{"meta":{"title":"钉子君","subtitle":"个人博客","description":"个人博客","author":"钉子君","url":"http://nanyu99.gitee.io","root":"/"},"pages":[{"title":"categories","date":"2021-03-05T13:58:49.000Z","updated":"2021-03-05T13:59:43.632Z","comments":true,"path":"categories/index.html","permalink":"http://nanyu99.gitee.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"3.Hive基本命令","date":"2021-03-05T09:19:59.912Z","updated":"2020-12-18T15:29:56.000Z","comments":true,"path":"2021/03/05/3.Hive基本命令/","link":"","permalink":"http://nanyu99.gitee.io/2021/03/05/3.Hive%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/","excerpt":"","text":"3.1 Beeline命令 Beeline是 Hive 0.11版本引入的新命令行客户端工具,基于SQLLine CLI的JDBC客户端。 Beeline支持内嵌模式(embedded mode)和远程模式(remote mode)。在嵌入式模式下，运行嵌入式的Hive(类似Hive CLI)，而远程模式可以通过Thrift连接到独立的HiveServer2进程上。从Hive 0.14版本开始，Beeline使用HiveServer2工作时，它也会从HiveServer2输出日志信息到STDERR。 Hive的三种安装方式 内嵌模式：不需要额外安装元数据库，采用的是Hive默认的Derby数据库，但这种模式有极大的缺陷就在于只允许一个 Hive 会话连接。 独立模式：在安装 Hive 的节点上安装一个 MySQL 服务端，并且将 hive.metastore.local 设置为 true 远程模式：将 Hive 服务端与元数据的存储地址分开，元数据直接存储在远程的数据库服务器上即可。因此这里我们采用的是 node01 安装 Hive 服务端，而node03 安装 MySQL，以此来实现 Hive 与元数据的解耦操作。 Beeline和其他工具有一些不同，执行查询都是正常的SQL输入。 create databases;【创建数据库】 select * from table_name;【查询表】 但是如果是一些管理的命令，比如进行连接，中断，退出，执行Beeline命令需要带上“!”，不需要终止符。 !connect url 【连接不同的Hive2服务器】 !exit 【退出shell】 !help 【显示全部命令列表】 !verbose 【显示查询追加的明细】 3.2 hive -e 不用进入交互窗口就能执行数据库相关命令 123456789101112131415161718[root@node02 ~]# hive -e &quot;show databases&quot;;## 以下是结果which: no hbase in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/apps/jdk1.8.0_261/bin:/opt/apps/jdk1.8.0_261/jre/bin:/opt/apps/hadoop-3.1.4/bin:/opt/apps/hadoop-3.1.4/sbin:/opt/apps/hive-3.1.2/bin:/root/bin)SLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:/opt/apps/hive-3.1.2/lib/log4j-slf4j-impl-2.10.0.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:/opt/apps/hadoop-3.1.4/share/hadoop/common/lib/slf4j-log4j12-1.7.25.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]Hive Session ID = e308f3e6-6cac-4e85-b4a1-2f53376dc53cLogging initialized using configuration in file:/opt/apps/hive-3.1.2/conf/hive-log4j2.properties Async: trueHive Session ID = 2b23427f-3062-4ad0-a6e4-5c51159af89dOKdatabase_namedefaultstudentteaceherTime taken: 3.745 seconds, Fetched: 3 row(s) 3.3 hive -f 不用进入交互窗口，用vim或vi创建一个文件，写入一些sql命令，通过hive -f 即可执行。 123456789101112131415161718192021[root@node02 apps]# vim hive.sql## 文件中的内容show databases;## 以下是执行结果[root@node02 apps]# hive -f hive.sqlwhich: no hbase in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/apps/jdk1.8.0_261/bin:/opt/apps/jdk1.8.0_261/jre/bin:/opt/apps/hadoop-3.1.4/bin:/opt/apps/hadoop-3.1.4/sbin:/opt/apps/hive-3.1.2/bin:/root/bin)SLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:/opt/apps/hive-3.1.2/lib/log4j-slf4j-impl-2.10.0.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:/opt/apps/hadoop-3.1.4/share/hadoop/common/lib/slf4j-log4j12-1.7.25.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]Hive Session ID = 1bf5a42e-f5e7-4bd4-87cb-a5d8aa719c62Logging initialized using configuration in file:/opt/apps/hive-3.1.2/conf/hive-log4j2.properties Async: trueHive Session ID = 1fe787c1-bac7-42bf-9cb6-2254f95fab17OKdatabase_namedefaultstudentteaceherTime taken: 3.399 seconds, Fetched: 3 row(s) 3.4 其他命令 退出hive客户端命令（非beeline模式下） 12hive(default)&gt;exit; hive(default)&gt;quit; 退出hive客户端命令（beeline模式下） 1hive(default)&gt;!quit; 通过客户端用命令行来查看HDFS的文件系统 123456hive (default)&gt; dfs -ls /;Found 4 itemsdrwxr-xr-x - root supergroup 0 2020-12-06 20:09 /datadrwxr-xr-x - root supergroup 0 2020-12-02 12:53 /hivedrwxr-xr-x - root supergroup 0 2020-11-03 16:42 /systemdrwxrwxrwx - root supergroup 0 2020-11-28 19:04 /tmp 查看本地的文件系统（即虚拟机上的文件系统） 123456hive (default)&gt; ! ls /opt/apps;datahadoop-3.1.4hive-3.1.2hive.sqljdk1.8.0_261 查看历史记录(即hive客户端的操作记录) 12345678## 必须进入主目录才行[root@node02 apps]# cat .hivehistorycat: .hivehistory: 没有那个文件或目录[root@node02 apps]# cd ~[root@node02 ~]# cat .hivehistoryexit;show tables;exit; 3.5 HQL HiveQL（简称HQL）是支持的类似的查询语言，HQL大体分为DDL、DDL、DML、UDF 四种类型。 DDL: （database definition language） 数据定义语言 引起的是结构上变化，不会影响数据 create drop alter DML: DataManipulationLanguage 数据操作语言 不会引起结构上的变化 引起的是数据的变化 update DQL: 数据查询语言 不会引起结构上的变化，也不会引起数据的变化，select where DDL可以创建数据库、创建表、进行数据库和表的删除；DML可以进行数据的添加、查询；UDF还支持用户自定义查询函数。 3.6 Hive之DDL （Database Definition Language） 数据定义语言 引起的是结构上变化，不会影响数据 create drop alter。 DDL主要负责的是数据库的创建、查看、修改、删除、表的创建、修改。（主要侧重于对数据库、表的操作） 内部表： 由Hive进行管理，创建内部表时，把内部表对应的数据会一并复制到对应的HDFS上（数据仓库）HIve所对应的目录下 外部表 不由Hive管理，在创建外部表时，同时指定一个指向实际数据的路径作为表的信息一同储存在映射表中，用户可以通过查询表中这一数据知道该映射结构表的实际数据在什么位置。创建外部表时，仅记录数据所在的路径，不会对数据位置进行任何改变 内部表和外部表的区别： 内部表和外部表在结构上没有任何区别，但在删除数据时，内部表可以用Hive进行删除，同时会把数据仓库上（HDFS上）对应的数据删掉。外部表则只是删除数据库中的数据信息，但不会真正的数据。 创建外部表时，要加一个External 分区表： 分区表实际上就是对应一个 HDFS 文件系统上的独立的文件夹，该文件夹下是该分区所有的数据文件。Hive 中的分区就是分目录，把一个大的数据集根据业务需要分割成小的数据集。在查询时通过 WHERE 子句中的表达式选择查询所需要的指定的分区，这样的查询效率会提高很多。（例如，将数科所有班级存入一张大表中（其实是个目录），为了利于管理，看起来更加系统，将这个大表进行分区，将数科191、数科192、数科201、数科202划分为四个区，辅导员需要哪个班级的数据时直接调对应分区的表即可。） ![](3.Hive基本命令.assets/Image 1.png) 数据库操作3.6.1 创建数据库创建数据库的SQL格式 123456789CREATE (DATABASE|SCHEMA) [IF NOT EXISTS] database_name [COMMENT database_comment] [LOCATION hdfs_path] [WITH DBPROPERTIES (property_name=property_value, ...)]; -------------------------------------------------------------------------------------- --(DATABASE|SCHEMA)：必须有的参数 -- [IF NOT EXISTS]：可有可无（判断数据库是否已经存在） -- [COMMENT database_comment]：可有可无，对数据库加以说明 -- [LOCATION hdfs_path]：指明数据库创建的路径 123456--if not exists 用于判断数据库是否已经存在，不存在就创建（可有可无），COMMENT用于对数据库做介绍（可有可无）create database if not exists books COMMENT &quot;第一个数据库&quot;;--什么也不加create database books;--指定创建位置create database books location &quot;/school&quot;; 3.6.2 查看数据库123456789101112131415161718--查看数据库show databases;--过滤显示数据库show databases like &quot;student&quot;;--显示数据库的基本信息desc database student;OKdb_name comment location owner_name owner_type parametersstudent hdfs://node01:9000/hive/warehouse/student.db root USER Time taken: 0.185 seconds, Fetched: 1 row(s)--显示数据库的详细信息 desc database extended student; OKdb_name comment location owner_name owner_type parametersstudent hdfs://node01:9000/hive/warehouse/student.db root USER Time taken: 0.108 seconds, Fetched: 1 row(s) 3.6.3 修改数据库1234567891011# 修改数据库的属性ALTER (DATABASE|SCHEMA) database_name SET DBPROPERTIES (property_name=property_value, ...);-- (注意: 在 Hive 0.14.0 增加了 SCHEMA 选项)# 修改数据库的拥有者和角色ALTER (DATABASE|SCHEMA) database_name SET OWNER [USER|ROLE] user_or_role; -- (注意: Hive 0.13.0 以上版本可用;在 Hive 0.14.0 增加了 SCHEMA 选项)# 修改数据库的存储路径ALTER (DATABASE|SCHEMA) database_name SET LOCATION hdfs_path;-- (注意: Hive 2.2.1, 2.4.0以及以上版本可用) 3.6.4 删除数据库123456--删除空数据库drop database books;--如果存在的话删除空数据库drop database if exists books;--强制删除数据库drop database books cascade; 表操作3.6.3 创建内部表12345678910111213141516171819create table if not exists studen( stuid int, --学生学号 stuname string, --学生姓名 stuage int --学生年龄)-- 每行字段以 \\t分割row format delimited fields terminated by &#x27;\\t&#x27;-- 根据查询结果创建表：有数据create table if not exists student2 as select * from student;create table if not exists student4 as select count(*) from teacher1;--根据已经存在的表创建表（类似复制一张表）create table if not exists student3 like student;OKstudent3.sno student3.sname student3.sage student3.ssexTime taken: 0.773 seconds 加载数据到表中 1load data local inpath &#x27;/opt/apps/data/teacher.txt&#x27; into table teacher; 查看表的类型 1desc formatted student3; 3.6.4 创建外部表外部表的创建与内部表没什么区别，只不过是在创建时要加上一个**external**关键字即可。 123456create external table tea( stuid int, stuname string, stuage int)row format delimited fields terminated by &#x27;\\t&#x27;; 加载数据到表中 1load data local inpath &#x27;/opt/apps/data/teacher.txt&#x27; into table teacher; 查看数据 1select * from ext_stu; 查询表的类型 1desc formatted ext_stu; 删除表 12drop table tea;drop table student3; 3.6.5 创建分区表 创建分区表 123create table student(id int,name string )partitioned by(day string comment &#x27;study&#x27;)row format delimited fields terminated by &#x27;\\t&#x27;; 上传数据到分区中 1load data local inpath &#x27;/opt/apps/data/student.txt&#x27; into table student partition (day=&#x27;01&#x27;); 增加分区 1234--增加单分区alter table student add partition(day=&#x27;05&#x27;);--增加多分区alter table student add partition(day=&#x27;06&#x27;) partition(day=&#x27;07&#x27;); 删除分区 1alter table student4 drop partition (day=&#x27;183&#x27;); 查看分区结构 1desc formatted student; study.db为数据库；student为表（其实再HDFS文件系统中是一个目录）；表里面的day05、day06、day07、day08为分区表。 创建二级分区 123create table teacher(id int,name string)partitioned by(day string ,month string )row format delimited fields terminated by &#x27;\\t&#x27;; 分区数据关联的三种方式 1234567891011121314151617181920-- 方式一：先hadoop上传，后修复dfs -put /opt/data/student.txt /hive/warehouse/student.db/student/day=04;-- 查看select * from student;-- 执行修复msck repair table student;-- 查看select * from student;-- 方式二：先hadoop上传，后修改dfs -mkdir /hive/warehouse/study.db/student/day=06;dfs -put /opt/data/teacher /hive/warehouse/study.db/student/day=06;alter table student add partition(day=&#x27;06&#x27;);-- 方式三：先上传，后加载dfs -mkdir /hive/warehouse/study.db/student/day=07;load data local inpath &#x27;/opt/data/teacher.txt&#x27; into table student partition(day=&#x27;07&#x27;); 3.6.6 修改表 表的重命名 1alter table student rename to student6; 添加列 1alter table student6 add columns(new string); 更改列：将某一列更改 1alter table student6 change column new bb string; 替换所有列：后面跟的是新的列名 1alter table student6 replace columns(ids int,names string,newb string); 修改内部表 student2 为外部表 1alter table student2 set tblproperties(&#x27;EXTERNAL&#x27;=&#x27;TRUE&#x27;); 3.7 Hive之DML Hive 数据真正存放在 Hadoop 之上，因此最简单的数据导入方式就是将数据上传至 HDFS 相应目录即可，但是此操作会非常不方便，因此 Hive 为我们提供了以下数据加载的方式。 DML负责数据的导入、导出、更新、删除等操作（主要负责对数据的操作）。 3.7.1 数据导入Hive的数据是存放在Hadoop之上的，因此Hive在处理数据时需要将数据上传到HDFS中去。比如创建内部表时，需要将数据复制到HDFS上指定的目录中去。 Hive提供以下五种数据上传到HDFS上的方法，分别是：Load模式、Import模式、Insert模式、as select模式、Location模式 3.7.1.1 导入数据（Load模式）创建普通数据表 12create table test(id int,name string) row format delimited fields terminated by &#x27;\\t&#x27;; 从本地(Linux)上传数据 1load data local inpath &#x27;/opt/data/student&#x27; into table test; 从本上传数据并覆盖原有 1load data local inpath &#x27;/opt/data/student&#x27; overwrite into table test; 创建分区表 123create table test02(id int,name string)partitioned by (num string)row format delimited fields terminated by &#x27;\\t&#x27;; 向分区表中加载数据 1load data local inpath &#x27;/opt/apps/data/student.txt&#x27; into table test02 partition (num=&#x27;01&#x27;); 向分区表中加载数据,但是不指定分区(可以上传成功,但会报错) 12345678910111213141516171819202122load data local inpath &#x27;/opt/apps/data/student.txt&#x27; into table test02;## 错误如下Query ID = root_20201218174108_6408e79a-4ec5-4aa1-9d5e-52558c638b98Total jobs = 3Launching Job 1 out of 3Number of reduce tasks not specified. Estimated from input data size: 1In order to change the average load for a reducer (in bytes): set hive.exec.reducers.bytes.per.reducer=&lt;number&gt;In order to limit the maximum number of reducers: set hive.exec.reducers.max=&lt;number&gt;In order to set a constant number of reducers: set mapreduce.job.reduces=&lt;number&gt;Starting Job = job_1608280545793_0001, Tracking URL = http://node02:8088/proxy/application_1608280545793_0001/Kill Command = /opt/apps/hadoop-3.1.4/bin/mapred job -kill job_1608280545793_0001Hadoop job information for Stage-1: number of mappers: 0; number of reducers: 02020-12-18 17:41:19,840 Stage-1 map = 0%, reduce = 0%Ended Job = job_1608280545793_0001 with errorsError during job, obtaining debugging information...FAILED: Execution Error, return code 2 from org.apache.hadoop.hive.ql.exec.mr.MapRedTaskMapReduce Jobs Launched: Stage-Stage-1: HDFS Read: 0 HDFS Write: 0 FAILTotal MapReduce CPU Time Spent: 0 msec 3.7.2 导入数据(insert模式) 也可以使用 insert 子句将查询结果插入表中 (这种插入方法只能一条一条的插入)。 创建分区表 123create table test03(id int ,name string) partitioned by(age int) row format delimited fields terminated by &#x27;\\t&#x27;; 向分区表中加载数据 1insert into table test03 partition(age=1) values(1001,&#x27;zhangsan&#x27;),(1002,&#x27;lisi&#x27;);","categories":[],"tags":[]},{"title":"","slug":"2.Hive环境配置","date":"2021-03-05T09:19:55.525Z","updated":"2020-12-03T01:42:16.000Z","comments":true,"path":"2021/03/05/2.Hive环境配置/","link":"","permalink":"http://nanyu99.gitee.io/2021/03/05/2.Hive%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Hive是基于Hadoop的一个数据仓库工具，因此Hive的安装前提必须是Hadoop能够正常运行。 2.1 Hive安装模式 根据元数据的位置，将Hive的安装分为三个模式：内嵌模式、独立模式、远程模式（最复杂） 1.1.1 Hive内嵌安装模式不需要额外安装元数据库，采用Hive默认的Derby数据库，但这种模式有极大的缺陷就在于只允许一个 Hive 会话连接。 1.1.2 Hive独立安装模式一个节点即做服务端，也做客户端。在安装 Hive 的节点上安装一个 MySQL 服务端，并且将 hive.metastore.local 设置为 true，配置 MySQL 地址和用户名密码即可。 1.1.3 Hive远程安装模式（√）将 Hive 服务端与元数据的存储地址分开，元数据直接存储在远程的数据库服务器上即可。 因此node01 安装 Hive 服务端，node02安装Hive客户端 ，node03 安装 MySQL，以此来实现 Hive 与元数据的解耦操作。 2.2所需软件合集 Mysql:官网下载地址 下载版本如下： Hive：官网下载地址 ​ 下载版本如下 2.3 安装Mysql 2.3.1 安装Mysql下载Mysql，在其中一台节点上安装就行（这里选择在node03上安装Mysql） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859## 1、先卸载node03上的数据库mariadb，不卸载会报错[root@node03 ~]# rpm -qa | grep mariadbmariadb-libs-5.5.65-1.el7.x86_64[root@node03 ~]# rpm -e --nodeps mariadb-libs-5.5.65-1.el7.x86_64## 2、安装 net-tools 工具，否则会报缺少依赖的错[root@node03 ~]# yum -y install net-tools## 3、安装 perl,否则会报缺少依赖的错误[root@node03 ~]# yum -y install perl## 4、上传Mysql压缩包到node03上## 创建一个新的文件夹用于存放安装包[root@node03 ~]# mkdir /opt/apps/Mysql[root@node03 ~]# cd /opt/apps/[root@node03 apps]# lsHadoop Java Mysql## 上传Mysql压缩包到node03的/opt/SoftWare/Mysql目录中[root@node03 ~]# cd /opt/SoftWare/Mysql## 安装上传下载软件[root@node03 Mysql]# yum -y install lrzsz[root@node03 Mysql]# rz[root@node03 Mysql]# lsmysql-5.7.32-1.el7.x86_64.rpm-bundle.tar## 5、解包（并非解压）[root@node03 Mysql]# tar -xvf mysql-5.7.28-1.el7.x86_64.rpm-bundle.tar mysql-community-client-5.7.32-1.el7.x86_64.rpmmysql-community-common-5.7.32-1.el7.x86_64.rpmmysql-community-devel-5.7.32-1.el7.x86_64.rpmmysql-community-embedded-5.7.32-1.el7.x86_64.rpmmysql-community-embedded-compat-5.7.32-1.el7.x86_64.rpmmysql-community-embedded-devel-5.7.32-1.el7.x86_64.rpmmysql-community-libs-5.7.32-1.el7.x86_64.rpmmysql-community-libs-compat-5.7.32-1.el7.x86_64.rpmmysql-community-server-5.7.32-1.el7.x86_64.rpmmysql-community-test-5.7.32-1.el7.x86_64.rpm## 开始安装，安装的顺序不能乱[root@node03 Mysql]# rpm -ivh mysql-community-common-5.7.32-1.el7.x86_64.rpm警告：mysql-community-common-5.7.32-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY准备中... ################################# [100%]正在升级/安装... 1:mysql-community-common-5.7.32-1.e################################# [100%][root@node03 Mysql]# rpm -ivh mysql-community-libs-5.7.32-1.el7.x86_64.rpm 警告：mysql-community-libs-5.7.32-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY准备中... ################################# [100%]正在升级/安装... 1:mysql-community-libs-5.7.32-1.el7################################# [100%][root@node03 Mysql]# rpm -ivh mysql-community-libs-compat-5.7.32-1.el7.x86_64.rpm 警告：mysql-community-libs-compat-5.7.32-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY准备中... ################################# [100%]正在升级/安装... 1:mysql-community-libs-compat-5.7.3################################# [100%][root@node03 Mysql]# rpm -ivh mysql-community-client-5.7.32-1.el7.x86_64.rpm 警告：mysql-community-client-5.7.32-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY准备中... ################################# [100%]正在升级/安装... 1:mysql-community-client-5.7.32-1.e################################# [100%][root@node03 Mysql]# rpm -ivh mysql-community-server-5.7.32-1.el7.x86_64.rpm 警告：mysql-community-server-5.7.32-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY准备中... ################################# [100%]正在升级/安装... 1:mysql-community-server-5.7.32-1.e################################# [100%] 2.3.2 启动Mysql服务1234567891011121314151617181920212223242526272829## 1、启动Mysql服务[root@node03 Mysql]# systemctl start mysqld## 2、查看Mysql状态[root@node03 Mysql]# systemctl status mysqld● mysqld.service - MySQL Server Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled) Active: active (running) since 六 2020-11-28 15:12:41 CST; 2min 0s ago Docs: man:mysqld(8) http://dev.mysql.com/doc/refman/en/using-systemd.html Process: 1394 ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid $MYSQLD_OPTS (code=exited, status=0/SUCCESS) Process: 1345 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS) Main PID: 1397 (mysqld) CGroup: /system.slice/mysqld.service └─1397 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid11月 28 15:12:36 node03 systemd[1]: Starting MySQL Server...11月 28 15:12:41 node03 systemd[1]: Started MySQL Server.## 3、设置开机自启动[root@node03 Mysql]# systemctl enable mysqld## 4、删除安装包（节省空间）[root@node03 Mysql]# lsmysql-5.7.32-1.el7.x86_64.rpm-bundle.tar mysql-community-embedded-devel-5.7.32-1.el7.x86_64.rpmmysql-community-client-5.7.32-1.el7.x86_64.rpm mysql-community-libs-5.7.32-1.el7.x86_64.rpmmysql-community-common-5.7.32-1.el7.x86_64.rpm mysql-community-libs-compat-5.7.32-1.el7.x86_64.rpmmysql-community-devel-5.7.32-1.el7.x86_64.rpm mysql-community-server-5.7.32-1.el7.x86_64.rpmmysql-community-embedded-5.7.32-1.el7.x86_64.rpm mysql-community-test-5.7.32-1.el7.x86_64.rpmmysql-community-embedded-compat-5.7.32-1.el7.x86_64.rpm[root@node03 Mysql]# rm -rf mysql-*[root@node03 Mysql]# ls 2.3.3 修改Root密码123456789101112131415161718## 1、 在日志文件中查看mysql的root用户默认密码## 如下，默认密码为root@localhost:后面的内容，即：4uNuB5DdiX+X[root@node03 Mysql]# grep &#x27;temporary password&#x27; /var/log/mysqld.log2020-11-28T07:12:38.953216Z 1 [Note] A temporary password is generated for root@localhost: 4uNuB5DdiX+X## 2、取消密码检查策略s## 修改/etc/my.cnf文件，在文件中添加以下内容以禁用密码策略## validate_password=off（必须手敲，不能拷贝，拷贝会报错）[root@node03 Mysql]# vim /etc/my.cnf## 3、重启Mysql服务[root@node03 Mysql]# systemctl restart mysqld## 4、进入mysql，并输入4uNuB5DdiX+X密码[root@node03 Mysql]# mysql -uroot -pEnter password: 4uNuB5DdiX+X## 5、修改密码为123456mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;Query OK, 0 rows affected (0.01 sec)## 6、退出mysql的命令mysql&gt; exit 2.3.3.1 为什么要禁用密码策略mysql中的密码策略规定，密码不能太过于简单；必须要有大小写；长度必须符合规定等限制。如果没有取消密码策略检查，则在mysql5.7中必然会报错，让你修改密码。 123456789101112131415161718## 密码策略示意表mysql&gt; show variables like &#x27;%password%&#x27;;+----------------------------------------+-----------------+| Variable_name | Value |+----------------------------------------+-----------------+| default_password_lifetime | 0 || disconnect_on_expired_password | ON || log_builtin_as_identified_by_password | OFF || mysql_native_password_proxy_users | OFF || old_passwords | 0 || report_password | || sha256_password_auto_generate_rsa_keys | ON || sha256_password_private_key_path | private_key.pem || sha256_password_proxy_users | OFF || sha256_password_public_key_path | public_key.pem |+----------------------------------------+-----------------+10 rows in set (0.01 sec) 2.3.4 修改数据库编码为UTF-8123## 在/etc/my.cnf文件中的添加以下内容character_set_server=utf8init_connect=&#x27;SET NAMES utf8&#x27; 2.3.5 添加Root用户的登录权限默认只允许 root 帐户在本地登录，如果要在其它机器上连接 MySQL，必须修改 root 允许远程连接，或者添加一个允许远程连接的帐户 12345678910## 1. 进入mysql[root@master SoftWare]# mysql -uroot -p123456## 2. 修改root的远程访问权限## root代表用户名， %代表任何主机都可以访问， 123456为root访问的密码mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27; WITH GRANT OPTION; ## 3. flush privileges 刷新MySQL的系统权限，使其即时生效，否则就重启服务器mysql&gt; FLUSH PRIVILEGES;## 4. 退出mysql&gt; exit; 2.4 安装Hive #### 2.4.1 上传解压Hive压缩包配置环境变量 在node01和node02上都要执行一遍。 1234567891011121314151617181920212223242526272829## 1、创建新的目录用于存放Hive安装包[root@node01 ~]# mkdir /opt/apps/Hive[root@node01 ~]# cd /opt/apps[root@node01 apps]# lsHadoop3.1.4 Hive JDK1.8## 2、上传Hive安装包到Hive文件中[root@node01 Hive]# rz## 3、解压Hive安装包[root@node01 Hive]# lsapache-hive-3.1.2-bin-hadoop-3.1.4.tar.gz[root@node01 Hive]# tar -zxf apache-hive-3.1.2-bin-hadoop-3.1.4.tar.gz ## 4、重命名文件，方便使用[root@node01 Hive]# mv apache-hive-3.1.2-bin hive-3.1.2[root@node01 Hive]# lsapache-hive-3.1.2-bin-hadoop-3.1.4.tar.gz hive-3.1.2## 5、删除Hive安装包[root@node01 Hive]# rm -rf apache-hive-3.1.2-bin-hadoop-3.1.4.tar.gz[root@node01 Hive]# ls hive-3.1.2## 6、配置环境变量[root@node01 Hive]# cd hive-3.1.2/[root@node01 hive-3.1.2]# pwd/opt/apps/Hive/hive-3.1.2## 编辑 profile 文件，添加以下环境变量内容[root@node01 hive-2.3.6]# vim /etc/profile## Hive 环境变量##Hiveexport HIVE_HOME=/opt/apps/Hive/hive-3.1.2export PATH=$PATH:$HIVE_HOME/bin 2.4.2 修改相关配置文件2.4.2.1 Server端配置（node01）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556## 新建一个conf文件，在里面创建hive-site.xml配置文件，并添加一下内容[root@node01 hive-3.1.2]# vim conf/hive-site.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt; &lt;property&gt;&lt;!--数据库连接地址，使用MySQL存储元数据信息--&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://node03:3306/metastore?createDatabaseIfNotExist=true&amp;amp;useSSL=false&lt;/value&gt; &lt;/property&gt; &lt;property&gt;&lt;!--数据库驱动--&gt; &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;property&gt;&lt;!--数据库用户名--&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;root&lt;/value&gt; &lt;/property&gt; &lt;property&gt;&lt;!--密码--&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;123456&lt;/value&gt; &lt;/property&gt; &lt;property&gt;&lt;!--HDFS路径，用于存储不同 map/reduce 阶段的执行计划和这些阶段的中间输出结果。--&gt; &lt;name&gt;hive.exec.local.scratchdir&lt;/name&gt; &lt;value&gt;/hive/tmp&lt;/value&gt; &lt;/property&gt; &lt;property&gt;&lt;!--HDFS路径，本地表的默认位置--&gt; &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt; &lt;value&gt;/hive/warehouse&lt;/value&gt; &lt;/property&gt; &lt;property&gt;&lt;!--本地路径：Hive 查询日志所在的目录，如果该值为空，将不创建查询日志。--&gt; &lt;name&gt;hive.querylog.location&lt;/name&gt; &lt;value&gt;/tmp/hive/logs&lt;/value&gt; &lt;/property&gt; &lt;property&gt;&lt;!--本地路径：Hive操作日志--&gt; &lt;name&gt;hive.server2.logging.operation.log.location&lt;/name&gt; &lt;value&gt;/tmp/hive/logs&lt;/value&gt; &lt;/property&gt; &lt;property&gt;&lt;!--本地路径：远程资源下载的临时目录--&gt; &lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt; &lt;value&gt;/tmp/hive/resources&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;!-- hiveserver2用户名 --&gt; &lt;name&gt;beeline.hs2.connection.user&lt;/name&gt; &lt;value&gt;root&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;!-- hiveserver2密码 --&gt; &lt;name&gt;beeline.hs2.connection.password&lt;/name&gt; &lt;value&gt;123456&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 2.4.2.2 Client端配置（node02）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748## 新建一个conf文件，在里面创建hive-site.xml配置文件，并添加一下内容[root@node02 hive-2.3.6]# vi conf/hive-site.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt; &lt;property&gt;&lt;!--这里配置的是否启用本地服务器连接Hive，这里我们是客户端和服务端分开的一个配置，所以这里设置为false.--&gt; &lt;name&gt;hive.metastore.local&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; &lt;property&gt;&lt;!--HDFS路径，用于存储不同 map/reduce 阶段的执行计划和这些阶段的中间输出结果。--&gt; &lt;name&gt;hive.exec.local.scratchdir&lt;/name&gt; &lt;value&gt;/hive/tmp&lt;/value&gt; &lt;/property&gt; &lt;property&gt;&lt;!--本地表的默认位置--&gt; &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt; &lt;value&gt;/hive/warehouse&lt;/value&gt; &lt;/property&gt; &lt;property&gt;&lt;!--Hive连接到该URI请求远程元存储的元数据--&gt; &lt;name&gt;hive.metastore.uris&lt;/name&gt; &lt;value&gt;thrift://node01:9083&lt;/value&gt; &lt;/property&gt; &lt;property&gt;&lt;!--本地路径：Hive 查询日志所在的目录，如果该值为空，将不创建查询日志。--&gt; &lt;name&gt;hive.querylog.location&lt;/name&gt; &lt;value&gt;/tmp/hive/logs&lt;/value&gt; &lt;/property&gt; &lt;property&gt;&lt;!--本地路径：Hive操作日志--&gt; &lt;name&gt;hive.server2.logging.operation.log.location&lt;/name&gt; &lt;value&gt;/tmp/hive/logs&lt;/value&gt; &lt;/property&gt; &lt;property&gt;&lt;!--本地路径：远程资源下载的临时目录--&gt; &lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt; &lt;value&gt;/tmp/hive/resources&lt;/value&gt; &lt;/property&gt; &lt;property&gt;&lt;!--显示当前所使用的数据库--&gt; &lt;name&gt;hive.cli.print.current.db&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt;&lt;!--显示表头--&gt; &lt;name&gt;hive.cli.print.header&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 2.4.3 添加Mysql驱动服务端（node01）与客户端（node02）都需要将驱动jar包上传至lib目录下 123456## 上传驱动jar包到lib目录下[root@node02 hive-3.1.2]# cd lib/[root@node02 lib]# rz -Erz waiting to receive.[root@node02 lib]# ls mysql-*mysql-connector-java-5.1.49.jar mysql-metadata-storage-0.12.0.jar 2.4.4 修改日志文件Hive 的 log 默认存放在 /tmp/root/hive.log目录下（当前用户名下），可以对其进行修改，两台节点均需要配置 12345## 重新复制一份log4j配置文件，从Hive 2.1.0 开始，使用的是log4j2。[root@node01 hive-3.1.2]# cp conf/hive-log4j2.properties.template conf/hive-log4j2.properties[root@node01 hive-3.1.2]# vi conf/hive-log4j2.properties## 修改下面的内容property.hive.log.dir = /opt/apps/hive-3.1.2/logs 2.4.5 格式化Hive先修改Hadoop的相关配置，否则会报错。 1234567891011121314## 1. 修改 Hadoop 中的 core-site.xml 配置文件[root@node01 Hive]# vi /opt/SoftWare/Hadoop/hadoop-2.7.7/etc/hadoop/core-site.xml## 添加以下内容&lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt; &lt;value&gt;root&lt;/value&gt; &lt;description&gt;Allow the superuser oozie to impersonate any members of the group group1 and group2 &lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt; &lt;value&gt;*&lt;/value&gt; &lt;description&gt;The superuser can connect only from host1 and host2 to impersonate a user&lt;/description&gt;&lt;/property&gt; 在node01上格式化Hive 1234567891011121314[root@node01 hive-2.3.6]# schematool -initSchema -dbType mysqlSLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:/opt/SoftWare/Hive/hive-2.3.6/lib/log4j-slf4j-impl-2.6.2.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:/opt/SoftWare/Hadoop/hadoop-2.7.7/share/hadoop/common/lib/slf4j-log4j12-1.7.10.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]Metastore connection URL: jdbc:mysql://node03:3306/metastore?createDatabaseIfNotExist=true&amp;useSSL=falseMetastore Connection Driver : com.mysql.jdbc.DriverMetastore connection User: rootStarting metastore schema initialization to 2.3.0Initialization script hive-schema-2.3.0.mysql.sqlInitialization script completedschemaTool completed 2.4.6 启动Hive两种方式区别 方式一：只要是支持Jdbc的，都能连接（支持的是Jdbc协议） 方式二：必须使用hive客户端才能连接（支持的是thrift协议） 先启动Hadoop集群 启动方法1 1234567891011121314151617181920## 1. 启动服务端 将启动时的结果输出到null中（扔掉） &amp;表示后台运行，在前台不显示[root@node01 hive-3.1.2]# hiveserver2 &gt; /dev/null 2&gt;&amp;1 &amp;## 2. 查询服务端进程 ID[root@node01 hive-3.1.2]# ps -aux| grep hiveserver2root 13931 1.0 11.1 2344932 431620 pts/0 Sl 00:10 0:16## 3. 停止服务端【这里暂时不操作，关闭 Hive 的时候操作】[root@node01 hive-3.1.2]# kill -9 13931##4.先关闭Hadoop集群的安全模式[root@node01 ~]# hdfs dfsadmin -safemode leave //集群退出安全模式Safe mode is OFF## 5. 启动客户端[root@node02 hive-3.1.2]# beeline -u jdbc:hive2://node01:10000 -n root -p 1234560: jdbc:hive2://node01:10000&gt; show tables;+-----------+| tab_name |+-----------+ |+-----------+1 row selected (0.616 seconds) 启动方法2 123456789101112131415## 1. 启动服务端[root@node01 hive-2.3.6]# hive --service metastore &gt; /dev/null 2&gt;&amp;1 &amp;## 2. 查看服务端进程 ID[root@node01 hive-2.3.6]# ps -aux| grep metastoreroot 14342 5.5 8.9 2297776 345508 pts/0 Sl 01:18 0:09## 3. 杀死服务进程[root@node01 hive-2.3.6]# kill -9 14342## 4. 启动客户端[root@node02 hive-2.3.6]# hivehive (default)&gt; show tables;OKtab_namestudent2Time taken: 0.755 seconds, Fetched: 1 row(s)hive (default)&gt; exit; 启动方法3 12345678910111213141516171819202122## 1. 启动服务端[root@node01 hive-2.3.6]# hive --service metastore &gt; /dev/null 2&gt;&amp;1 &amp;## 2. 查看服务端进程 ID[root@node01 hive-2.3.6]# ps -aux| grep metastoreroot 14342 5.5 8.9 2297776 345508 pts/0 Sl 01:18 0:09## 3. 杀死服务进程[root@node01 hive-2.3.6]# kill -9 14342## 4. 启动客户端（用的比较多的方法，因为可以写脚本）[root@node02 hive-2.3.6]# hive -e &quot;show tables;&quot;which: no hbase in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/SoftWare/Java/jdk1.8.0_212/bin:/opt/SoftWare/Java/jdk1.8.0_212/jre/bin:/opt/SoftWare/Hadoop/hadoop-2.7.7/bin:/opt/SoftWare/Hadoop/hadoop-2.7.7/sbin:/root/bin:/opt/SoftWare/Java/jdk1.8.0_212/bin:/opt/SoftWare/Java/jdk1.8.0_212/jre/bin:/opt/SoftWare/Hadoop/hadoop-2.7.7/bin:/opt/SoftWare/Hadoop/hadoop-2.7.7/sbin:/opt/SoftWare/Hive/hive-2.3.6/bin)SLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:/opt/SoftWare/Hive/hive-2.3.6/lib/log4j-slf4j-impl-2.6.2.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:/opt/SoftWare/Hadoop/hadoop-2.7.7/share/hadoop/common/lib/slf4j-log4j12-1.7.10.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]Logging initialized using configuration in file:/opt/SoftWare/Hive/hive-2.3.6/conf/hive-log4j2.properties Async: trueOKtab_namestudent2Time taken: 1.274 seconds, Fetched: 1 row(s)","categories":[],"tags":[]},{"title":"","slug":"1.Hive入门","date":"2021-03-05T09:19:52.193Z","updated":"2020-11-28T05:50:10.000Z","comments":true,"path":"2021/03/05/1.Hive入门/","link":"","permalink":"http://nanyu99.gitee.io/2021/03/05/1.Hive%E5%85%A5%E9%97%A8/","excerpt":"","text":"1.1 Hive 是什么 Hive是领英公司开发，是基于Hadoop的一个开源**数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行，需要注意的是，Hive它并不是数据库。** 数据仓库：数据仓库注重存储、查询数据（并不注重对数据的查删改等操作） 数据库：数据库注重管理数据，比如对数据的增删改查等操作。 **Mysql\\Oracle:**数据库管理软件。 Hive 提供了一系列的工具，可以用来进行数据的提取、转换和加载【ETL】，是一种可以存储、查询和分析存储在 Hadoop中的大规模数据的架构体系。 1.2 为什么要有Hive Hive 简化了 MapReduce 的开发难度，只要会 SQL，不需要去实现底层Map Reduce代码，就能快速的上手 Hive，通过简单的 SQL 语句就能实现复杂的 MapReduce 所能达到的功能。（通过简单的Sql语句，即可实现MapReduce大多数功能） 1.3 Hive的优点 简单容易上手操作接口采用类 SQL 语法，提供快速开发的能力。 学习成本低避免了去写MapReduce，减少开发人员的学习成本。 可扩展Hive 可以自由扩展集群规模，一般情况下不需要重启服务 延展性Hive支持用户自定义函数，用户可以根据自己的需求来实现自己的函数 容错性良好的容错性，即使节点出现问题 SQL 仍能够正常完成 1.4 Hive的缺点 Hive 的 HQL 表达能力有限迭代式算法无法表达，比如 pagerank 。数据挖掘方面，比如 k-means . Hive 的效率比较低Hive 自动生成的 MapReduce 作业，通常情况下不够智能化 Hive 调优比较困难，粒度较粗 Hive 可控性差 1.5 Hive与传统数据库的比较 项目 Hive 传统数据库 查询语言 HiveQL SQL 存储 HDFS【理论上无限存储】 存储有限，随着容量增加，计算速度急剧下降 执行引擎 依赖于 MR/Spark框架，无法进行良好的性能优化 可以选择更加有效的算法执行查询，以此提高执行效率 灵活性 元数据独立存储，数据存储在HDFS上，耦合度降低 数据用途单一，耦合度高 执行效率 在大数据情况下，执行效率远远高于传统数据库 在少量数据情况下，比较快 延迟性 高 低 数据加载模式 读时模式 写时模式 数据操作 数据覆盖追加 行级更新删除 索引 0.7.0版本后加入，索引比较简单 复杂索引 事务 支持，只能对数据库和表设置锁 完全支持，具备完善的事务机制 可靠性 借助于 HDFS 数据有备份 需要设置数据库的热备，以防止丢失 基本环境 应用场景 大规模数据分析查询 小规模数据的实时查询 费用 开源，免费 商业应用，收费较高","categories":[],"tags":[]},{"title":"","slug":"2.JS学习","date":"2021-03-05T09:19:44.418Z","updated":"2021-02-24T05:41:56.431Z","comments":true,"path":"2021/03/05/2.JS学习/","link":"","permalink":"http://nanyu99.gitee.io/2021/03/05/2.JS%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"2.1 初识JavaScript 由布兰登艾奇发明，最初命名为LiveScript，最后与网景公司合作，改名为JavaScript(简称JS)，但JS与Java没有任何关系。 2.1.1 什么是JS JavaScript是世界上最流行的语言之一, 是一种运行在客户端的脚本语言( Script是脚本的意思) 脚本语言:不需要编译,运行过程中由js解释器(js引擎)逐行来进行解释并执行 现在也可以基于Node.js技术进行服务器端编程 2.1.2JS能做什么 表单动态校验 (密码强度检测) ( JS产生最初的目的) 网页特效 服务端开发(Node.js) 桌面程序(Electron) App(Cordova) 控制硬件-物联网(Ruff) 游戏开发(cocos2d-js) 2.1.3 JS/CSS/HTML区别与联系 描述类语言：HTML/CSS标记语言 HTML：html决定网页结构和内容（决定人看到什么），相当于人的身体。 CSS：CSS决定网页呈现给用户的样式，相当于人化妆、穿衣服。 编程类语言：JS脚本语言 JS：实现页面控制（决定功能）和业务逻辑，相当于人的各种动作。 2.1.4 浏览器执行JS原理 浏览器分成两部分:渲染引擎和JS引擎 渲染引擎:用来解析HTML与CSS ，俗称内核,比如chrome浏览器的blink ,老版本的webkit。 JS引擎:也称为JS解释器，用来读取网页中的JavaScript代码,对其处理后运行,比如chrome浏览器的V8。 浏览器本身并不会执行S代码，而是通过内置JavaScript引擎(解释器)来执行JS代码。 JS 引擎执行代码时逐行解释每一句源码(转换为机器语言) ，然后由计算机去执行,，以JavaScript语言归为脚本语言，会逐行解释执行。 2.1.5 JS三部分组成 ECMAScript: **ECMAScript**是由ECMA国际(原欧洲计算机制造商协会)进行标准化的一编程语言, 这种语言在万维网上应用广 泛，ECMAScript规定了JS的编程语法和基础核心知识,是所有浏览器厂商共同遵守的一套S语法工业标准。它往往被 称为JavaScript或JScript ，但实际上后两者是ECMAScript语言的实现和扩展，可简单理解为ECMAScript就是JS。 DOM-文档对象模型： 文档对象模型( Document Object Model ，简称DOM)，是W3C组织推荐的处理可扩展标记语言的标准编程接口。 通过DOM提供的接口可以对页面上的各种元素进行操作(大小、位置、颜色等)。 BOM-浏览器对象模型： 浏览器对象模型(Browser Object Model ，简称BOM)，是指浏览器对象模型，它提供了独立于内容的、可以与浏览 器窗口进行互动的对象B结构。通过BOM可以操作浏览器窗口,比如B弹出框、控制浏览器跳转、获取分辨率等。 2.1.6JS三种书写方式 JS有三种书写方式（与CSS相同），分别为行内式、内嵌式、外联式 行内式（一般不使用）： 内嵌式（使用最多）： alert('JS测试') 外联式： 2.1.7输入输出语句 prompt用法： // 用户输入框 prompt(‘请输入姓名’); alter用法： // 弹出框 alert(‘南雨’); console.log用法： // 输出到控制台，用于程序员观看分析 console.log(‘程序员观看’); 2.2变量 白话:变量就是一个装东西的盒子。 通俗:变量是用于存放数据的容器。我们通过变量名获取数据，甚至数据可以修改。 本质:变量是程序在内存中申请的一块用来存放数据的空间。 2.2.1 变量的使用 变量在使用时分为两部分：声明变量、赋值 变量使用方法一： 12345//生命变量var age;//给变量赋值age=12;console.log(&#x27;程序员:&#x27; + yourname + &#x27;观看&#x27;); 变量使用方法二： 123//声明变量并赋值var age=12;alert(yourname); 变量使用方法三： 1234// 用户输入框var yourname = prompt(&#x27;请输入姓名&#x27;);// 弹出框alert(yourname); var是一个JS关键字，用来声明变量( variable变量的意思)。使用该关键字声明变量后，计算机会自动为变量分配内 存空间，不需要程序员管。 age是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间。 2.2.2 变量的使用 **变量重新赋值：** 123456// 用户输入框var yourname = prompt(&#x27;请输入姓名&#x27;);// 输出到控制台，用于程序员观看分析console.log( yourname);yourname = &quot;石雨&quot;;console.log(yourname); 申请多变量： 1234var myname = &quot;丁志君&quot;, age = 18, salary = 2000;console.log(myname);console.log(age);console.log(salary); 只声明变量不赋值： 123//只声明变量不赋值，系统无法识别，结果是undefined，未识别的var myname console.log(myname); 不声明变量直接赋值： 123//不声明变量直接赋值，可以直接使用myname=1000console.log(myname); 变量值的交换： 12345678var temp;var qing = &quot;青苹果&quot;var hong = &quot;红苹果&quot;temp = qing;qing = hong;hong = temp;console.log(qing);console.log(hong); 2.2.3 变量的命名规范 由字母(A-Za-z)、数字(0-9)、 下划线( )、元符号($ )组成，如: usrAge, num01, name+ 严格区分大小写。var app；和var App；是两个变量 不能以数字开头。18age 是错误的 不能是关键字、保留字。例如: var、for、 while 变量名必须有意义。MMD BBD n|- → age . 遵守驼峰命名法。首字母小写,后面单词的首字母需要大写 myFirstName 2.3 数据类型 在计算机中,不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。 变量是用来存储值的所在处,它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算的 内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型,在程序运行过程中，类型会被自动确定。 1234// int num = 10; javavar num;//这里的num我们是不确定属于哪种数据类型的var num =10; // num属于数字型//js的变量数据类型是只有程序在运行过程中，根据等号右边的值来确定的 在代码运行时，变量的数据类型是由JS引擎根据=右边变量值的数据类型来判断的，运行完毕之后，变量就确定了数据类型。 123// js是动态语言变量的数据类型是可以变化的varx=10;//x是数字型x=&#x27;pink&#x27;;// x字符串型 2.3.1 数据类型分类 JS把数据类型分为两类: 简单数据类型( Number , String , Boolean, Undefined, Null ) 复杂数据类型( object) 简单数据类型： 数字型（Number）： 12345678910111213var num=10;//num为数字型var num=10.0//num数字型//数字型最大值var num=Number.MAX_VALUE//数字型最小值var num=Number.MIN_VALUE//数字型三个特殊值var num=Number.MAX_VALUE*2//结果为Infinityvar num=Number.MIN_VALUE*2//结果为-Infinityvar num=‘丁志君’-12//结果为NaNalert (Infinity) ;//Infinity ,代表无穷大,大于任何数值alert(-Infinity) ; //-Infinity ,代表无穷小,小于任何数值alert (NaN) ;//Not a number ,代表一个非数值 字符串型（String）： 字符串型可以是引号中的任意文本,其语法为双引号””和单引号”，因为HTML标签里面的属性使用的是双引号，JS这里我们更推荐使用单引号。 123456var strMsg = &quot;我爱北京天安门~&quot;; // 使用双引号表示字符串var strMsg2 = &#x27;我爱吃猪蹄~&#x27;; // 使用单引号表示字符串var strMsg3 = &#x27;我爱吃&quot;猪蹄&quot;~&#x27;; //‘ ’里面套“ ”var strMsg4 = &quot;我爱吃&#x27;猪蹄&#x27;~&quot;; //&quot; &quot;里面套 &#x27; &#x27;//常见错误var strMsg3 =我爱大肘子;//报错，没使用引号,会被认为是js代码,但j s没有这些语法 布尔类型（boolean）： 布尔类型有两个值: true和false ，其中true表示真(对) ，而false表示假(错)。 123456//布尔型var flag = true;var flag1 = false;//进行数学运算时，true代表的是1，false代表的是0console.log(true + 1);//2console.log(false + 1);//1 未定义类型(Undefined): 如果一个变量声明时未被赋值，则输出结果就是Undefined 1234var age;console.log(age);//Undefinedconsole.log(age+&#x27;pink&#x27;);//Undefinedpinkconsole.log(age + 1); // NaN(非数字) undefined 和数字相加最后的结果是NaN 空值类型(null): 123var age = null;console.log(age + &#x27;pink&#x27;);//nullpinkconsole.log(age + 1);//1 转义字符： 123//字符串转义字符都是用 \\ 开头但是这些转义字符写道引号里面varstr1=“我是个&#x27;高富帅&#x27;的\\n程序员&quot;;alert(&#x27;大大大大大大大大大\\n小小小小小小小小小\\n&quot;收破烂啦~&quot;&#x27;) 2.3.2 字符串length属性及拼接 字符串长度属性：length 1234var len = &quot;丁志君&quot;.length;alert(len);var str = &quot;石雨&quot;;alert(str.length); 字符串拼接： 多个字符串之间可以使用+进行拼接,其拼接方式为字符串+任何类型=拼接之后的新字符串 12345var len = &quot;丁志君&quot;;var str = &quot;石雨&quot;;console.log(len + &quot;喜欢&quot; + str + 2021);//丁志君喜欢石雨2021console.log(12+12)//24console.log(&quot;12&quot;+12)//1212 2.3.3 获取变量数据类型 **typeof:**typeof可用来获取检测变量的数据类型 12345678910111213var num = 10;console.log(typeof num);//numbervar str = &quot;pink&quot;;console.log(typeof str);//stringvar flag = true;console.log(typeof flag);//booleanvar variable = undefined;console.log(typeof variable);//undefinedvar times = null;console.log(typeof times);//object//prompt获取到的值是字符串型的var age=prompt(&quot;请输入年龄：&quot;);console.log(typeof age);//string 2.3.4 数据类型的转换 使用表单、prompt获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量 的数据类型。通俗来说，就是把一种数据类型的变量转换成另外一种数据类型。 编程中通常有三种形式的转换：转换为字符串类型、转换为数字型、转换为布尔型 2.3.4.1 其他类型转换为字符串类型： 123456var str = 10;console.log(typeof str);//numberconsole.log(str.toString());//10console.log(typeof str.toString());//stringconsole.log(String(str));//10console.log(typeof String(str));//string 2.3.4.2 其他类型转换为数字类型： 12345678910111213141516var str = &quot;10.0&quot;;var str1 = &quot;120px&quot;;var str2 = &quot;rem120px&quot;;console.log(typeof str);//stringconsole.log(parseInt(str));//10console.log(parseInt(str1));//120console.log(parseInt(str2));//NaNconsole.log(typeof parseInt(str));//Numberconsole.log(parseFloat(str));//10.0console.log(typeof parseFloat(str));//Numberconsole.log(typeof Number(str));//Number//隐式转换console.log(str - 0);//10console.log(typeof (str - 0));//Numberconsole.log(&quot;120&quot; - &quot;110&quot;);//10console.log(&quot;120&quot; * 1);//120 2.3.4.3 其他类型转换为布尔类型： 代表空、否定的值会被转换为false，如”、 0、NaN、 null undefined其余值都会被转换为true 1234567console.log(Boolean(&#x27;&#x27;));//falseconsole.log(Boolean(0));//falseconsole.log(Boolean(&quot;12&quot;));//trueconsole.log(Boolean(undefined));//falseconsole.log(Boolean(null));//falseconsole.log(Boolean(NaN));//falseconsole.log(Boolean(12));//true 2.4 扩展内容 编译语言与解释语言的区别： 计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能 执行程序。程序语言翻译成机器语言的工具，被称为翻译器。 翻译器翻译的方式有两种: 一个是编译，另外一个是解释。两种方式之间的区别在于翻译的时间点不同 编译器是在代码执行之前进行编译，生成中间代码文件（比如Java语言，执行代码时会用编译器编译成javac.class临时文件，当代码全部编译成javac.class文件后，再用解释器进行解释） 解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候,也称之为解释器)（比如JS语言，JS每读取一行代码，就直接被解释器解释） 类似于请客吃饭: 编译语言:首先把所有菜做好，才能上桌吃饭 解释语言:好比吃火锅，边吃边涮，同时进行 2.5 运算符 运算符( operator )也被称为操作符，用于实现赋值、比较和执行算数运算等功能的符号。 JS中常用运算符：算数运算符、递增和递减运算符、比较运算符、逻辑运算符、赋值运算符 2.5.1 算数运算符概念:算术运算使用的符号，于执行两个变量或值的算术运算。 1234567console.log(1 + 1);//2console.log(1 - 1);//0console.log(1 / 1);//1console.log(1 * 2);//2console.log(4 % 2);//0console.log(5 % 3);//2console.log(3% 5;//3 浮点数计算时有精度问题： 浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。不能直接用浮点数来判断是否相等 12console.log(0.1 + 0.2);//0.30000000000000004console.log(0.07 * 100);//7.000000000000001 2.5.2 自增与自减 如果需要反复给数字变量添加或减去1 ,可以使用递增( ++ )和递减( – )运算符来完成。 在JavaScript中，递增( ++ )和递减( – )既可以放在变量前面，也可以放在变量后面。放在变量前面时，我们可以称为前置递增(递减)运算符，放在变量后面时，我们可以称为后置递增(递减)运算符。 注意：递增和递减运算符必须和变量配合使用。 递增： 前置递增与后置递增单独使用时没有任何区别，但当他们用于其他情况时产生的结果就不一样了 前置递增： 先加1，后返回值。 1234var age=10;++age;//类似于age=age+1console.log(age);//11console.log(++age +10)//21 后置递增： 先后返回原值，后加1。 1234var age&#x3D;10;age++;&#x2F;&#x2F;类似于age&#x3D;age+1console.log(age);&#x2F;&#x2F;11console.log(age++ +10)&#x2F;&#x2F;20 2.5.3 比较运算符概念：比较运算符(关系运算符)是两个数据进行比较时所使用的运算符，比较运算后会返回一个布尔值( true / false )作为比较运算的结果。 1234console.log(18 == &#x27;18&#x27;);console.log(15 &gt;= 18);// 左右的18数据类型不同console.log(18 === &#x27;18&#x27;); 2.5.4 逻辑运算符概念：逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断。 逻辑中断（短路与）： 逻辑与短路运算：如果表达式1结果为真，则返回表达式2，如果表达式1为假，那么返回表达式1。 12345console.log(123&amp;&amp;456);//456console.log(0&amp;&amp;456);//0console.log(0&amp;&amp;1+23&amp;&amp;4*56);//0console.log(null&amp;&amp;1+23&amp;&amp;4*56);//nullconsole.log(&#x27;&#x27;&amp;&amp;1+23&amp;&amp;4*56);//&#x27;&#x27; 逻辑中断（短路或）： 逻辑或短路运算：如果表达式1结果为真，则返回的是表达式1，如果表达式1结果为假，则返回表达式2 1234console.log(123||456);&#x2F;&#x2F;123console.log(0||456);&#x2F;&#x2F;456console.log(0||4*56);&#x2F;&#x2F;4*56console.log(null||4*56);&#x2F;&#x2F;4*56 2.3.5 赋值运算符 2.6 流程控制 在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能。 简单理解:流程控制就是来控制我们的代码按照什么结构顺序来执行 流程控制主要有三种结构，分别是顺序结构、分支结构和循环结构， 这三种结构代表三种代码执行的顺序。 顺序流程控制：顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行。 分支流程控制：由上到下执行代码的过程中，根据不同的条件,执行不同的路径代码(执行代码多选-的过程) ，从而得到不同的结果 12345678910111213141516171819if(条件表达式)&#123;//条件成立时执行的代码语句&#125;else if(条件表达式)&#123; //条件成立时的语句&#125;else&#123; //条件不成立时的表达式&#125;2.执行思路如果if里面的条件表达式结果为真true，则执行大括号里面的执行语句。如果if条件表达式结果为假，则不执行大括号里面的语句，则执行if语句后面的代码。//if语句if(2&gt;1)&#123; console.log(&#x27;你好&#x27;); &#125;//if else语句if(2&gt;1)&#123; console.log(&#x27;你好&#x27;); &#125;else&#123; console.log(&#x27;你不好&#x27;); &#125; 三元表达式：条件表达式？表达式1 ：表达式2 如果条件表达式结果为真，则返回表达式1的值，如果条件表达式结果为假，则返回表达式2的值 12var num&#x3D;10;num&gt;5 ? &#39;是的&#39;:&#39;不是的&#39;; 分支流程控制语句： switch语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的特定值的选项 时，就可以使用switch。 1234567891011121314151617181920//语法结构,break不可省略switch(表达式)&#123;case value1: break;case value2:break;default;&#125;//实例，break不可省略,case值与switch值必须全等（即类型与数值都相等）var num=2;switch(num)&#123; case 1; console.log(&#x27;这是1&#x27;); break; case 2; console,log(&#x27;这是2&#x27;); break; default; console.log(&#x27;啥也不是&#x27;); &#125; 2.7 循环控制 三种主要循环：for循环、while循环、do while循环 在程序中，一组被重复执行的语句被称之 为循环体，能否继续重复执行，取决于循环的终止条件。由循环体 及循环的终止条件组成的语句，被称之为循环语句 2.7.1 for循环12345678910111213141516//语法结构for(初始化变量;条件表达式;循环表达式)&#123;//循环语句&#125;//实例for(var i=0;i&lt;10;i++)&#123; console.log(&#x27;你好！&#x27;);&#125;//求班级学生平均成绩案例var num = prompt(&#x27;请输入班级人数：&#x27;) - 0;var sum = 0;for (var i = 1; i &lt;= num; i++) &#123; sum = sum + (prompt(&#x27;请输入第&#x27; + i + &#x27;个同学的成绩&#x27;) - 0);&#125;var average = sum / num;console.log(average); 双重for循环 很多情况下，单层for循环并不能满足我们的需求，比如我们要打印一个5行5列的图形、打印一个倒直角三角形 等，此时就可以通过循环嵌套来实现。**循环嵌套**是指在一个循环语句中再定义一个循环语句的语法结构，例如在 for循环语句中，可以再嵌套一个for循环，这样的for循环语句我们称之为双重for循环。 12345678910111213141516171819202122232425262728293031//双重for循环语法结构//外循环一次，里循环执行全部for(外层初始化变量;外层条件表达式;外层的操作表达式)&#123;for(里层初始化变量;里层条件表达式;里层的操作表达式)&#123;//循环语句&#125;&#125;for(var i=0;i&lt;3;i++)&#123; console.log(&#x27;外循环执行&#x27;+i+&#x27;次&#x27;); for(var j=0;j&lt;3;j++)&#123; console.log(&#x27;内循环执行&#x27;+j+&#x27;次&#x27;); &#125; &#125;//打印五行五列 var str = &#x27;&#x27;; for (var i = 0; i &lt; 5; i++) &#123; for (var j = 0; j &lt; 5; j++) &#123; str = str + &#x27;*&#x27;; &#125; str = str + &#x27;\\n&#x27; &#125; console.log(str);//打印九九乘法表var str = &#x27;&#x27;;for (var i = 1; i &lt;= 9; i++) &#123;for (var j = 1; j &lt;= i; j++) &#123; str = str + i + &#x27;x&#x27; + j + &#x27;=&#x27; + i * j + &#x27; &#x27;;&#125; str = str + &#x27;\\n&#x27;;&#125;console.log(str); 2.7.2 while循环12345678910//语法结构 当 成立的是时候，执行循环语句while(条件表达式)&#123; 循环体 &#125;//当表达式结果为true时，执行循环体，否则则退出var age = prompt(&#x27;请输入年龄&#x27;) - 0; while (age &lt; 18) &#123; console.log(&#x27;未成年人禁止入内！&#x27;) age++;//防止死循环&#125; 2.7.3 do while循环do… while语句其实是while语句的一一个变体。该循环会先执行次代码块 ，然后对条件表达式进行判断，如果条件 为真，就会重复执行循环体，否则退出循环。 12345678910//do while循环语法结构do&#123;//循环体&#125;while(条件表达式) //与while循环的不同之处在于它会先执行一遍循环体再执行条件表达式，如果条件为真，则继续执行，如果条件为假，则退出循环var age = prompt(&#x27;请输入年龄&#x27;) - 0;do &#123; alert(&#x27;禁止&#x27;); age++;&#125; while (age &lt; 18) 2.7.4 continue关键字continue关键宇用于立即跳出本次循环，继续下一次循环(本次循环体中continue之后的代码就会少执行一次)。例 如，吃5个包子，第3个有子，就扔掉第3个，继续吃第4个第5个包子，其代码实现如下: 123456for (var i = 0; i &lt; 3; i++) &#123; if (i == 1) &#123; continue;&#125; console.log(&#x27;正在吃第&#x27; + i + &#x27;个包子&#x27;);&#125; 2.7.5 break关键字break关键字用于立即跳出整个循环(循环结束)。例如,吃5个包子，吃到第3个发现里面有半个虫子，其余的不吃了，其代码实现如下: 123456for (var i = 0; i &lt; 5; i++) &#123; if (i == 3) &#123; break;&#125; console.log(&#x27;正在吃第&#x27; + i + &#x27;个包子&#x27;);&#125; 2.8 数组 数组是指一组数据的集合 ，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一种将一组 数据存储在单个变量名 下的优雅方式。 数组可以把一组相关的数据一 起存放，并提供方便的访问(获取)方式。 123456//数组：即一组数据的集合，储存在单个变量下的优雅方式//利用new创建数组var arr=new Arrary();//空数组//使用数组字面量来创建数组var arr2=[];//空数组var arr1=[1,2,3,4,5,&#x27;hahaha&#x27;,true] 数组的字面量是方括号[ ]，声明数组并赋值称为数组的初始化。 2.8.1数组的访问123456789var arr = new Array();//创建了一个空数组arr = [1, 2, 5, &#x27;钉钉&#x27;];console.log(arr);//[1, 2, 5, &quot;钉钉&quot;]0: 1/*1: 22: 53: &quot;钉钉&quot;length: 4__proto__: Array(0)*/ 数组的索引： 123var arr = new Array();//创建了一个空数组arr = [1, 2, 5, &#x27;钉钉&#x27;];console.log(arr[0]);//1 2.8.2数组的遍历1234567891011121314151617181920212223var arr = [&#x27;迪丽热巴&#x27;, &#x27;鹿晗&#x27;, 1, 2]for (var i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]);//&#x27;迪丽热巴&#x27;, &#x27;鹿晗&#x27;, 1, 2&#125;//案例，求数组和及平均数var arr = [1, 1, 2, 3, 4, 7, 8, 6]var sum = 0;for (var i = 0; i &lt; arr.length; i++) &#123; sum += arr[i];&#125; var average = sum / arr.length; console.log(sum, average);//多结果输出//求数组中最大值var arr = [2, 4, 3, 6, 8, 1, 12];var max = arr[0];for (var i = 1; i &lt; arr.length; i++) &#123; if (max &lt;= arr[i]) &#123; max = arr[i]&#125;&#125;console.log(max); 2.8.3 spilt的使用方法12345var str = &#x27;nihao nihaoma 1&#x27;;var arr = str.split(&#x27; &#x27;);//通过&#x27; &#x27;将字符串切割为数组for (var i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]); &#125; 2.8.4 数组属性的修改12345678910111213//修改数组长度（扩容数组）var arr=[1,2,3];console.log(arr.length);//3arr.length=5;//扩容数组//修改数组索引arr[3]=4;//新增元素arr[4]=5;//新增元素arr[1]=6;//修改索引为1的元素//修改数组的数据类型arr=&#x27;优点意思&#x27;//不能直接给数名复制，否则会替换掉之前数组中的内容。console.log(arr);//有点意思 2.8.5 数组实操 筛选出大于10 的数组元素 1234567891011var arr = [1, 2, 3, 6, 8, 4, 23, 56, 6, 34, 76]; var newarr = new Array(); for (var i = 0, j = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt; 10) &#123; newarr[j] = arr[i]; j++; &#125; &#125; for (var k = 0; k &lt; newarr.length; k++) &#123; console.log(newarr[k]); &#125; 删除指定数组元素 1234567891011var arr = [0, 56, 3, 3, 78, 0, 67, 0, 0, 67, 34];var newarr = new Array();for (var j = 0, i = 0; i &lt; arr.length; i++) &#123;if (arr[i] != 0) &#123; newarr[j] = arr[i]; j++; &#125; &#125;for (var k = 0; k &lt; newarr.length; k++) &#123;console.log(newarr[k]); &#125; 翻转数组 123456var arr = [1, 2, 3, 4, 5, 6];var newarr = [];for (var i = arr.length - 1; i &gt;= 0; i--) &#123; newarr[newarr.length] = arr[i];&#125; console.log(newarr); 冒泡排序 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就 把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算 法的名字由来是因为越小的元素会经由交换慢慢浮“到数列的顶端。 1234567891011var arr = [3, 5, 7, 9, 0, 1, 4];for (var i = 0; i &lt;= arr.length - 1; i++) &#123;//外层循环管趟数for (var j = 0; j &lt;= arr.length - i - 1; j++) &#123;//内层循环管交换次数if (arr[j] &gt; arr[j + 1]) &#123; var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; console.log(arr); 2.9 函数 在JS里面,可能会定义非常多的相同代码或者功能相似的代码,这些代码可能需要大量重复使用。虽然for循环语句也 能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用JS中的函数。 函数:就是封装了一段可被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用。 2.9.1 函数的使用 函数的使用分为两部分：声明函数和调用函数 函数的使用： 12345678910111213141516//声明函数方法一function 函数名()&#123;//函数体（代码块）&#125;//实例function sayHi()&#123;consolge.log(&#x27;Hi&#x27;);&#125;//声明函数方法二var 变量名=function()&#123;&#125;//实例var fun=function(num)&#123; console.log(&#x27;我是函数表达式&#x27;);&#125; 注意： function为声明函数的关键字，全部为小写 函数是做某件事情，函数名一般为动词 函数如果不被调用，自己是无法执行的 函数的调用： 1234567891011121314//函数名（）sayHi();//实例//声明函数function getSum() &#123;var sum = 0;for (var i = 1; i &lt;= 100; i++) &#123; sum += i;&#125; console.log(sum);&#125;//调用函数 getSum(); 注意： 调用函数时一定要加(); 2.9.2 函数的封装函数的封装是把一个或者多 个功能通过函数的方式封装起来，对外只提供一个简单的函数接口 2.9.3 函数的参数形参与实参： 123456789//函数声明时，（）里是形参function getSum(形参1,形参2,形参3)&#123;//代码块&#125;//调用时，传递的为实参function cook(food)&#123;//food为形参 &#125;food(&#x27;西红柿炒鸡蛋&#x27;);//西红柿炒鸡蛋为实参 2.9.4 函数形参与实参不匹配问题在JS中，形参的默认值为undefinded。 1234567function getSum(num1,num2,num3)&#123;console.log(num1+num2);&#125;getSum(1,2,3)//3getSum(1,2)//3getSum(1)//NaNgetSum(1, 2, 3, 4);//3 2.9.5 函数的返回值return1234567891011121314//函数的返回值格式//function 函数名()&#123;return 需要返回的值&#125;//函数知只是实现某种功能，最终的结果需要返回给函数的调用者function getResult(num)&#123; return num;&#125;console,log(getResult(666));function getSum(num1,num2)&#123; return num1+num2;&#125;console.log(getSum(1,4)); 2.9.6 return使用时的注意事项12345678910111213141516171819//1.return为终止位置，return之后的代码不会被执行function getSum(num1,num2)&#123;return num1+num2;alert(&#x27;111&#x27;);//不会被执行，return之后的代码不会被执行&#125;//2.return只能返回一个值function getSum(num1,num2)&#123; return num1,num1+num2;//只返回num1+num2的结果&#125;//3.如果函数中有return，则返回return后的值，如果没有则返回undefinedfunction fun1()&#123; return 666;&#125;fun1();//返回666function fun2()&#123; &#125;fun2();//返回值为undefined 2.9.7 argument的使用 当我们不确定有多少个参数传递的时候，可以用arguments来获取。在JavaScript中， arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个arguments对象， arguments对象中存储了传递的所有实参。 argument的使用： 123456789101112function fun()&#123;console.log(arguments)//里面存储了所有传递过来的实参&#125;fun(1,2,3,4)//返回[1,2,3,4]伪数组function fun1()&#123; for(var i=0;i&lt;arguments.length;i++)&#123; console.log(arguments[i]); &#125;&#125;fun1(1,2,3,4,5,6) 伪数组： 具有数组的length属性 按照数组的索引进行存储 没有真正数组的一些方法，比如pop()、push() 2.9.8 函数封装冒泡排序1234567891011121314function sort(arr) &#123;for (var i = 0; i &lt; arr.length - 1; i++) &#123;for (var j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp;&#125;&#125;&#125; return arr;&#125;var arr1 = sort([1, 4, 3, 8, 5]);console.log(arr1); 3.0 作用域 通常来说,，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个 名字的作用域。作用域的使用提高了程序逻辑的局部性,增强了程序的可靠性,减少了名字冲突。 2.0.1 全局变量与局部变量JS的作用域：全局作用域、局部作用域 123456//全局作用域（在整个代码中都会起作用）var num=10;//在函数内部就是局部作用域，只在函数内部起作用function fun()&#123;var num1=10;&#125; 从执行效率来看全局变量和局部变量 全局变量只有浏览器关闭的时候才会销毁，比较占内存资源 局部变量当我们程序执行完毕就会销毁， 比较节约内存资源 3.0.1 块级作用域1234if(i&lt;10)&#123;var num=10;&#125;console.log(num);//10 3.1 预解析 JS引擎运行JS代码时分为：预**解析、代码执行** 预解析JS引擎会把JS里面所有的var还有function，提升到当前作用域的最前面。 预解析分为：变量预解析(变量提升 )和函数预解析( 函数提升) 变量提升：就是把所有的变量声明提升到当前的作用域最前面不提升赋值操作 函数提升：就是把所有的函数声明提升到当前作用域的最前面但不调用函数 须注意点： 123456789101112131415//情形一console.log(num);//结果报错//情形二 变量提升var num提升到最前边，但不提升赋值console.log(num);//结果为undefinedvar num=10;//情形三 函数提升fun();//结果为10function fun()&#123;console.log(10);&#125;//情形四 变量提升，提升var fun,但不提升后边的function（）fun();//结果报错var fun=function()&#123;console.log(10);&#125; 3.2 JS对象（Object） 什么是对象？ 现实生活中：万物皆对象，对象是一个具体的事物 ，看得见摸得着的实物。例如，一本书、一辆汽车、 一个人 可以是”对象”，一个数据库、一张网页、 一个与远程服务器的连接也可以是“对象”。 在JavaScript中，对象是一组无序的相关属性和方法的集合 ，所有的事物都是对象，例如字符串、 数值、数 组、函数等。对象是由属性和方法组成的。 属性:事物的特征，在对象中用属性来表示(常用名词) 方法:事物的行为，在对象中用方法来表示(常用动词) 为什么需要对象？ 保存一个值时，可以使用变量，保存多个值( 一组值)时，可以使用数组。如果要保存一个人的完整信息（身高、体重和、年龄等属性）呢? 例如： 用数组储存丁志君的各种属性 var person=[‘丁志君’,’’男,21,175,147];//不合适，表述不清楚 用对象储存丁志君的属性 dingzhijun.名字= ‘丁志君’； person.name=’丁志君’； dingzhijun.性别=’男’； person.sex=’男’； dingzhijun.年龄=21 ; person.age=21 ; dingzhijun.身高=175; person.height=175; 3.1.1 创建对象的三种方式 利用字面量创建对象 **对象字面量：**即花括号{}里面包含了表达这个具体事物（对象 ）的属性和方法 123456789101112131415161718//创建对象var obj = &#123; //键值对的形式，多个属性之后用 ， 隔开 uname: &#x27;丁志君&#x27;, age: 21, uheight: 175, uweight: 147, //方法冒号后面跟匿名函数 sayHi: function () &#123; console.log(&#x27;这是&#x27; + num + &#x27;呀！&#x27;);&#125; &#125;//调用对象中的方法obj.sayHi(2);//调用对象中的属性console.log(obj.age);//第二种调用方式console.log(obj[&#x27;age&#x27;]); 利用new object创建对象 **new object创建对象：**与创建数组 new Arrary（）原理类似 123456789101112//创建对象var obj = new Object();//添加属性obj.uname = &#x27;丁志君&#x27;;obj.age = 21;obj.uheight = 175;obj.sayHi = function (num) &#123; console.log(&#x27;这是&#x27; + num + &#x27;呀！&#x27;);&#125;//调用对象console.log(obj.age);obj.sayHi(2); 利用构造函数来创造对象 使用上述两种方法一次只能创建一个对象，具有一定的局限性，因此可以利用函数的方法将属性封装如函数中，即为构造函数。 构造函数：将对象里面相同的属性和方法抽象出来封装到函数里 1234567891011121314151617181920//使用方法function start(属性1,属性2)&#123;this.属性1=属性1;this.属性2=属性2;&#125;//调用new start(实参1,实参2)function(uname,age,sex)&#123;this.name=&#x27;刘德华this.sex=&#x27;男&#x27;this.age=18 this.sang=function(sang)&#123; console.log(sang) &#125;&#125;var ldh=new start(&#x27;刘德华&#x27;,18,&#x27;男&#x27;,&#x27;冰雨&#x27;)console.log(typeof ldh)//objectconsole.log(ldh.age)//18ldh.sang(&#x27;冰雨&#x27;) 3.1.2 遍历对象for - in 遍历对象 12345678910111213for(变量in对象)&#123;&#125;//实例var obj=&#123;name:&#x27;丁志君&#x27;;age:18sex:&#x27;男&#x27;;&#125;for(var k in obj)&#123;console.log(k);//结果为属性名console.log(obj[k]);//结果为属性值&#125; 3.3 JS内置对象 JS中的对象分为:内置对象 、自定义对象、浏览器对象 内置对象：指JS语言自带的对象，这些对象供开发者使用，并提供了一些常用的或是最基本必要的功能 3.3.1 查阅文档MDN：https://developer.mozilla.org/zh-CN/ 3.3.2 内置对象Math123456789//内置对象Math的几种方法Math.PI //圆周率Math.floor();//向下取整Math.ceil();//向上取整Math.round();//四舍五入取整Math.abs();//绝对值Math.max();//最大值Math.min();//最小值Math.random();//返回一个[0,1)之间的随机数 3.3.3 内置对象Date日期对象必须通过构造函数来创建（即通过new关键字来创建） 123456789//构造日期对象函数//若Date（）里无参数，则返回系统的当前时间var date = new Date();console.log(date);//若有参数，在参数写法如下var date1=new Date(2021,2,22);//数字型console.log(date);//返回的是3月，不是2月var date1=new Date(&#x27;2020-2-22 8:8:8&#x27;);//字符串型console.log(date);//返回的是2月 格式化日期格式 1234var date = new Date();console.log(date.getFullYear());//返回当前日期的年var date1 = new Date();console.log(date1.getMonth()+1);//返回当前月份，不过返回的月份比当前的月份小一个月（国外原因），因此需要加1 获得时间戳 1234var date=new Date();console.log(valueOf());//获得现在到1970年的毫秒数console.log(getTime());//获得现在到1970年的毫秒数console.log(Date.now());//获得现在到1970年的毫秒数 时间戳转换为时分秒格式 123456var nowTime= +new Date();//获取当前的毫秒数（时间戳）var times=nowTime/1000//获取总的秒数var day=parsentInt(times/60/60/24);//获取天数（整数）var hours=parsentInt(times/60/60%24);//获取小时数（整数）var mintues=parsentInt(times/60%60);//获取分钟数（整数）var seconds=parsentInt(times%60);//获取当前秒数（整数） 3.3.4 内置对象Array检测是否为数组 123456var arr=[];//数组var obj=&#123;&#125;;//对象cosole.log(arr instanceof Array);//true 为数组cosole.log(obj instanceof Array);//false 不为数组Array.isArray(arr);//ture 为数组Array.isArray(obj);//false 不为数组 在数组末尾添加数组元素 12var arr=[1,2,3];//数组arr.push(1,&#x27;丁&#x27;)//在数组末尾新增两个数组元素，返回数组的长度 在数组开头添加数组元素 12var arr=[1,2,3];//数组arr.unshift(1,&#x27;丁&#x27;)//在数组开头新增两个数组元素，返回数组的长度 删除数组的最后一个元素 12var arr=[1,2,3];//数组arr.pop()//删除数组最后一个元素，一次只能删除一个，返回的结果为被删除的元素 删除数组的第一个元素 12var arr=[1,2,3];//数组arr.shift()//删除数组第一个元素，一次只能删除一个，返回的结果为被删除的元素 数组排序 1234var arr=[1,2,3];//数组Array.reverse();//数组翻转3,2,1var arr=[4,2,3];//数组arr.sort();//数组排序2,3,4 数组索引 1234var arr=[1,2,3];//数组console.log(arr.indexOf(1));//返回结果为0console.log(arr.indexOf(5));//找不到元素，返回结果为-1console.log(arr.latindexOf(1));//从后面开始查找，但结果不变，返回结果为0（与indexOf（）效果一样） 数组转换为字符串 1234var arr=[1,2,3];//数组console.log(arr.toString());//1,2,3 使用toString（）转化console.log(arr.join());//1,2,3 使用join（）转化console.log(arr.join(&#x27;-&#x27;));//1-2-3 使用join（）转化，可自定义分隔符 其他方法 3.3.5 内置对象字符串基本包装数据类型 1234567var str=&#x27;ding&#x27;;//把简单数据类型包装成为复杂数据类型var temp=new String(&#x27;ding&#x27;);//把临时变量赋值给strstr=temp;//销毁临时变量temp=null; 字符串不可变性 123var str=&#x27;ding&#x27;;str=&#x27;shiyu&#x27;;console.log(str);//shiyu 字符串的不可变指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，每次对字符串的操作完成都会返回一个新的字符串（开辟了一个新的地址）。 12345var str&#x3D;&#39;&#39;;for(var i&#x3D;0;i&lt;10000000;i++)&#123;str+&#x3D;i&#125;console.log(str);&#x2F;&#x2F;这个结果需要计算很久，非常消耗电脑内存 根据字符返回字符的位置 字符串操作方法 3.4 简单数据类型与复杂数据类型简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。 值类型︰简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型。string , number , boolean , undefined , null。其中简单数据类型null返回的是一个空的对象object 12var times=null;console.log(typeof times);//object 引用类型∶复杂数据类型，在存储时变量中存储的仅仅是地址(引用)，因此叫做引用数据类型通过new关键字 创建的对象（系统对象、自定义对象），如Object、Array、Date等 3.4.1 堆和栈堆空间和栈空间分配区别 1、栈(操作系统）︰由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。简单数据类型存放到栈里面 2、堆（操作系统）∶存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型存放到堆里面 3.4.2 简单数据类型内存分配 值类型（简单数据类型) : string , number , boolean , undefined , null 值类型变量的数据直接存放在变量(栈空间)中 简单数据类型直接存放在栈中，存放的是值。如下图中的age就是简单数据类型 引用类型(复杂数据类型)∶通过new关键字创建的对象（系统对象、自定义对象），如Object、Array、Date等。 引用类型变量（栈空间)里存放的是地址，真正的对象实例存放在堆空间中 复杂数据类型首先在栈中存放地址（十六进制表示），然后这个地址再指向堆中的值。如下图中的数组。 3.4.3 简单数据类型传参 3.4.4 复杂数据类型传参 3.5 WebAPIs3.5.1 Web APIs与JS基础的关联性JS的组成： 在JS基础阶段学习的主要是ECMAScript，而Web APIs阶段主要学习DOM和BOM。 JS的基础阶段： 学习的是ECMAscript标准规定的基本语法 要求掌握Js基础语法 只学习基本语法，做不了常用的网页交互效果 目的是为了Js 后面的课程判基础、做铺垫 Web APIs阶段： web APIs是w3c组织的标准 web APIs 主要学习DOM和BOM web APIs是JS所独有的部分 主要学习页面交互功能 需要使用Js基础的课程内容做基础 JS基础学习ECMAscript基础语法为后面作铺垫，web APIs是JS的应用，大量使用JS基础语法做交互效果 3.5.2 API与Web APIAPI： APl( Application Programming Interface,应用程序编程接口)是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。 简单理解︰**API是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能。** Web API： Web API是浏览器提供的一套操作浏览器功能和页面元素的API( BOM和DOM)。现阶段我们主要针对于浏览器讲 解常用的API，主要针对浏览器做交互效果。 比如我们想要浏览器弹出一个警示框，直接使用alert(‘弹出’) MDN API参考：https://developer.mozilla.org/zh-CN/docs/Web/API 总结： API是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结内部何实现. Web API主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果。 Web API一般都有输入和输出（函数的传参和返回值），Web API很多都是方法（函数），比如alert()方法。 学习Web API可以结合前面学习内置对象方法的思路学习 3.6 DOM什么是DOM： 文档对象模型(Document Object Model，简称DOM)，是W3C组织推荐的处理**可扩展标记语言(**HTML或者XML )的标准编程接口。 W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式。 DOM树： 文档：一个页面就是一个文档，DOM中使用document表示 元素：页面中的所有标签都是元素，DOM中使用element表示 节点︰网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示 3.6.1 获取元素 DOM在我们实际开发中主要用来操作元素。 如何来获取页面中的元素呢? 获取页面中的元素可以使用以下几种方式: 根据ID获取 根据标签名获取 通过HTML5新增的方法获取 特殊元素获取 3.6.1.1 根据ID获取元素1234567891011121314 &lt;body&gt;&lt;div id=&#x27;time&#x27;&gt;钉子君&lt;/div&gt;&lt;!-- 因为HTML文档是从上往下依次读取，因此获取元素时，需要先有标签，才能写script，因此要写到标签下面 --&gt;&lt;script&gt;//get 获得 Elemnet 元素 BYId 通过Id 驼峰命名法//里面的参数是大小写敏感的字符串//返回的元素是一个对象var timer = document.getElementById(&#x27;time&#x27;);console.log(timer); //返回结果 &lt;div id=&#x27;time&#x27;&gt;钉子君&lt;/div&gt;console.log(typeof timer); //object//打印我们返回的元素对象，更好的查看里面的属性和方法console.dir(timer);&lt;/script&gt;&lt;/body&gt; 3.6.1.2 根据标签名获取使用getElementsByTagName()方法可以返回带有指定标签名的对象的集合。 1234567891011121314151617 &lt;ol&gt; &lt;li&gt;作业雨疏风骤，浓睡不消残酒&lt;/li&gt; &lt;li&gt;作业雨疏风骤，浓睡不消残酒&lt;/li&gt; &lt;li&gt;作业雨疏风骤，浓睡不消残酒&lt;/li&gt; &lt;/ol&gt;//返回的是获取过来元素对象的集合以伪数组的形式存储的var result = document.getElementsByTagName(&#x27;li&#x27;);console.log(result);console.log(result[0]);//获取第一个li标签里的内容 console.log(result[0]); //获取第一个li标签里的内容for (var i = 0; i &lt; result.length; i++) &#123; console.log(result[i]);&#125;//如果页面中只有一个li返回的还是伪数组的形式//如果页面中没有这个元素返回的空的伪数组的形式 因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。得到元素对象是动态的 获取某一父元素内指定的子元素 复杂版： 1234567891011121314 &lt;ol&gt; &lt;li&gt;昨夜雨疏风骤&lt;/li&gt; &lt;li&gt;昨夜雨疏风骤&lt;/li&gt; &lt;li&gt;昨夜雨疏风骤&lt;/li&gt; &lt;/ol&gt; &lt;ul&gt; &lt;li&gt;浓睡不消残酒&lt;/li&gt; &lt;li&gt;浓睡不消残酒&lt;/li&gt; &lt;li&gt;浓睡不消残酒&lt;/li&gt; &lt;/ul&gt;//如果想获取的是ol里面的li标签，而不要ul里面的var ol = document.getElementsByTagName(&#x27;ol&#x27;); //先通过ol标签名获取所有ol标签（存入数组中），又因为文档中只有一个ol标签，因此数组中的下标为0返回的是一个数组对象 console.log(ol[0].getElementsByTagName(&#x27;li&#x27;)); //再通过ol[0]获得整个ol标签，最后通过父元素来获得li标签 简单版： 1234567891011121314&lt;ol id=&#x27;ol&#x27;&gt; &lt;li&gt;昨夜雨疏风骤&lt;/li&gt; &lt;li&gt;昨夜雨疏风骤&lt;/li&gt; &lt;li&gt;昨夜雨疏风骤&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt; &lt;li&gt;浓睡不消残酒&lt;/li&gt; &lt;li&gt;浓睡不消残酒&lt;/li&gt; &lt;li&gt;浓睡不消残酒&lt;/li&gt;&lt;/ul&gt; //为父元素加个id，通过id获取父元素对象 var ol=document.getElementsByTagName(&#x27;ol&#x27;); //再通过父元素对象，获得子元素标签 console.log(ol.getElementsByTagName(&#x27;li&#x27;)); 3.6.1.3 H5新增获取元素通过类名获得标签元素 1234567&lt;div class=&quot;box1&quot;&gt;盒子1&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;盒子2&lt;/div&gt;&lt;script&gt;//根据类名获取元素var box = document.getElementsByClassName(&#x27;box1&#x27;);console.log(box);&lt;/script&gt; H5新增方法（query’Selector） 返回指定选择器的第一个元素对象 12345678910 &lt;div class=&quot;box&quot;&gt;盒子1&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;盒子2&lt;/div&gt; &lt;ol id=&#x27;ol&#x27;&gt; &lt;li&gt;昨夜雨疏风骤&lt;/li&gt; &lt;li&gt;昨夜雨疏风骤&lt;/li&gt; &lt;li&gt;昨夜雨疏风骤&lt;/li&gt; &lt;/ol&gt;//H5新增方法querySelector var firstbox = document.querySelector(&#x27;.box&#x27;); //类选择器 var firstol = document.querySelector(&#x27;#ol&#x27;); //id选择器 返回指定选择器的所有对象 12345678910 &lt;div class=&quot;box&quot;&gt;盒子1&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;盒子2&lt;/div&gt; &lt;ol id=&#x27;ol&#x27;&gt; &lt;li&gt;昨夜雨疏风骤&lt;/li&gt; &lt;li&gt;昨夜雨疏风骤&lt;/li&gt; &lt;li&gt;昨夜雨疏风骤&lt;/li&gt; &lt;/ol&gt;//H5新增方法querySelector var firstbox = document.querySelectorAll(&#x27;.box&#x27;); //类选择器 var firstol = document.querySelectorAll(&#x27;#ol&#x27;); //id选择器 3.6.1.3 获取body元素1234&lt;script&gt; var getBody = document.body; console.log(getBody); &lt;/script&gt; 3.6.1.4 获取html元素1234&lt;script&gt; var getHtml = document.documentElement; console.log(getHtml); &lt;/script&gt; 3.6.2 事件基础事件概念：（触发—响应机制） JavaScript使我们有能力创建动态页面，而事件是可以被JavaScript侦测到的行为。 网页中的每个元素都可以产生某些可以触发JavaScript的事件，例如，我们可以在用户点击某按钮时产生一个事件，然后去执行某些操作。 事件有三部分组成（事件三要素）：事件源、事件类型、事件处理程序 事件源：事件被触发的对象 事件类型：如何触发？什么事件？比如鼠标点击（onclick）还是鼠标经过，还是键盘按下 事件处理程序：通过一个函数赋值的方式完成 比如点击一个按钮，弹出对话框 1234567&#x2F;&#x2F;事件源 var btn &#x3D; document.getElementById(&#39;btn&#39;); btn.onclick事件类型（点击） btn.onclick &#x3D; function() &#123; &#x2F;&#x2F;事件处理程序 弹出对话框 alert(&#39;石雨&#39;); &#125; 3.6.2.1 执行事件的步骤 获取事件源 注册事件（绑定事件） 添加事件处理程序（采取函数赋值的形式） 123456789&lt;div&gt;123&lt;/div&gt;//获取事件源var div=document.querySelector(&#x27;div&#x27;);//注册事件（绑定事件）div.onclick//添加事件处理程序（采取函数赋值的形式）div.onclick= function()&#123;alert(&#x27;我被选中了&#x27;);&#125; 常见鼠标事件 3.6.3 操作元素JavaScript的DOM操作可以改变网页内容、结构和样式，我们可以利用DOM操作元素来改变元素里面的内容、属性等。注意以下都是属性 3.6.3.1 改变元素内容从起始位置到终止位置的内容,但它去除 html标签，同时空格和换行也会去掉 1element.innerText 起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行``` 1element.innerHTML element.innerText 123456789101112131415&lt;body&gt; &lt;button id=&#x27;btn&#x27;&gt;显示当前系统时间&lt;/button&gt; &lt;div&gt;当前时间&lt;/div&gt; &lt;script&gt; //需求 当点击按钮，div里面的时间会发生变化 //获取元素（事件源） var btn = document.querySelector(&#x27;button&#x27;); var div = document.querySelector(&#x27;div&#x27;); //注册事件 btn.onclick = function() &#123; var timer = new Date(); div.innerText = timer; &#125; &lt;/script&gt;&lt;/body&gt; 元素可以不添加事件(只要刷新页面就会执行) 123//不用注册事件var p = document.querySelector(&quot;.p1&quot;);p.innerText = getDate(); element.innerHTML与element.innerText的区别 element.innerHTML不识别Html标签，非标准 innerHTML可以识别引号里面的HTML标签 123&lt;div id=&#x27;test&#x27;&gt;测试&lt;/div&gt;var test = document.querySelector(&#x27;#test&#x27;);test.innerHTML = &#x27;&lt;strong&gt;今天是：&lt;/Strong&gt;2021年&#x27;; element.innerText识别Html标签，W3S标准 innerText不可以识别引号里面的HTML标签 123&lt;div id=&#x27;test&#x27;&gt;测试&lt;/div&gt;var test = document.querySelector(&#x27;#test&#x27;);test.innerTests = &#x27;&lt;strong&gt;今天是：&lt;/Strong&gt;2021年&#x27;; 这两个属性是可读取的 可以获取元素里面的内容 123456789101112&lt;p&gt;我是用来测试的&lt;span&gt;我也是&lt;/span&gt; &lt;/p&gt; &lt;script&gt; var p = document.querySelector(&#x27;p&#x27;); console.log(p.innerText);//innerText会去除空格和标签 我是用来测试的 我也是 console.log(p.innerHTML);//会空格和标签/**我是用来测试的 &lt;span&gt;我也是&lt;/span&gt;**/ &lt;/script&gt; 3.6.3.2 常用元素的属性操作案例一：通过点击不同的图片，会展示出不同的图片。 12345678910111213141516&lt;button class=&quot;ding&quot;&gt;丁志君&lt;/button&gt; &lt;button class=&quot;yu&quot;&gt;石雨&lt;/button&gt; &lt;img src=&quot;image/test.jpg&quot; alt=&quot;首页图片&quot;&gt; &lt;script&gt; var ding = document.querySelector(&#x27;.ding&#x27;); var yu = document.querySelector(&#x27;.yu&#x27;); var img = document.querySelector(&#x27;img&#x27;); ding.onclick = function() &#123; img.src = &#x27;image/ding.jpg&#x27;;//修改图片链接属性 img.alt = &#x27;这是丁志君&#x27;; &#125; yu.onclick = function() &#123; img.src = &#x27;image/yu.png&#x27;;//修改图片链接属性 img.alt = &#x27;这是我老婆&#x27;; &#125; &lt;/script&gt; 案例二：根据不同的时间显示不同的图片，不同的问候语 12345678910111213141516171819202122232425 &lt;img src=&quot;image/test.jpg&quot; class=&quot;image&quot; alt=&quot;首页图片&quot; title=&quot;首页图片&quot;&gt;&lt;script&gt;//获取图片元素var img = document.querySelector(&#x27;img&#x27;);//获取时间对象var nowTime = new Date();//获取时间格式function getHour() &#123; var nowhour = nowTime.getHours(); return nowhour;&#125;// console.log(getHour());if (getHour() &lt; 7) &#123; alert(&#x27;现在是凌晨&#x27; + getHour() + &#x27;点,还不睡？等着猝死呢！&#x27;);&#125; else if (7 &lt;= getHour() &amp;&amp; getHour() &lt; 10) &#123; alert(&#x27;记得吃早饭哦！&#x27;)&#125; else if (10 &lt;= getHour() &amp;&amp; getHour() &lt; 14) &#123; alert(&#x27;吃午饭了吗！亲&#x27;) img.src = &#x27;image/zhongwu.jpg&#x27;&#125; else if (18 &lt;= getHour() &amp;&amp; getHour() &lt; 20) &#123; alert(&#x27;晚饭不要吃太多哦！&#x27;)&#125; else if (20 &lt;= getHour() &amp;&amp; getHour() &lt;= 23) &#123; alert(&#x27;干哈呢！都晚上&#x27; + getHour() + &#x27;点了,还不睡？快睡觉去~&#x27;)&#125;&lt;/script&gt; 3.6.3.3 表单属性修改12345678910&lt;button&gt;按钮&lt;/button&gt; &lt;input type=&quot;text&quot; value=&quot;点我&quot;&gt; &lt;script&gt; var btn = document.querySelector(&#x27;button&#x27;); var input = document.querySelector(&#x27;input&#x27;); btn.onclick = function() &#123; input.value = &#x27;皮一下&#x27;; //修改input中的value属性 btn.disabled = true; //禁用点击 &#125; &lt;/script&gt; 仿登录隐藏密码案例：","categories":[],"tags":[]},{"title":"","slug":"1.计算机基础部分","date":"2021-03-05T09:19:38.852Z","updated":"2021-01-22T09:12:36.000Z","comments":true,"path":"2021/03/05/1.计算机基础部分/","link":"","permalink":"http://nanyu99.gitee.io/2021/03/05/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/","excerpt":"","text":"1.1 计算机基础 计算机可分为硬件、软件两种。其中硬件是看得见摸得着的，比如键盘、鼠标、硬盘等。软件是摸不着的，比如系统软件、应用软件。 系统软件包括：Windows、Linux、IOS 应用软件包括：QQ、微信、谷歌浏览器、英雄联盟等。 其中软件是在硬件的基础上运行的。 程序在电脑上的运行过程: 当打开某个文件时，CPU不会直接从硬盘中取文件，而是先从硬盘中加载程序的代码到内存中去。 CPU执行内存中的代码。 电脑这样做的原因:CPU读取数据是非常快的，而硬盘的速度则非常慢，如果只从硬盘中读取数据的话，会大大浪费CPU的性能，因此CPU选择读取速度更快的内存。 2.2 计算机语言 计算机语言可以分为三种:机器语言、汇编语言、高级语言。 机器语言:计算机能最终执行的，它是由0、1组成的二进制数，二进制是计算机的基础。 汇编语言:汇编语言本质上与机器语言相同，都是直接对硬件进行操作，只不过汇编语言的指令采用了特殊的英语缩写标识，更容易被记忆和识别。 高级语言:主要相对于低级需要来说的，他不是一种具体的语言，而是由许多编程语言组成，比如java、c、go语言、javascript、python等。 高级语言相对来说更适合人类编写，但计算机所能够识别的语言只有0、1构成的机器语言，因此计算机不能直接识别人类所编写的高级语言。这时就需要一种中间物体，能够将人类所写的高级语言转换为计算机所能识别的机器语言，这个中间物体就是**解释器**，比如java所依赖的JVM上就有java解释器 编程语言与标记语言的区别： 编程语言:有很强的逻辑性，是主动的，比如在编程语言里会有大量的if else ,for ,while等。 标记语言(Html):不用于向计算机发出指令，常用于格式化和链接，标记语言的存在是被读取的，是被动的。","categories":[],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2021-03-02T10:24:42.000Z","updated":"2021-03-02T10:27:46.584Z","comments":true,"path":"2021/03/02/我的第一篇博客文章/","link":"","permalink":"http://nanyu99.gitee.io/2021/03/02/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"第一章你好呀 第二章随便说说啦 第三章再见","categories":[],"tags":[]}],"categories":[],"tags":[]}