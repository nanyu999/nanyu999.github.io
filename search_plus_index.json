{"./":{"url":"./","title":"简介","keywords":"","body":"项目测试 "},"1-Java/1-Java学习笔记一-基础语法.html":{"url":"1-Java/1-Java学习笔记一-基础语法.html","title":"1. Java学习笔记一 基础语法","keywords":"","body":"1. Java跨平台原理 什么是平台 平台指的是操作系统平台，比如Windows、Linux、Mac 什么是跨平台？ Java程序可以在任意平台上运行 跨平台原理 不同国家的人之间交流需要翻译才能进行交流。 同理，Java程序在不同的操作系统上运行时也需要一个翻译，而这个翻译就是Java虚拟机（JVM：Java Virtua Machine），以下简称JVM。 我们只需要针对不同的操作系统提供不同的JVM即可实现Java跨平台。在Win上运行Java程序时提供Win版的JVM；在Mac上运行Java程序时提供Mac版的JVM；在Linux上运行Java程序时提供Linux版的JVM即可。 总结：在需要运行Java应用程序的操作系统上，安装一个与操作系统对应的Java虚拟机(JVM：Java Virtua Machine)即可。 2.JRE和JDK 2.1 什么是JRE？ JRE：(Java Runtime Environment)是Java程序运行时环境，包含JVM和运行时所需的核心类库。我们想要运行一个Java程序，只需要安装JRE即可。 上节说到JVM能保证Java跨平台运行，而JRE又包含JVM，所以我们只安装JRE也能保证Java跨平台运行 2.2 什么是JDK？ JDK：(Java Development Kit)，包含JRE和开发人员使用的开发工具。我们想开发一个全新的Java程序，必须要安装JDK。 开发工具：编译工具（javac.exe）、运行工具（java.exe） 实际开发时我们只需要JDK即可，因为它包含了JRE和开发工具。 2.3 关系图 3.JDK下载与安装 官网下载 注意：下载时要下载与自己电脑操作系统相对应的版本。 4.常用DOS命令 打开命令提示符窗口： 1.按下Win+R 2.在弹出框中输入cmd 3.敲回车或点确定 常用命令 操作 说明 D:回车或者d:回车 切换到D盘 dir 查看当前路径下的所有内容 cd 目录 切换到指定目录 cd blog（按下Tab键可补齐目录） cd .. 返回上级目录 cd blog\\themes 切换到多级目录 cd \\ 返回到当前盘的根目录 cls 清屏 exit 退出命令提示符窗口 5.Path环境变量配置 5.1 为什么配置环境变量 我们在开发Java程序时，需要用到JDK提供的开发工具，而这些工具在JDK的安装目录的bin目录下。 如果不配置Java环境变量会怎么样？打开命令提示窗口，输入javac或java，然后回车就会会提示以下内容： 'javac' 不是内部或外部命令，也不是可运行的程序或批处理文件。 怎么才能正常使用javac或java命令？ 方法一： 执行javac或java命令时，先切换到JDK的bin目录下，再执行命令 方法二： 由于每次执行命令时都要切换到bin目录下，所有略显麻烦，在实际开发中也不方便，所以才有了一种一劳永逸的方法二，即配置环境变量。 5.2 配置环境变量（JDK8为例） 打开文件管理器，右键此电脑，选择属性。 点击高级系统设置 点击环境变量 找到系统变量，点击新建，会弹出窗口。 变量名：JAVA_HOME 变量值：JDK的安装路径 在系统变量中找到Path，点击编辑 点击新建，添加下图中两条变量，最后点击确定。 以上，Java环境变量已经配置完成，在任意目录下执行javac命令若如下图，则说明配置成功。 6.第一个Java程序 开发一个Java程序需要三个步骤：编写程序、编译程序、运行程序 Java属于编译型语言，因此在运行Java程序之前需要先对Java源程序进行编译，编译成Java自己字节码文件，最后才能执行Java程序。 第一个Java程序：Hello World： 1.新建文本文档，修改名为HelloWorld.java 2.用记事本打开HelloWorld.java文本，输入以下内容并保存 public class HelloWorld{ public static void main (String [] args) { System.out.println(\"Hello World！\"); } } 3.打开命令提示符窗口，进入到HelloWorld.java所在目录，使用以下命令先对java源程序进行编译 javac HelloWorld.java 编译完成后会在HelloWorld.java的同级目录下生成一个命名为java类名，后缀名为.class的文件HelloWorld.class，使用以下命令即可执行该字节码文件。 //注意:java直接跟文件名，不能加后缀，加后缀会报错 java HelloWorld 7.常量、变量、数据类型 7.1 注释 注释指在程序指定位置添加说明性信息 注释不参与程序运行，仅起到说明作用 注释分为：单行注释、多行注释、文档注释 单行注释 public class HelloWorld{ public static void main (String [] args) { //这是单行注释，程序不会执行此行 System.out.println(\"Hello World！\"); } } 多行注释 public class HelloWorld{ public static void main (String [] args) { /* 这是多行注释 程序不会执行我们 我的注释范围比单行注释更广*/ System.out.println(\"Hello World！\"); } } 文本注释 /** 这是文档注释 **/ public class HelloWorld{ public static void main (String [] args) { System.out.println(\"Hello World！\"); } } 7.2 关键字 关键字描述：关键字就是被Java语言赋予了特殊含义的单词 关键字的特点： 关键字的字母全部小写 常用的代码编辑器对关键词有特殊的颜色显示 关键字有50多个左右 //该程序中的public、class、void都是最常见的关键字，后期会学到更多的关键字 public class HelloWorld{ public static void main(String [] args){ System.out.println(\"Hello World\"); } } 7.3 常量 常量概述：在程序运行过程中，其值不可以再发生改变的量 常量分类： 常量类型 说明 举例 字符串常量 英文双引号括起来 \"钉子君博客\" ， \"钉子君\" 整数常量 整数包括正负 18，-18，0 小数常量 含有小数点的数字 1.5，10.0，10.00，-1.0，0.1 字符常量 用单引号括起来 'A'，'0'，'我' 布尔常量 布尔值，表真假 只有两个值：true、false 空常量 一个特殊值：空值 null public class HelloWorld{ public static void main(String [] args){ //字符串常量 System.out.println(\"Hello World\"); //整数常量 System.out.println(12); System.out.println(-12); //小数常量 System.out.println(12.1); System.out.println(-12.1); //字符常量 System.out.println('1'); System.out.println('我'); System.out.println('A'); //布尔常量 System.out.println(true); System.out.println(false); //空常量 System.out.println(null); } } 7.4 数据类型 计算机的存储单元 计算机是可以用来存储数据的，但无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位(bit)\"，又称之 为“比特位”，通常用小写的字母” b”表示。而计算机中最小的存储单元叫“字节(byte)\"，通常用大写字 母”B”表示，字节由连续的8个位组成。 1B(字节) = 8bit 1KB = 1024B 1MB = 1024kB 1GB = 1024MB 1TB = 1024GB 数据类型 Java语言是强类型语言，对于每一种数据都给出了明确的数据类型，不同的数据类型也分配了不同的内存空间,所 以它们表示的数据大小也是不一样的。Java在声明变量时必须指明该变量的数据类型，但比如Python、 JavaScript就不许要指明数据类型。 Java中的数据类型分为两大类分别是基本类型和引用类型，基本类型包含int，float，double，char， boolean等八种类型，引用类型包含类，数组，接口三种类型。 数据类型 描述 占用字节 取值范围 默认值 int 整型，用于存储整数 4字节 -2147483648~2147483647 0 byte Java中最小的数据类型 1字节 -128~127 0 short 短整型 2字节 -32768~32717 0 long 长整型 8字节 -2^63~2^63-1 0L float 浮点型，用于存储带小数点的数字 4字节 0.0f double 双精度浮点型，用于存储带有小数点的数字 8字节 0.0d char 字符型，用于存储单个字符 2字节 0~65535 空 boolean 布尔类型，用于判断真或假 1字节 true、false false 数据类型之间的相互转换 类型转换分为：自动类型转换和强制类型转换 自动类型转换：将表示数值小的变量类型转换为表示数值类型大的数据类型，小数据类型转换为大数据类型可以自动转换。 表示数据范围从小到大图 案例：10为int类型，但将它赋值给double类型的变量时，10就自动转换为了浮点型10.0 public class HelloWorld{ public static void main(String [] args){ double d=10; System.out.println(d);//结果为10.0 } } 强制类型转换：将表示数值大的变量类型转换为表示数值类型小的数据类型，大数据类型转换为小数据类型需强制转换。 案例：10.0为double类型，但将它赋值给int类型时，需要强制转换才能转换成功 public class HelloWorld{ public static void main(String [] args){ int n=(int)10.0;//(目标数据类型) System.out.println(n);//结果为10 } } 7.6 变量 变量概述：在程序运行过程中，其值可以发生改变的量。从本质上来说，变量就是内存中的一小块区域 变量定义： 格式：数据类型 变量名=变量值; 范例：int num=10; 使用变量： 取值和修改值 取值：变量名 范例：num 修改值：num=18; 变量使用的注意事项: 变量名字不能重复 变量未赋值不能使用 long类型的变量定义的时为防止整数过大，后面要加L float类型变量定义时，为防止类型不兼容，后面要加F 8.运算符 8.1 算术运算符 符号 作用 说明 加 + 1+2=3，''1'+''2'=''12'' ，'A'+10=75 减 - 2-1=1，1.5-1=0.5 乘 * 21=2，2.0 1=2.0 除 / 6/5=1，整数相除只能得到整数；6.0/5=1.2 取余 % 8%4=0，0是两个数相除的余数 实例： public class Test1 { public static void main(String[] args) { int a=1; int b=2; System.out.print(a+b); System.out.print(b-a); System.out.print(a*b); System.out.print(a/b); System.out.print(b%a); } } 注意1： 算术表达式中包含多个基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。 提升规则： byte类型，short类型和char类型将被提升到int类型 整个表达式的类型自动提升到表达式中最高等级操作数同样的类型等级顺序: byte,short,char →int → long → float double public class Test1 { public static void main(String[] args) { int a=1; char b='A'; double c=10.1 System.out.print(b+a);//11 ,结果提升为int类型 System.out.print(b+c);//20.1 ,结果提升为double类型 } } 注意2： 字符也可以做+运算操作，并且字符也有数值。 详见：ASCII对照表 public class Test1 { public static void main(String[] args) { int a=1; char b='A';//对应ASCII值为65 System.out.print(b+a);//11 } } 注意3： 字符串也可以做+运算操作。 字符串相加，结果直接拼接 public class Test1 { public static void main(String[] args) { int a=10; String b=\"钉子君\"; String c=\"牛哇牛哇\"; int d=6 System.out.print(b+a);//钉子君11 System.out.print(b+c);//钉子君牛哇牛哇 System.out.print(b+a+d);//钉子君106 System.out.print(a+d+b);//16钉子君 } } 8.2 赋值运算符 符号 作用 说明 = 赋值 a=10;将10赋值给a += 加后赋值 a+=1;等价于a=a+1; -= 减后赋值 a-=1;等价于a=a-1; *= 乘后赋值 a=1;等价于a=a 1; /= 除后赋值 a/=1;等价于a=a/1; %= 取余后赋值 a%=1;等价于a=a%1; 实例： public class Test1 { public static void main(String[] args) { int a=10; System.out.print(a);//10 a+=10; System.out.print(a);//20 a-=10; System.out.print(a);//0 a*=10; System.out.print(a);//100 a/=10; System.out.print(a);//1 a%=3; System.out.print(a);//1 } } 8.3 自增/减运算符 自增：自动加一 自减：自动减一 实例： public class Test1 { public static void main(String[] args) { int a=1; //先输出a的值，再进行++操作 System.out.println(a++);//1 int b=1; //先进行++操作，再输出b的值 System.out.println(++b);//2 int c=2; //先输出c的值，再进行--操作 System.out.println(c--);//2 int d=2; //先进行--操作，再输出d的值 System.out.println(--d);//1 } } 8.4 关系运算符 符号 说明 == a==b，判断a和b的值是否相等，成立为true，不成立为false != a!=b，判断a和b的值是否不相等，成立为true，不成立为false > a>b，判断a是否大于b。成立为true，不成立为false >= a>=b，判断a是否大于等于b，成立为true，不成立为falsea 判断a是否小于b，成立为true，不成立为falsea 判断a是否小于等于b，成立为true，不成立为false 实例： public class Test1 { public static void main(String[] args) { int a=1; int b=1; int c=2; String str1=\"你好\"; String str2=\"你好\"; System.out.println(a==b);//true System.out.println(a==c);//false System.out.println(a=b);//true System.out.println(str1==str2);//true } } 8.5 逻辑运算符 在数学中，一个数据x，大于3，小于6，我们可以这样来进行表示: 3 但在Java中，不能直接写上面的表达式，需要把上面的式子先进行拆解，再进行合并。 拆解：x>3且x 合并：x>3&&x 逻辑运算符 符号 作用 说明 & 逻辑与 a&b,a和b都是true，结果为true，否则为false \\ 逻辑或 a\\ b,a和b都是false，结果为false，否则为true ^ 逻辑异或 a^b，a和b结果不同为true，相同为false ！ 逻辑非 !a，结果和a的结果正好相反 public class Test1 { public static void main(String[] args) { int a=1; int b=2; int c=3; System.out.println(b>a&c>a);//true System.out.println(b>c|c>a);//true System.out.println(b>c^c>a);//false^true true System.out.println(b>a^c>a);//true^true false System.out.println(ba^ca)^c 短路逻辑运算符 符号 作用 说明 && 短路与 作用和&相同，但是有短路效果 \\ \\ 短路或 作用和\\ 相同，但是有短路或效果 逻辑与&，无论左边真假，右边都要执行。 短路与&&，如果左边为真，右边执行；如果左边为假。右边不执行。 逻辑或，无论左边真假，右边都要执行。 短路或|l，如果左边为假，右边执行；如果左边为真，右边不执行. 最常用的逻辑运算符：&&与|| 8.6 三元运算符 格式：关系表达式？表达式1:表达式2 范例：a>b?a:b 计算规则：先计算关系表达式的值，如果值为true，表达式1的值就是运算结果。如果值为false，表达式2的值就是运算结果。 public class Test1 { public static void main(String[] args) { int a=1; int b=2; //表达式成立则输出表达式1，表达式不成立输出表达式2 System.out.println(a>b?a:b);//2 } } 9. 分支语句 流程控制语句分类： 顺序结构 分支结构（if，switch） 循环控制（for，while，do…while） 9.1 顺序结构 顺序结构是程序中最基本最简单的流程控制，它没有特定的语法结构，按照代码的先后顺序依次执行代码，程序中大部分代码都是这样执行的。 public class Test1 { public static void main(String[] args) { System.out.println(\"这是顺序结构案例\"); System.out.println(\"没有特定的语法结构\"); System.out.println(\"按照代码的先后顺序依次执行代码\"); System.out.println(\"程序中大部分代码都是这样执行的\"); } } 9.2 分支结构 9.2.1 if语句 语法格式一：if if(表达式){ 语句体; } 执行流程: 首先计算关系表达式的值 如果关系表达式的值为true就执行语句体 如果关系表达式的值为false就不执行语句体 继续执行后面的语句内容 public class Test1 { public static void main(String[] args) { int a = 1; int b = 2; if (a 语法格式二：if-else if(表达式){ 语句体1; }else{ 语句体2; } 执行流程: 首先计算关系表达式1的值 如果关系表达式的值为true就执行语句体1 如果关系表达式的值为false就执行语句体2 public class Test1 { public static void main(String[] args) { int a = 1; int b = 2; if (a 语法格式三：if…else-if if(表达式1){ 语句体1; }else if(表达式2){ 语句体2; }else if(表达式3){ 语句体3; . . . }else{ 语句体n; } 执行流程: 首先计算关系表达式1的值 如果关系表达式的值为true就执行语句体1 如果关系表达式1的值为false就执行表达式2 如果表达式2的值为true，则执行语句体2 如果表达式2的值为false，就执行表达式3 这样一直向下执行，如果所有表达式都不满足，则执行表达式n public class Test1 { public static void main(String[] args) { int a = 1; int b = 2; if (a b){ System.out.println(\"a大于b\"); }else{ System.out.println(\"a等于b\"); } } } if…else-if 案例： import java.util.Scanner; public class Test1 { public static void main(String[] args) { System.out.print(\"请输入你的成绩：\"); Scanner sc = new Scanner(System.in); int score = sc.nextInt(); if (score >= 90 && score = 70 && score = 60 && score 9.2.2 switch语句 语法格式： switch(表达式){ case 值1: 语句体1; break; case 值2: 语句体2; break; case 值3: 语句体3; break; case 值4: 语句体4; break; default: 语句体n; } 执行流程: 先计算表达式的值。 依次和case后面的值进行比较，如果有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。 如果所有的case后面的值和表达式的值都不匹配，就会执行default里面的语句体，然后程序结束掉。 实例： import java.util.Scanner; public class Test1 { public static void main(String[] args) { System.out.print(\"请输入一个1-5的整数：\"); Scanner sc = new Scanner(System.in); int n=sc.nextInt(); switch (n){ case 1: System.out.print(\"你输入的是1\"); break; case 2: System.out.print(\"你输入的是2\"); break; case 3: System.out.print(\"你输入的是3\"); break; case 4: System.out.print(\"你输入的是4\"); break; case 5: System.out.print(\"你输入的是5\"); break; default: System.out.print(\"你输入的数有问题\"); break; } } } 如果不加break，程序就不会跳出，会自动执行到代码的最底端。 9.3 循环结构 循环结构的组成： 初始化语句:用于表示循环开启时的起始状态， 简单说就是循环开始的时候什么样 条件判断语句:用于表示循环反复执行的条件,简单说就是判断循环是否能-直执行 下去 循环体语句:用于表示循环反复执行的内容， 简单说就是循环反复执行的事情 条件控制语句:用于表示循环执行中每次变化的内容,简单说就是控制循环是否能执行下去 循环结构对应的语法: 初始化语句:这里可以是一 条或者多条语句,这些语句可以完成-些初始化操作 条件判断语句:这里使用一个结果值为boolean类型的表达式，这个表达式能决定是否执行循环体。例如: a 循环体语句: .这里可以是任意语句,这些语句将反复执行 条件控制语句:这里通常是使用一条语句来改变变量的值， 从而达到控制循环是否继续向下执行的效果。常见i+ + ,j--这样的操作 9.3.1 for循环 语法结构： for(初始化语句;条件判断语句;条件控制语句){ 循环体; } 执行流程: 1.执行初始化语句 2.执行条件判断语句，看其结果是true还是false，如果是false,循环结束，如果是true,继续执行 3.执行循环体语句 4.执行条件控制语句 5.回到2继续 实例： for(int i=0;i 9.3.2 while循环 语法格式： while(条件判断语句){ 循环体语句; 条件控制语句; } 执行流程: 1.执行初始化语句 2.执行条件判断语句，看其结果是true还是false，如果是false,循环结束，如果是true,继续执行 3.执行循环体语句 4.执行条件控制语句 5.回到2继续 实例： int i=1; while(i 9.3.3 do…while循环 语法格式： do{ 循坏体; }while(条件控制语句) 执行流程: 1.执行初始化语句 2.执行循环体语句 3.执行条件控制语句 4.执行条件判断语句，看其结果是true还是false，如果是false,循环结束，如果是true,继续执行 5.回到2继续 i=3; do{ System.out.println('你好'); i++; }while(i 三种循环的区别： for循环和while循环先判断条件是否成立，然后决定是否执行循环体(先判断后执行) do..while循环先执行一次循环体, 然后判断条件是否成立，是否继续执行循环体(先执行后判断) while循环与for循环的区别： 条件控制语句所控制的自增变量,因为归属for循环的语法结构中,在for循环结束后， 就不能再次被访问到了 条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后,该变量还可以续 使用 9.4.4 跳转控制语句 Java中的循环控制语句有两种，分别是：continue与break continue用法： 用在循环中，基于条件控制，跳过某次循环体内容的执行，继续下一次的执行 //输出结果为：0，1，3，4 public class Test1 { public static void main(String[] args) { for (int i = 0; i break： 用在循环中，基于条件控制，终止循环体内容的执行，也就是说结束当前的整个循环 //输出结果为：0，1,2 public class Test1 { public static void main(String[] args) { for (int i = 0; i 10.数组 数组概述： 一次性声明大量的用于存储数据的变量。 要存储大的数据通常是相同的数据类型，比如：考试成绩 什么是数组： 数组（array）是一种用于存储多个相同数据类型的存储模型 数组的定义格式： 格式一（推荐使用）： 数据类型 [] 变量名:int [] arr 定义了一个int类型的数组，数组名为arr 格式二： 数据类型 变量名 []:int arr[] 定义了一个int类型的变量，变量名为数组arr 10.1 数组初始化 数组中的元素必须需要先初始化才能使用。- 什么是初始化 初始化就是为数组中的数组元素分配内存空间，并为每个数组元素赋值。 动态初始化 动态初始化：初始化时只指定数组的长度，由系统为数组分配初始值。 格式：数据类型 [] 变量名=new 数据类型[数组长度] public class Test1 { public static void main(String[] args) { int [] arr=new int[5]; } } int :数组的数据类型，也可以是String、double等 []:说明这是一个数组 arr:数组的名称 new:关键字，为数组申请内存空间 5：数组长度，即数组中的元素个数。 静态初始化 静态初始化：即在声明数组时，直接指明数组的元素。 格式：数据类型 [] 变量名=new 数据类型[元素1，元素2，元素3] public class Test1 { public static void main(String[] args) { int [] arr={1，2，3，4}; } } 10.2 数组元素访问及遍历数组 数组中元素的访问是通过数组名[索引]来实现的，所谓索引也叫下标就是给每一个数组元素分配一个从0开始的序号。 实例： public class Test1 { public static void main(String[] args) { int [] arr=new int[1，2，3，4];//下标从0开始，数组中1的下标为0，2的下标为1，3的下标为2，4的下标为3 //直接输出数组名字的话得到的是数组在堆空间中的内存地址 System.out.println(arr) //访问数组元素时就是通过下标来访问，比如访问数组中的元素2，元素2对应的下标为1，则 System.out.println(arr[1])//输出为2 } } 数组的遍历 数组的遍历就是通过循环，将数组中的所有元素全部打印出来，其中循环我们一般用for循环。 public class Test1 { public static void main(String[] args) { int [] arr=new int[1，2，3，4]; //数组的ength属性用来获取数组的长度 for(int i=0;i 10.3 内存分配 Java中的内存分配 Java程序在运行时，需要在内存中分配空间。为了提高运算效率,就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方 式和内存管理方式。 其中粉红色的内存区域为栈内存：存储局部变量，定义在方法中的变量，例如: arr，变量使用完毕后立即消除 右侧蓝色部分为堆内存：存储new出来的内容(实体,对象)，数组在初始化时，会为存储空间添加默认值 整数: 0；浮点数: 0.0；布尔: false；字符:空字符；引用数据类型: null 每一个new出来的东西都有一个地址值使用完毕，会在垃圾回收器空闲时被回收 10.4 数组常见两个问题 索引越界 如果声明一个长度为3的数组，则它的索引只能是0，1，2，如果使用时索引大于2，则会运行时报错 public class Test1 { public static void main(String[] args) { int [] arr= {1,2,3}; //索引越界 System.out.println(arr[4]); } } //会报索引越界异常 /* Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 4 at Test1.main(Test1.java:6) */ 空指针异常 访问的数组已经不再指向堆内存的数据，造成空指针异常 public class Test1 { public static void main(String[] args) { int [] arr= {1,2,3}; //将数组值设为空 arr=null; System.out.println(arr[1]); } } //会报空指针异常 /* Exception in thread \"main\" java.lang.NullPointerException at Test1.main(Test1.java:7) */ 11. 方法 方法：方法是具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集 方法必须先创建再使用，该过程成为方法的定义，创建完方法之后需要调用才能执行方法。 11.1 方法的定义与调用 方法的定义： public static void 方法名(){ //方法体 } //实例 public static void run(){ System.out.println(\"跑步\") } 方法的调用： 在调用方法之前，该方法必须被事先定义好的，如果没有定义而调用，则会报错。 public class Test1 { public static void main(String[] args) { //方法的调用，调用run（）方法 run(); } public static void run() { System.out.print(\"跑步\"); } } 实例： public class Test1 { public static void main(String[] args) { //2.调用方法 getMax(); } //1.定义方法 public static void getMax() { int a = 10; int b = 12; if (a > b) { System.out.println(a); } else { System.out.println(b); } } } 11.2 带参数的方法 形参与实参： 形参：形参是定义方法时定义的参数，等同于变量定义格式 实参：方法定义时，实际传入的参数，等同于使用变量或常量 带参数的方法的定义： public static void 方法名(数据类型 参数1,数据类型 参数2,数据类型 参数3…){ //方法体 } //实例 public static void run(String name){ System.out.println(name+\"在跑步\") } 带参数的方法的调用： 方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错 public class Test1 { public static void main(String[] args) { //方法的调用，调用run（）方法 run(\"南雨\"); } public static void run(String name) { System.out.print(\"跑步\"); } } 实例： public class Test1 { public static void main(String[] args) { //向getSum中传递的参数，必须与定义方法时设置的参数数据类型，和参数个数保持一致 //1，2，3为实参 getSum(1, 2, 3); } //a,b,c为形参 public static void getSum(int a, int b, int c) { System.out.print(a + b + c); } } 11.3 带返回值方法的定义与调用 带返回值的方法的定义： 方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错 public static 数据类型 方法名(参数){ reutrn 数据类型; } public static int getInt(int a){ return a; } public static String getString(String str){ return 100; } public static int getInt(int a){ return \"南雨\"; } public static boolean getBoolean(int b){ return True; } 带返回值方法的调用 格式一： 方法名（参数）; getboolean(0); 格式二： 数据类型 变量名=方法名（参数）; Boolean flag=getBoolean(0); 方法的返回值通常会使用变量接收,否则该返回值将无意义，所以更推荐用格式二来调用方法 实例： public class Test1 { public static void main(String[] args) { //向getSum中传递的参数，必须与定义方法时设置的参数数据类型，和参数个数保持一致 int sum=-getSum(1, 2, 3); System.out.print(sum); } public static int getSum(int a, int b, int c) { int n=a+b+c; return n; } } 11.4 有关方法注意事项 方法与方法之间不能嵌套定义，只能一个方法定义另一个方法。 void关键字表示无返回值，课省略return，也可以单独写return，但return后面不加数据。 11.5 方法重载 重载概述： 方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载 多个方法在同一个类中 多个方法具有相同的方法名 多个方法的参数不相同，类型不同或者数量不同 重载特点： 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，不能通过返回值来判定两个方法是否相互构成重载 public class Test1 { public static void main(String[] args) { //向getSum中传递的参数，必须与定义方法时设置的参数数据类型，和参数个数保持一致 int sum=-getSum(1, 2, 3); int sum2=-getSum(1, 2); double sum1=getSum(1.7,1.9); System.out.println(sum); System.out.println(sum1); System.out.println(sum2); } public static int getSum(int a, int b, int c) { int n=a+b+c; return n; } public static int getSum(int a, int b) { int n=a+b; return n; } public static double getSum(double a, double b) { double n=a+b; return n; } } 12. DeBug debug： 是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。 debug操作流程： Debug调试，又被称为断点调试，断点其实是一个标记，告诉我们从哪里开始查看。具体操作流程：如何加断点、如何运行加了断点的程序、看哪里、点哪里、如何删除断点 加断点 运行加了断点的程序 观察debug窗口 观察console窗口，观察运行结果 点F7键可向下执行代码，再次点击断点处可删除断点。 "},"1-Java/2-Java学习笔记二-面向对象.html":{"url":"1-Java/2-Java学习笔记二-面向对象.html","title":"2. Java学习笔记二 面向对象","keywords":"","body":"1.类和对象 什么是对象？ 万物皆可对象，客观存在的事物皆为对象。水杯、手机、电脑、铅笔、汽车、飞机等只要是客观存在的事物都可以对象。 什么是面向对象？ 面向对象的方法主要是把事物给对象化，包括其属性和行为。面向对象说到底就是一种思想，任何事物都可以看作 是一个对象。之前在知乎上看到过一篇有关面向对象和面向过程的介绍，比较通俗易懂。 文章链接：点我进入 什么是类？ 类是对现实生活中一类具有共同属性和行为的事物的抽象。 类的特点： 类是对象的数据类型。 类是具有相同属性和行为的一组对象的集合（也可以说一个类对应多个对象，只要这些对象的属性和行为是相同的）。 什么是对象属性？ 属性：对象具有的各种特征，每个对象的每个属性都拥有特定的属性值，以人为例。 属性 属性值 身高 189cm 体重 135kg 性别 男 年龄 26 什么是对象的行为？ 行为：对象能执行的操作，还以人为例。 人可以吃饭、睡觉、学习、跑步等行为。 类和对象的关系 类：类是对现实生活中一类具有共同属性和行为的事物的抽象 对象：是能够看得到摸的着的真实存在的实体 类是对象的抽象，对象是类的实体，比如下图。右边的对象实现了左边类里所有的属性与行为，左边的类是右边对象的抽象。 2.类的定义 类的重要性：类是java程序最基本的组成单位 类是什么：是对现实生活中一类具有共同属性和行为的事物的抽象，确定对象将会拥有属性和行为。 类的组成：类是由属性和行为组成 属性：在类中通过成员变量来体现。（类中方法外的变量） 行为：在类中通过成员方法来体现（即不带static关键字） 注意：Java中就没有全局变量这个概念，只分为成员变量和局部变量，全局变量与成员变量基本没什么区别，全局变量是C语言中的叫法，但很多人在学Java时习惯把成员变量叫做全局变量。 类的定义步骤： 定义类 public class 类名{ } 编写类的成员变量 public class 类名{ //成员变量 数据类型 变量1; 数据类型 变量2; } 编写类的成员方法 public class 类名{ //成员变量 数据类型 变量1; 数据类型 变量2; …… //成员方法 方法1; 方法2; …… } 实例： package com.zut.nanyu; public class Person { //声明成员变量 public String name; //public为修饰符，后面会有介绍，暂时不用关注 public int age; public String sex; //声明成员方法 public void run(){ System.out.print(\"跑步\"); } public void speak(){ System.out.print(\"说话\"); } } 3.使用对象 使用对象之前，我们需要先创建一个对象。 创建对象的格式：类名 对象名=new 类名(); package com.zut.nanyu; public class Person { //声明成员变量 public String name; //public为修饰符，后面会有介绍，暂时不用关注 public int age; public String sex; //声明成员方法 public void run(){ System.out.print(\"跑步\"); } public void speak(){ System.out.print(\"说话\"); } } 创建对象： package com.zut.nanyu; public class Test1 { public static void main(String[] args) { //这里创建的对象就是Person类的实例化，此Person对象实例化了Person类中的所有的成员变量与成员方法，可以直接调用属性和方法。 Person p=new Person(); } } 对象的使用1： package com.zut.nanyu; public class Test1 { public static void main(String[] args) { Person p=new Person(); String pname=p.name; int page=p.age; String psex=p.sex; //未对属性赋值，所以属性被调用后输出的是默认值 System.out.print(pname);//输出为null System.out.print(page);//输出为0 System.out.print(psex);//输出为null } } 对象的使用2： package com.zut.nanyu; public class Test1 { public static void main(String[] args) { //创建对象 Person p=new Person(); //调用Person的属性 p.name=\"钉子君\"; p.age=34; p.sex=\"男\"; String pname=p.name; int page=p.age; String psex=p.sex; System.out.println(pname);//输出为钉子君 System.out.println(page);//输出为34 System.out.println(psex);//输出为男 //调用Person中的方法 p.run();//输出为跑步 p.speak();//输出为说话 } } 4.成员变量与局部变量 成员变量：类中方法外的变量。 package com.zut.nanyu; public class Person { //声明成员变量 public String name; } 局部变量：方法中的变量 package com.zut.nanyu; public class Person { //声明成员变量 public String name; public void run(){ int str=\"钉子君\"; System.out.print(str); } } 局部变量与成员变量的区别： 区别 成员变量 局部变量 类中位置不同 类中方法外 类中方法内 内存中位置不同 对内存 栈内存 生命周期不同 随着对象的存在而存在，随对象消失而消失 随方法的调用而存在，方法调用完毕消失 初始化值不同 有默认的初始化值 无默认的初始化值，必须先定义赋值才能使用 5.封装 5.1 private关键字 private是一个权限修饰符 可以修饰成员（成员变量和成员方法) 作用是保护成员不被别的类使用，被private修饰的成员只在本类中才能访问 被private修饰的成员变量不能被别的类随意访问。针对private修饰的成员变量，如果需要被其他类使用，需 要提供相应的操作，public修饰的变量允许被其他类调用，所以不需要get(),set()方法 提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰 提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰 实例： Person类 package com.zut.nanyu; public class Person { //public修饰的成员变量可以被其他类调用 public String name; //private修饰的方法只能在本类中使用，其他类无法直接调用。 private int age; //如果想调用private修饰的变量可以通过get（）和set（）方法来获取和设置值,两个方法 //get()和set()方法都要用public修饰 //set()方法为private修饰的变量赋值 public void setAge(int a) { age = a; } //set()方法获取private修饰的变量 public int getAge() { return age; } } 测试类： package com.zut.nanyu; public class Test1 { public static void main(String[] args) { Person p=new Person(); p.name=\"钉子君\"; //通过调用setAge(实参)方法来为age传参 p.setAge(-19); System.out.println(p.name); //通过调用getAge()方法来调用age属性值 System.out.println(p.getAge()); } } 为什么private修饰的成员变量要用get()，set()方法来设置和获取值？ 原因： private修饰的变量表示我们不想让其他人随意调用这个变量，有时候需要对别人传过来的属性值加一限制，比如Person中的age变量代表的是人的年龄属性，如果调用者传入的值是上述代码中的-19，那么这个值显然是不符合常理的，所以我们有时需要对别人传入的变量值做限制，让变量的赋值更加规范。而我们刚好可以通过set方法，在传入变量值时对其加以判断，筛选掉不符合逻辑或不符合我们要求的值。 package com.zut.nanyu; public class Person { public String name; private int age; //在set()方法中加入判断条件，如果年龄不在范围内，则输出错误信息 public void setAge(int a) { if(a120){ System.out.println(\"输入的年龄有误!\"); }else{ age = a; } } public int getAge() { return age; } } 5.2 this关键字 this修饰的变量用于指代成员变量，方法形参如果与成员变量同名，不带this修饰的变量指得时形参而不是成员变量，用this修饰的变量为成员变量。 什么时候用this关键字？ 当局部变量与成员变量同名时，防止局部变量把成员变量隐藏。 package com.zut.nanyu; public class Person { public String name; private int age; //成员变量与形参同名，用this关键字来指代成员变量，this后面跟的就是成员变量，赋值号后面的就是局部变量 public void setAge(int age) { this.age = age; } public int getAge() { return age; } } this的内存原理 5.3 封装 封装概述： 是面向对象三大特征之一(封装，继承，多态)，是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的 分装原则： 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问成员变量private，提供对应的getXxox()/setXxx()方法 封装好处： 通过方法来控制成员变量的操作，提高了代码的安全性把代码用方法进行封，提高了代码的复用性 5.4 构造方法 构造方法概述：构造方法是一种特殊的方法。 构造方法作用：创建对象 构造方法功能：完成对象数据的初始化 语法格式： public class 类名(){ //如果没有参数的话，叫无参构造器 修饰符 类名(参数){ } } 实例： Person类： package com.zut.nanyu; public class Person { public String name; private int age; //一个类中可以同时有无参构造器和有参构造器 //无参构造器 public Person() { System.out.println(\"无参构造器\"); } //有参构造器 public Person(String name, int age) { this.name = name; this.age = age; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } } 测试类： package com.zut.nanyu; public class Test1 { public static void main(String[] args) { Person p=new Person();//这里相当于调用了无参构造函数 p.name=\"钉子君\"; //通过调用setAge(实参)方法来为age传参 p.setAge(19); System.out.println(p.name); //通过调用getAge()方法来调用age属性值 System.out.println(p.getAge()); } } //输出结果 /* 无参构造器 钉子君 -19 */ 5.5 构造方法注意事项 注意事项一： 如果Person类中程序员没有写构造方法，创建对象并调用时程序会不会报错？答案是：不会！ 下面的Person类中没有写构造函数，但程序运行时不会报错。原因是当一个类中没有给任何的构造方法，系统会默认给一个无参的构造函数。 package com.zut.nanyu; public class Person { public String name; private int age; public void setAge(int age) { this.age = age; } public int getAge() { return age; } } 注意事项二： 如果在类中已经创建了一个有参构造器，而没有创建无参构造函数，则在创建对象时不能使用无参构造器，若想使用无参构造器同时使用有参构造器，必须同时创建有参构造器和无参构造器。 package com.zut.nanyu; public class Test1 { public static void main(String[] args) { //有参构造器，使用时必须传参 Person p = new Person(\"钉子君\", 30); //Person类中只有一个有参构造器，如果像下面那样构建对象，则会报错 // Person p = new Person(); System.out.println(p.getAge()); System.out.println(p.getName()); } } 5.6 标准类的制作 成员变量 使用private修饰 构造方法 提供一个无参构造方法 提供一个带多个参数的构造方法 成员方法 提供每一个成员变量对应的setXXX()/getXXX() 提供一个显示对象信息的show() 创建对象并为其成员变量赋值的两种方式 无参构造方法创建对象后使用setXxxx()赋值 使用带参构造方法直接创建带有属性值的对象 实例： Person类： package com.zut.nanyu; public class Person { private String name; private int age; //无参构造器 public Person() { } //有两个参数的构造器 public Person(String name, int age) { this.age = age; this.name = name; } //有一个参数的构造器 public Person(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } public void setName(String name) { this.name = name; } public String getName() { return name; } } 测试类： package com.zut.nanyu; public class Test1 { public static void main(String[] args) { //使用无参构造器 Person p = new Person(); p.setAge(15); p.setName(\"钉子君\"); //有参构造器，必须传参 Person p1 = new Person(\"钉子君\", 30); Person p2 = new Person(\"钉子君\"); System.out.println(p.getAge()); System.out.println(p.getName()); } } "},"1-Java/4-Java学习笔记四-继承、多态.html":{"url":"1-Java/4-Java学习笔记四-继承、多态.html","title":"4. Java学习笔记四 继承、多态","keywords":"","body":"1 继承 1.1 继承简介 继承概述：继承是面向对象三大特征之一。可以使得子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法 继承格式： public class 子类名 extends 父类名(){ } public class ZiLei extends FuLei(){ } 父类：也称基类、超类 子类：也称派生类 实例： 定义一个Person父类 public class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.age = age; this.name = name; } public void sleep() { System.out.println(\"睡觉\"); } public void eat() { System.out.println(\"吃饭\"); } public void walk() { System.out.println(\"走路\"); } public Person(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } public void setName(String name) { this.name = name; } public String getName() { return name; } } 定义一个Student子类来继承Person父类 /** * 因为Studnet继承了Person，所以Person中的方法Student的对象都可以使用 */ public class Student extends Person { private String idcard; //public Student(String idcard){ // this.idcard=idcard; //} public Student() { } public void study(String id) { System.out.println(\"学号:\"+this.idcard+\" 姓名:\"+id+ \"正在学习\"); } public void setIdcard(String idcard) { this.idcard = idcard; } public String getIdcard() { return idcard; } } 定义一个测试类测试继承 public class Test1 { public static void main(String[] args) { Student student = new Student(); Person person = new Person(); person.setName(\"轩辕狗蛋\"); student.setIdcard(\"1111111\"); System.out.println(person.getName()); System.out.println(student.getIdcard()); //调用子类中的方法 student.study(person.getName()); //子类继承父类之后可以直接调用父类中的方法 student.eat(); student.walk(); } } 1.2 继承优缺点 继承的优点 提高了代码的复用性（多个类相同的成员可以放到同一个类中） 提高了代码的维护性（如果方法中的代码需要修改，则只需要修改一处即可） 继承的缺点 继承让类与类之间产生了关系，类的耦合性增强，当父类发生变化时子类也要发生变化，削弱了子类的独立性 什么时候使用继承 假设有两个类A和B，如果满足A是B的一种，或B是A的一种，则说明他们存在继承关系，就可以考虑使用继承 来体现，否则就不能滥用继承。比如:苹果和水果之间可以用继承，猫和动物之间可以用继承，猫和狗之间不能用继承 1.3 变量访问特点 定义一个Person父类 public class Person { public int age=30; } 定义一个Student子类 public class Student extends Person { public int age=40; public void show(){ int age=50; System.out.print(age); } } 定义一个测试类 public class Test1 { public static void main(String[] args) { Student student = new Student(); student.show();//输出结果为show（）方法中定义的age=50 } } 此时测试类中的结果为50，如果show()方法中没有int age=50则输出结果为40，如果Student类中没有public int age=40则输出结果为30。 继承中变量访问特点 子类局部范围找（函数中） 子类成员范围找（成员变量） 父类成员范围找 如果都没有就报错(不考虑父亲的父亲...) 1.4 super、this关键字 1.4.1 this关键字 由变量的访问特点可知，如果在函数中定义了与成员变量同名的局部变量，那么在测试类中直接调用的函数的话输出结果为30，如果想让测试类中的输出结果是成员变量中的age，则需要用到this关键字 定义一个Person父类 public class Person { public int age=30; } 定义一个Student子类 public class Student extends Person { public int age=40; public void show(){ int age=50; System.out.print(\"我是在show()方法中定义的局部变量age，值为:\"+age); System.out.print(\"我是在Student类中定义的成员变量age，值为:\"+this.age); } } 定义一个测试类 public class Test1 { public static void main(String[] args) { Student student = new Student(); student.show(); } } /* 输出结果: 我是在show()方法中定义的局部变量age，值为:50 我是在Student类中定义的成员变量age，值为:40 */ 1.4.2 super关键字 由1.4.2 章节可以了解到使用this关键字可以指代成员变量。那么在继承关系中，如果想让输出结果为父类中的与子类的同名变量则需要使用super关键字。 定义一个Person父类 public class Person { public int age=30; } 定义一个Student子类 public class Student extends Person { public int age=40; public void show(){ int age=50; System.out.print(\"我是在show()方法中定义的局部变量age，值为:\"+age); System.out.print(\"我是在Student类中定义的成员变量age，值为:\"+this.age); System.out.print(\"我是在Person类中定义的成员变量age，值为:\"+super.age); } } 定义一个测试类 public class Test1 { public static void main(String[] args) { Student student = new Student(); student.show(); } } /* 输出结果: 我是在show()方法中定义的局部变量age，值为:50 我是在Student类中定义的成员变量age，值为:40 我是在Person类中定义的成员变量age，值为:30 */ 1.4.3 总结 super与this关键字用法相似 this代表本类对象的引用 super代表父类存储空间的标识（父类对象的引用） this和super的三种用法 关键字 访问成员变量 访问构造方法 访问成员方法 this this.成员变量（访问本类成员变量） this()（访问本类构造方法） this.成员方法()（访问本类成员方法） super super.成员变量（访问父类成员变量） super()（访问父类构造方法） super.成员方法()（访问父类成员方法） 1.5 构造方法的访问特点 定义一个父类 public class Person { public Person(){ System.out.println(\"父类无参构造方法被调用\"); } public Person(int age){ System.out.println(\"父类有参构造方法被调用\"); } } 定义一个子类 public class Student extends Person { public Student(){ super();//默认存在，不写也会存在 System.out.println(\"子类无参构造器被调用\"); } public Student(String name){ super();//默认存在，不写也会存在 System.out.println(\"子类中有参构造器被调用\"); } } 定义一个测试类 public class Test1 { public static void main(String[] args) { Student student = new Student(); Student stu=new Student(20); } } /* 输出结果 父类无参构造方法被调用 子类无参构造器被调用 父类无参构造方法被调用 子类中有参构造器被调用 */ 子类中所有的构造方法默认都会访问父类中无参的构造方法，为什么? 因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。 每一个子类构造方法的第一条语句默认都是: super()，因此每次调用子类时默认通过super()方法，调用了父类的无参构造器，如果想调用父类的有参构造器，只需要在子类构造器中使用super(参数)调用即可。 如果父类中没有无参构造方法，只有带参构造方法，该怎么办? 通过使用super关键字去显示的调用父类的带参构造方法 在父类中自己提供一个无参构造方法(推荐:自己给出无参构造方法) 1.6 成员方法的访问特点 定义一个子类 public class Teacher extends Person { public void method() { System.out.println(\"Teacher类中Method\"); } public void show() { System.out.println(\"Teacher类中show方法\"); } } 定义一个父类 public class Person { public void method() { System.out.println(\"Person类中Method\"); } public void show() { System.out.println(\"Person类中show方法\"); } } 定义一个测试类 public class Test3 { public static void main(String[] args) { Teacher t=new Teacher(); t.method(); t.show(); } } 总结： 通过子类对象访问一个方法，先在子类成员范围找，然后再从父类成员范围找，如果都没有就报错(不考虑父亲的父亲...) 1.7 方法重写 方法重写概述：子类中出现了和父类中完全相同的方法 方法重写应用：当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容。 定义一个父类： 并定义一个call()方法 public class Person { public void method() { System.out.println(\"Person类中Method\"); } public void show() { System.out.println(\"Person类中show方法\"); } public void call(String name){ System.out.println(\"给\"+name+\"打电话\"); } } 定义一个子类： 定义一个与父类中相同名称的call()方法，并在父类的基础上添加新内容，实现方法的重写。 public class Teacher extends Person { public void method() { System.out.println(\"Teacher类中Method\"); } public void show() { System.out.println(\"Teacher类中show方法\"); } public void call(String name){ System.out.println(name+\"犯错了\"); //使用父类call()方法，可以沿袭父类功能 super.call(name); } } 定义一个测试类： public class Test3 { public static void main(String[] args) { Teacher t=new Teacher(); t.call(\"小明\"); } } /* 输出结果： 小明犯错了 给小明的家长打电话 */ @Override注解关键字：检验重写方法时方法声明的正确性，如果子类中重写的方法名称与父类中不一致，则会报错。 方法重写的注意事项： 子类不能重写父类中的私有方法（private修饰的方法） 在子类中重写方法时，子类方法的访问权限不能比父类低，即如果父类中的方法用default（默认）级别修饰，则子类在重写方法时方法的访问权限必须比default高或者相同（public>default>private） 1.8 继承注意事项 Java中只支持单继承，不支持多继承 //错误案例 public class son extends Father,Mother{ } Java支持多层继承 //正确案例 public class son extends Father{ } public class Father extends GrandFather{ } 1.9 修饰符 1.9.1 导包 概述： 使用不同包下的类时，使用的时候要写类的全路径，写起来太麻烦，为了简化带包的操作，Java提供了导包的功能。 格式：import 包名 案例：import com.zut.nanyu.Teacher 1.9.2 修饰符 修饰符：权限修饰符、状态修饰符 权限修饰符： 修饰符 同一类中 同一包中子类无关类 不同包的子类 不同包的无关类 private √ 默认 √ √ protected √ √ √ public √ √ √ √ final修饰变量 变量是基本类型: final修饰指的是基本类型的数据值不能发生改变 变量是引用类型: final修饰指的是引用类型的地址值不能发生改变，但是地址扯里面的内容是可以发生改变的 final修饰基本类型变量 public class FinalDemo { public static void main(String[] args) { // final修饰基本类型变量 final int age=100; // age=200; final修饰变量之后，变量就变为了常量，就不能重新赋值了（会报错） System.out.println(age); } } final修饰引用类型变量 定义一个Teacher类 public class Teacher extends Person { public int age=0; } 定义一个测试类 public class FinalDemo { public static void main(String[] args) { //final修饰引用数据类型t之后，只说明了t的地址值不能再变，但t里面的内容是可以改变的 final Teacher t=new Teacher(); // t=new Teacher(); //会报错，因为这个行为修改了对象的地址值 t.age=10; System.out.println(t.age); } } 状态修饰符： static是静态的意思，它可以修饰成员方法和成员变量 定义一个Teacher类： public class Teacher extends Person { public String name; public String school; public int age; public void show(){ System.out.println(\"姓名:\"+name+\",年龄:\"+age+\" 岁\"+\",学校:\"+school); } } 定义一个测试类： public class StaticDemo { public static void main(String[] args) { Teacher t=new Teacher(); t.name=\"张三\"; t.school=\"中国政法大学\"; t.age=20; t.show(); t.name=\"李四\"; t.school=\"中国政法大学\"; t.age=39; t.show(); } } //输出结果:姓名:张三,年龄:20 岁,学校:中国政法大学 //输出结果:姓名:李四,年龄:39 岁,学校:中国政法大学 现要求t.school=\"中国政法大学\"只赋值一次，而不用每次都重复赋值 重新定义Teacher类：将school类用static关键字修饰 public class Teacher extends Person { public String name; // public String school; public static String school; public int age; public void show() { System.out.println(\"姓名:\" + name + \",年龄:\" + age + \" 岁\" + \",学校:\" + school); } } 定义一个测试类： public class StaticDemo { public static void main(String[] args) { //推荐这样对static修饰的变量赋值 Teacher.school=\"清华大学\" Teacher t=new Teacher(); t.name=\"张三\"; //如果一个属性被static修饰，不建议像下边这样写 //t.school=\"清华大学\"; t.age=20; t.show(); //此处不再对t.school进行赋值 t.name=\"李四\"; t.age=39; t.show(); } } //输出结果:姓名:张三,年龄:20 岁,学校:清华大学 //输出结果:姓名:李四,年龄:39 岁,学校:清华大学 static修饰的特点： 被类的所有对象共享，也是判断是否使用静态关键字的条件 可以通过类名调用，也可以通过对象名调用，推荐使用类名调用 1.9.3 static访问特点 非静态的成员方法 能访问静态的成员变量 能访问非静态的成员变量 能访问静态的成员方法 能访问非静态的成员方法 静态的成员方法 能访问静态的成员变量 能访问静态的成员方法 总结：静态成员方法只能访问静态成员 2 多态 2.1 多态简介 多态概述：同一对象，在不同时刻的不同形态 举例： // 猫 cat=new 猫(); // 可以说猫是猫 // 也可以说猫是动物，这两种说法都不错 // 动物 animal=new 猫(); 多态的形式：具体类多态，抽象类多态，接口多态。 多态的前提：有继承或者实现关系;有方法重写;有父(类/接口)引用指向(子/实现)类对象心 多态实现的前提： 有继承/实现关系 有方法重写 有父类引用指向子类对象 代码实例： 创建一个动物类 public class Animal { public void eat(){ System.out.println(\"动物吃东西\"); } } 创建一个猫类，并继承动物类 public class Cat extends Animal { @Override public void eat() { System.out.println(\"猫吃鱼\"); } } 创建一个测试类 public class Test1 { public static void main(String[] args) { //继承关系：Cat类继承Animal类 //方法重写：Cat类中重写了Animal类中的eat()方法 //父类引用指向子类对象 Animal a=new Cat(); a.eat(); } } //输出结果 //猫吃鱼 2.2 多态中成员的访问特点 成员方法： 编译看左边，运行看左边 成员变量：编译看左边，运行看右边 成员方法和成员变量访问不一样的原因：成员方法有重写，而成员方法没有。 多态形式访问成员方法时只能访问子类中重写父类的方法，子类中自定义的方法不能访问 创建一个Animal类 public class Animal { public int age = 12; public void eat() { System.out.println(\"动物吃东西\"); } } 创建一个Cat类 public class Cat extends Animal { public int age = 30; public int weight = 120; @Override public void eat() { System.out.println(\"猫吃鱼\"); } //子类中自定义的方法 public void playGame(){ System.out.println(\"猫玩游戏\"); } } 创建一个测试类 public class Test1 { public static void main(String[] args) { Animal a=new Cat(); System.out.println(a.age);//输出结果：12 // System.out.println(a.weight); 会报错，父类中没有weight属性 a.eat(); // //a.playGame(); 由于这是子类中自定义的方法，所以不能访问 } } 2.3 多态的好处与弊端 多态的好处：提高了程序的扩展性 具体体现：定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作 多态的弊端：不能使用子类特有的功能。 程序实例： 创建一个Animal类： public class Animal { public void eat() { System.out.println(\"动物吃东西\"); } } 创建一个Cat类： public class Cat extends Animal { @Override public void eat() { System.out.println(\"猫吃鱼\"); } public void playGame(){ System.out.println(\"猫玩游戏\"); } } 创建一个Dog类： public class Dog extends Animal{ @Override public void eat() { System.out.println(\"狗吃骨头\"); } public void lookDoor() { System.out.println(\"狗卡看门\"); } } 创建一个动物操作类： public class OperateAnimal { /* 下面这种操作过于繁琐，每新增一种动物都要重新写一个方法，程序延展性太低，不推荐使用 public void useAnimal(Cat cat) { cat.eat(); } public void useAnimal(Dog dog) { dog.eat(); } */ //利用多态，父类引用指向子类对象，可以通过传入子类对象的方式来调用子类方法，只需写一个方法即可，提高了程序的扩展性，这是多态的好处。但多态的缺点就是只能调用子类中重写父类的方法，子类中特有的方法无法被访问。 public void useAnimal(Animal animal){ animal.eat(); } } 创建一个测试类： public class Test1 { public static void main(String[] args) { OperateAnimal o=new OperateAnimal(); Dog dog=new Dog(); o.useAnimal(dog);//狗吃骨头 Cat cat=new Cat(); o.useAnimal(cat);//猫吃鱼 } } 2.4 多态的转型 多态中转型可分为： 向上转型：从子到父，父类引用指向子类对象 向下转型：从父到子，父类引用转换为子类对象 程序实例： public class Test1 { public static void main(String[] args) { //向上转型,只能访问子类中重写父类的方法 Animal animal=new Cat(); animal.eat();//猫吃鱼 //向下转型，可以访问子类中特有的方法 Cat c= (Cat)animal; c.eat(); c.playGame(); } } 2.5 猫和狗案例（多态版） 定义一个Animal类： public class Animal { private String name; private int age; public Animal(){ } public Animal(String name,int age){ this.age=age; this.name=name; } public void eat(){ System.out.println(\"动物吃东西\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 定义一个Cat类： public class Cat extends Animal { public Cat(){ } public Cat(String name,int age){ super(name,age); } @Override public void eat() { System.out.println(\"猫吃饭\"); } } 定义一个Dog类： public class Dog extends Animal{ public Dog() { } public Dog(String name, int age) { super(name, age); } @Override public void eat() { System.out.println(\"狗吃饭\"); } } 定义一个测试类： public class Test1 { public static void main(String[] args) { Animal animal=new Cat(); animal.setAge(2); animal.setName(\"布丁\"); System.out.println(animal.getAge()+\" \"+animal.getName()); animal=new Cat(\"蓝渐\",3); System.out.println(animal.getAge()+\" \"+animal.getName()); } } 2.6 抽象类 抽象类概述： 在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类。一个抽象类中可以有非抽象方法，也可以没有抽象方法，但只要类中有抽象方法，该类一定是抽象类 程序实例： public abstract class Animal { /* public abstract void eat(){ System.out.println(\"吃东西\") }; */ //抽像方法没有方法体 public abstract void eat(); } 2.7 抽象类的特点 抽象类和抽象方法必须使用abstract关键字修饰 public abstract class 类名{} public abstract void eat(){} 抽象类中不一定有抽象方法，但有抽象方法的类一定是抽象类。 抽象类不能实例化，不过它可以参照多态的方式，通过子类对象实例化。叫抽象类多态。 抽象类的子类要么重写抽象类中的所有方法，要么是个抽象类。 创建一个Animal抽象类： public abstract class Animal { //抽象方法 public abstract void eat(); public void sleep() { System.out.println(\"睡觉\"); } } 创建一个Cat类： public class Cat extends Animal { @Override public void eat() { System.out.println(\"猫吃鱼\"); } } 创建一个测试类： public class Test1 { public static void main(String[] args) { //抽象类需要采用多态的形式创建对象 Animal a=new Cat(); a.eat();//此处的eat()方法是Cat类中重写的方法 a.sleep();//此处的sleep()是Cat类中继承Animal的方法 } } 2.8 抽象类的成员特点 成员变量，抽象类中可以有变量，也可以有常量 构造方法，抽象类中有构造方法，但不能实例化，它的作用是用于子类访问父类数据的初始化 成员方法，可以有抽象方法，限定子类必须重写的方法，也可以有普通方法，提高代码的复用性。 2.9 猫和狗案例（抽象类版） 定义一个Animal抽象类 public abstract class Animal { private int age; private String name; // 构造方法 public Animal() { } public Animal(int age, String name) { this.age=age; this.name=name; } //抽象方法 public abstract void eat(); public void sleep() { System.out.println(this.name+\"在睡觉\"); } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 定义Dog类继承Animal public class Dog extends Animal { public Dog() { } public Dog(String name, int age) { super(age, name); } @Override public void eat() { System.out.println(super.getAge()+\"的\"+super.getName()+\"在吃骨头\"); } } 定义Cat类继承Animal public class Cat extends Animal { public Cat() { } public Cat(int age, String name) { super(age, name); } @Override public void eat() { System.out.println(super.getAge()+\"的\"+super.getName()+\"在吃鱼\"); } } 定义一个测试类 public class Test1 { public static void main(String[] args) { //抽象类需要采用多态的形式创建对象 Animal a = new Cat(); a.setName(\"多多\"); a.setAge(1); a.eat();//此处的eat()方法是Cat类中重写的方法 a.sleep();//此处的sleep()是Cat类中继承Animal的方法 System.out.println(\"----------------------------------\"); Animal d = new Dog(); d.setName(\"豆豆\"); d.setAge(2); d.eat();//此处的eat()方法是Cat类中重写的方法 d.sleep();//此处的sleep()是Cat类中继承Animal的方法 } } /* 输出结果 多多在睡觉 ---------------------------------- 2的豆豆在吃骨头 豆豆在睡觉 */ 3 接口 接口概述：接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用，比如笔记本电脑上的键盘接口、鼠标接口等，再比如日常家用插座，虽然制造的厂商不同，但都能通用。 Java中的接口更多体现在对行为的抽象 3.1 接口的特点 接口用关键字interface修饰 public interface 类名{} 类实现接口用implements接口名{} public implements 接口名{} 接口不能实例化，如果要实例化，需要以多态的形式实例化，叫接口多态 多态的形式：具体类多态，抽象类多态，接口多态。 多态的前提：有继承或者实现关系;有方法重写;有父(类/接口)引用指向(子/实现)类对象心 接口的实现类，要么重写接口中所有的抽象方法，要么是抽象类 定义一个Jumpping接口 package com.study.nanyu.day02; /* 定义一个接口 */ public interface Jumpping { public abstract void jump(); } 定义一个Cat类实现接口并重写方法 package com.study.nanyu.day02; public class Cat implements Jumpping{ @Override public void jump() { System.out.println(\"猫猫跳高了\"); } } 定义一个Dog类实现接口，不重写方法 package com.study.nanyu.day02; public abstract class Dog implements Jumpping { } 定义一个测试类 package com.study.nanyu.day02; public class Demo { public static void main(String[] args) { // Jumpping j=new Jumpping(); 报错，接口也是抽象内容，不能以普通方法被实例化 //以多态的形式将接口实例化 Jumpping j=new Cat(); j.jump(); } } /* 输出结果: 猫猫跳高了 */ 3.2 接口成员特点 成员变量：接口中只有常量，没有变量，即使定义的是变量，也会变成常量。默认修饰符：public static final 构造方法：接口中没有构造方法，因为接口主要是对行为进行抽象的，没有具体的存在，一个类如果没有父类，默认继承自Object类 成员方法：接口里的方法只能是抽象方法。默认修饰符：public abstract 3.3 猫和狗案例（接口版） 定义一个接口 package com.study.nanyu.day02.one; public interface Jumpping { public abstract void jump(); } 定义一个Animal抽象 package com.study.nanyu.day02.one; public abstract class Animal { private String name; private int age; public Animal(){} public Animal(String name, int age) { this.name = name; this.age = age; } public abstract void eat(); public void sleep(){ System.out.println(\"睡觉\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 定义一个Cat类，继承Animal类，实现Jumpping接口 package com.study.nanyu.day02.one; public class Cat extends Animal implements Jumpping { public Cat() { } public Cat(String name, int age) { super(name, age); } @Override public void jump() { System.out.println(\"猫猫跳高了\"); } @Override public void eat() { System.out.println(\"猫吃鱼\"); } public void show(){ System.out.println(\"喵喵喵~\"); } } 定义一个Dog类，继承Animal类，实现Jumpping接口 package com.study.nanyu.day02.one; public class Dog extends Animal implements Jumpping { public Dog() { } public Dog(String name, int age) { super(name, age); } @Override public void jump() { System.out.println(\"狗狗跳高了\"); } @Override public void eat() { System.out.println(\"狗吃骨头\"); } } 定义一个测试类 package com.study.nanyu.day02.two; import com.study.nanyu.day02.one.Animal; import com.study.nanyu.day02.one.Cat; import com.study.nanyu.day02.one.Dog; import com.study.nanyu.day02.one.Jumpping; public class Demo { public static void main(String[] args) { //接口中方法与抽象类中的方法只能分开调用，这种使用方法不恰当 Jumpping j = new Cat(); j.jump();//重写的接口中的方法 Animal c = new Cat(); c.setAge(12); c.setName(\"多多\"); System.out.println(c.getAge()+\"的猫猫\"+c.getName()); c.sleep();//抽象类中的非抽象方法 c.eat();//重写的抽象父类中的方法 System.out.println(\"------------------------------------\"); Jumpping d = new Dog(); d.jump();//重写的接口中的方法 Animal d1 = new Dog(); d1.setAge(11); d1.setName(\"拉拉\"); System.out.println(d1.getAge()+\"的猫猫\"+d1.getName()); d1.sleep();//抽象类中的非抽象方法 d1.eat();//重写的抽象父类中的方法 System.out.println(\"------------------------------------\"); //正确的使用方法，Cat中包含接口和抽象类中最多的方法 Cat cat=new Cat(); cat.setAge(10); cat.setName(\"布布\"); System.out.println(cat.getAge()+\"的猫猫\"+cat.getName()); cat.eat(); cat.sleep(); cat.jump(); } } /* 输出结果 猫猫跳高了 12的猫猫多多 睡觉 猫吃鱼 ------------------------------------ 狗狗跳高了 11的猫猫拉拉 睡觉 狗吃骨头 ------------------------------------ 10的猫猫布布 猫吃鱼 睡觉 猫猫跳高了 */ 4 内部类 内部类概述：内部类就是在一个类中定义一个类。例如，在类A中定义一个类B，则B为A的内部类。 4.1 内部类 内部类定义格式： public class 类名{ 修饰符 class 类名{ } } public class outer{ public class inner{ } } 内部类的访问特点： 内部类可以直接访问外部类的成员，包括私有 外部类想访问内部类的成员必须先创建对象 程序实例： package com.study.nanyu.day03; public class Outer { public String name = \"钉子君\"; public int age = 19; private String gender = \"女\"; //内部类 public class Inner { public void show() { //内部类可以直接访问外部类成员 System.out.println(name); System.out.println(gender); } } public void method() { //外部类不能直接访问内部类成员方法 Inner i = new Inner(); i.show(); } } 4.2 成员内部类 按照内部类在类中定义的位置不同，可分为如下两种形式： 在类的成员位置：成员内部类 在类的局部位置：局部内部类（方法中） 对于成员内部类，外界如何创建对象并调用方法？ 格式：外部类名.内部类名 对象名=外部类对象.内部类对象 程序实例： 创建内部类 package com.study.nanyu.day03.two; public class Outer { private int num=10; private class Inner{ public void show(){ System.out.println(num); } } public void menthod(){ Inner i=new Inner(); i.show(); } } 创建Demo类 package com.study.nanyu.day03.two; public class Demo { public static void main(String[] args) { //创建内部类对象，并调用内部类方法 //方式一 /* 此方式只用于内部类修饰符为public时才适用 Outer.Inner i=new Outer().new Inner(); i.show(); */ //方式二 Outer o=new Outer(); o.menthod(); } } 4.3 局部内部类 局部内部类是在方法中定义的类，所以外界是无法直接使用，需要在方法内部创建对象并使用。 该类可以直接访问外部类的成员，也可以访问方法内的局部变量 程序实例： 创建外部类 package com.study.nanyu.day03.three; public class Outer { private int num=0; public void method(){ class Inner{ public void show(){ System.out.println(num); } } Inner i=new Inner(); i.show(); } } 创建内部类 package com.study.nanyu.day03.three; import com.study.nanyu.day03.two.Outer; public class Demo { public static void main(String[] args) { Outer o=new Outer(); o.menthod(); } } 4.4 匿名内部类 前提：存在一个类或接口，这个类可以是具体类，也可以是抽象类 本质：是一个继承了该类或实现了该接口的子类匿名对象，匿名内部类是局部内部类的一种形式。 格式： new 类名或接口名(){ //重写方法 } new Inter(){ public void show(){ } } 程序示例 定义一个接口 package com.study.nanyu.day03.four; public interface Inter { void show(); } 定义一个外部类 package com.study.nanyu.day03.four; public class Outer { public void method() { //它的本质是实现了Inter接口的子类的匿名对象 new Inter() { @Override public void show() { System.out.println(\"Hello World\"); } }; //方法调用 new Inter() { @Override public void show() { System.out.println(\"Hello World\"); } }.show(); //方法调用 Inter i = new Inter() { @Override public void show() { System.out.println(\"Hello World\"); } }; i.show(); i.show(); i.show(); } } 定义测试类 package com.study.nanyu.day03.four; public class Demo { public static void main(String[] args) { Outer o=new Outer(); o.method(); } } 4.5 匿名内部类的应用 采用匿名内部类可以提升扩展性，节省不必要的代码。 定义一个接口 package com.study.nanyu.day04; public interface Jump { public void jump(); } 定义一个Cat实现类 package com.study.nanyu.day04; public class Cat implements Jump{ @Override public void jump() { System.out.println(\"猫猫跳高啦！\"); } } 定义一个Cat实现类 package com.study.nanyu.day04; public class Dog implements Jump { @Override public void jump() { System.out.println(\"狗狗跳高了\"); } } 定义一个Dog类 package com.study.nanyu.day04; public class JumpOperate { public void method(Jump jump){ jump.jump(); } } 定义一个测试类 package com.study.nanyu.day04; public class Demo { public static void main(String[] args) { /* 扩展性不高，每增加一个新的动物，就要新创建一个类 Jump j=new Cat(); Jump j1=new Dog(); JumpOperate jo=new JumpOperate(); jo.method(j); jo.method(j1); */ JumpOperate jo=new JumpOperate(); jo.method(new Jump() { //匿名内部类的本质是对象 @Override public void jump() { System.out.println(\"猫猫可以跳高了\"); } }); jo.method(new Jump() { //匿名内部类的本质是对象 @Override public void jump() { System.out.println(\"狗可以跳高了\"); } }); jo.method(new Jump() { //匿名内部类的本质是对象 @Override public void jump() { System.out.println(\"猪可以跳高了\"); } }); } } "},"1-Java/6-Java学习笔记六-异常与集合.html":{"url":"1-Java/6-Java学习笔记六-异常与集合.html","title":"6. Java学习笔记六 异常与集合","keywords":"","body":"1 异常 异常：就是程序出现了不正常的情况 异常体系： Error：严重问题，不需要处理 Exception：称为异常类，他表示程序本身可以处理的问题 RuntimeException：在编译器不需要检查，出现问题后，需要回来修改代码。 非RuntimeException：编译时就需要处理，否则程序不能通过编译，不能正常运行。 1.1 JVM默认处理方式 如果程序出现了问题，最终JVM会做默认的处理。 把异常的名称，异常原因及异常出现的位置等信息输出在控制台 程序停止执行 程序演示 package com.study.nanyu.day08; public class ExceptionDemo { public static void main(String[] args) { System.out.println(\"开始\"); show(); System.out.println(\"结束\"); } public static void show(){ int [] arr={1,2,3}; System.out.println(arr[4]); } } /* 输出结果 开始 Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 4 at com.study.nanyu.day08.ExceptionDemo.show(ExceptionDemo.java:12) at com.study.nanyu.day08.ExceptionDemo.main(ExceptionDemo.java:6) */ 1.2 try...catch 格式： try{ 可能出现异常的代码; }catch(异常类名 变量名){ 异常的处理代码; } 执行流程： 程序从try里面的代码开始执行，出现异常会自动生成异常类对象，该异常类对象将被自动提交给Java运行时系统。 当Java运行时系统接收到异常对象时，会到catch中去找匹配的异常类，找到后进行异常处理。 执行完毕之后，程序可以继续往下执行。 程序实例： package com.study.nanyu.day08; public class ExceptionDemo { public static void main(String[] args) { System.out.println(\"开始\"); show(); System.out.println(\"结束\"); } public static void show(){ try { int[] arr = {1, 2, 3}; System.out.println(arr[4]); //catch()中填入异常对象的名称 }catch (ArrayIndexOutOfBoundsException e){ System.out.println(\"出问题啦！数组索引越界啦！\"); } } } /* 输出结果 开始 出问题啦！数组索引越界啦！ 结束 */ 1.3 Throwable Throwable类是所有异常类的父类 方法名 说明 public String getMessage() 返回此throwable的详细信息字符串 public String toString() 返回此可抛出的简短描述 public void printStackTrace() 把异常的错误信息输出在控制台上 程序实例： 因为Throwable是所有异常类的父类，所以ArrayIndexOutOfBoundsException继承了Throwable类中的方法。 printStackTrace()方法： package com.study.nanyu.day08; public class ExceptionDemo { public static void main(String[] args) { System.out.println(\"开始\"); show(); System.out.println(\"结束\"); } public static void show() { try { int[] arr = {1, 2, 3}; System.out.println(arr[4]); } catch (ArrayIndexOutOfBoundsException e) { e.printStackTrace(); } } } /* 输出结果 开始 结束 java.lang.ArrayIndexOutOfBoundsException: 4 at com.study.nanyu.day08.ExceptionDemo.show(ExceptionDemo.java:14) at com.study.nanyu.day08.ExceptionDemo.main(ExceptionDemo.java:6) */ getMessage()方法 package com.study.nanyu.day08; public class ExceptionDemo { public static void main(String[] args) { System.out.println(\"开始\"); show(); System.out.println(\"结束\"); } public static void show() { try { int[] arr = {1, 2, 3}; System.out.println(arr[4]); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(e.getMessage()); } } } /* 输出结果 开始 4 结束 */ toString()方法 package com.study.nanyu.day08; public class ExceptionDemo { public static void main(String[] args) { System.out.println(\"开始\"); show(); System.out.println(\"结束\"); } public static void show() { try { int[] arr = {1, 2, 3}; System.out.println(arr[4]); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(e.toString()); } } } /* 输出结果 开始 java.lang.ArrayIndexOutOfBoundsException: 4 结束 */ 1.4 编译时异常与运行时异常 Java中的异常被分为两大类:编译时异常和运行时异常，也被称为受检异常和非受检异常。 所有的RuntimeException类及其子类被称为运行时异常，其他的异常都是编译时异常. 编译时异常:必须显示处理，否则程序就会发生错误，无法通过编译 运行时异常:无需显示处理，也可以和编译时异常一样处理 package com.study.nanyu.day08; import java.text.SimpleDateFormat; import java.util.Date; public class ExceptionDemo { public static void main(String[] args) { method1(); } //运行时异常 public static void method1() { int[] arr = {1, 2, 3}; System.out.println(arr[4]); } //编译时异常 public static void method2(){ String date=\"2021-06-06\"; SimpleDateFormat df=new SimpleDateFormat(\"yyyy-MM-dd\"); Date parse = df.parse(date);//报错，导致无法运行程序 System.out.println(parse); } } 1.5 throws 虽然我们通过try...catch.….可以对异常进行处理，但并不是所有的情 况我们都有权限进行异常的处理. 格式： throws 异常类名; 注意：throws跟在方法的括号后面 package com.study.nanyu.day08; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class ExceptionDemo { public static void main(String[] args) throws ParseException { method1(); } //运行时异常 public static void method1() throws ParseException { String date=\"2021-06-06\"; SimpleDateFormat df=new SimpleDateFormat(\"yyyy-MM-dd\"); Date parse = df.parse(date); System.out.println(parse); } } 编译时异常必须要进行处理，两种处理方案: try..catch ..或者throws，如果采用throws这种方案，将来谁调用谁处理 运行时异常可以不处理，出现问题后，需要回来修改代码 1.6 自定义异常 自定义异常类并继承Exception类 package com.study.nanyu.day08.one; public class ScoreExceptiom extends Exception{ public ScoreExceptiom(){}; public ScoreExceptiom(String message){ super(message); }; } 定义一个Teacher类 package com.study.nanyu.day08.one; public class Teacher { public void checkScore(int score)throws ScoreExceptiom { if (score 100) { //手动抛异常 throw new ScoreExceptiom(\"分数有误！\"); }else{ System.out.println(\"分数正常\"); } } } 定义一个测试类 package com.study.nanyu.day08.one; import java.util.Scanner; public class TeacherDemo { public static void main(String[] args) { Scanner sc=new Scanner(System.in); int score=sc.nextInt(); Teacher t=new Teacher(); try { t.checkScore(score); } catch (ScoreExceptiom scoreExceptiom) { scoreExceptiom.printStackTrace(); } } } /* 输出结果 123 com.study.nanyu.day08.one.ScoreExceptiom: 分数有误！ at com.study.nanyu.day08.one.Teacher.checkScore(Teacher.java:7) at com.study.nanyu.day08.one.TeacherDemo.main(TeacherDemo.java:11) */ 1.6.1 throw与throws区别 throws 用在方法声明后面，跟的是异常类名表示抛出异常，由该方法的调用者来处理，表示出现异常的可能性，并不一定会发生异常 throw 用在方法体内，跟的是异常对象名表示抛出异常，由方法体内的语句处理，执行throw一定抛出了异常 2 集合 集合类的特点：提供一种存储空间可变的存储模型，存储的数据容量可以随时发生改变。集合的体系结构如下： 蓝色框表示接口，红色框表示实现类，接口无法直接实例化，需要先实现该接口，再通过其实现类进行实例化。 Collection：单列接口，它是所有单列接口的父接口 Map：双列接口，它是所有双列接口的父接口，其实现类有HashMap List：存储可重复元素的单列接口，其具体的实现类有ArrarlList、LikedList等 Set：存储不可重复元素的单列接口，其具体实现类有HashSet、TreeSet 集合存储的是引用数据类型，对于一般数据类型需要使用包装类 TreeSet set=new TreeSet<>(); LinkedList set=new LinkedList<>(); HashSet set=new HashSet<>(); 2.1 Collection Collection集合概述： 是单例集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素 JDK不提供Collection接口的任何直接实现，它提供更具体的子接口（如Set和List）实现 创建Collection集合的对象 多态的方式 具体的实现类ArrayList package com.study.nanyu.day09; import java.util.ArrayList; import java.util.Collection; public class CollectionDemo { public static void main(String[] args) { // 多态方式创建Collection对象 Collection c=new ArrayList(); c.add(\"Hello\"); c.add(\"World!\"); System.out.println(c); } } /* 输出结果 [Hello, World!] */ 总结：Collection如果要进行实例化，有两种方法，一种是通过多态的形式，二是通过其子接口的实现类实现实例化。 2.1.1 Collection常用方法 方法名 说明 boolean add(E e) 添加元素 boolean remove(Object o) 从集合中移除指定元素 void clear() 清空集合中的元素 boolean contains(Object o) 判断集合是否包含指定元素 boolean isEmpty() 判断集合是否为空 int size() 集合的长度，即集合中元素的个数 程序实例： package com.study.nanyu.day09; import java.util.ArrayList; import java.util.Collection; public class CollectionDemo { public static void main(String[] args) { Collection c=new ArrayList(); c.add(\"Hello \"); c.add(\"World \"); c.add(\"Java\"); System.out.println(c); // 移除集合中某一元素 c.remove(\"Java\"); // 判断集合是否包含某一元素 System.out.println(c.contains(\"Java\")); // 判断集合是否为空 System.out.println(c.isEmpty()); // 集合中元素个数 2 System.out.println(c.size()); } } 2.1.2 Collection集合的遍历 Iterator：迭代器，集合的专用遍历方式 Iterator iterator()：返回集合中元素的迭代器，通过集合的iterator()方法获得 迭代器是通过集合的iterator()方法得到的，所以说它是依赖于集合存在的。 Iterator中的常用方法 E next()：返回迭代中的下一个元素。 boolean hashNext():如果迭代器有更多元素，则返回true。 程序实例： package com.study.nanyu.day09; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; public class IteratorDemo { public static void main(String[] args) { Collection c=new ArrayList(); c.add(\"a\"); c.add(\"b\"); c.add(\"c\"); // 获取迭代器：iterator，其实是一种多态的形式 Iterator iterator = c.iterator(); // System.out.println(iterator.next()); // System.out.println(iterator.next()); // System.out.println(iterator.next()); // System.out.println(iterator.next()); 会报错，表示元素不存在 // 使用迭代器遍历集合 while (iterator.hasNext()){ System.out.println(iterator.next()); } } } /* 输出结果： a b c */ 2.1.3 集合存储学生对象 创建学生类 package com.study.nanyu.day09; public class Student { private String name; private int age; public Student() { } // get和set以及toString方法已省略 } 创建测试类 package com.study.nanyu.day09; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; public class StudentDemo { public static void main(String[] args) { //创建集合对象 Collection s=new ArrayList(); //创建对象 Student s1=new Student(\"张三\",18); Student s2=new Student(\"李四\",29); Student s3=new Student(\"王五\",68); //添加数据 s.add(s1); s.add(s2); s.add(s3); //遍历集合 Iterator iterator = s.iterator(); while (iterator.hasNext()){ System.out.println(iterator.next()); //System.out.println(iterator.next().getName()); } } } /* 学生集合{姓名:'张三', 年龄:18} 学生集合{姓名:'李四', 年龄:29} 学生集合{姓名:'王五', 年龄:68} */ 2.2 List集合 List集合概述： 有序集合(也称为序列)，用户可以精确控制列表中每个元素的插入位置，还可以通过整数索引访问元素，并搜索列表中的元素， 与Set集合不同，List集合中允许有重复的元素。 List集合特点： 有序，存储和取出的元素顺序一致； 可重复，存储的元素可以重复。 程序实例： package com.study.nanyu.day10; import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class ListDemo { public static void main(String[] args) { List list=new ArrayList(); //添加元素 list.add(\"hello\"); list.add(\"world\"); list.add(\"java\"); //可重复 list.add(\"hello\"); // System.out.println(list); // 遍历集合 Iterator iterator = list.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } } } /* hello world java hello */ 2.2.1 list特有方法 方法名 说明 void add(int index,E element) 指定位置插入元素 E remove(int index) 移除指定位置元素，返回删除的元素 E set(int index,E element) 修改指定位置元素，返回被修改的元素 E get(int index) 获取指定位置元素 程序实例： package com.study.nanyu.day10; import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class ListDemo { public static void main(String[] args) { // 多态的形式创建List对象 List list=new ArrayList(); //添加元素 list.add(\"hello\"); list.add(\"world\"); list.add(\"java\"); //指定位置添加元素 list.add(1,\"java\"); //删除指定位置元素,返回被删除的元素 list.remove(2); //修改指定位置元素 list.set(2,\"modify\"); //返回指定位置元素 list.get(2); System.out.println(list); for (int i=list.size()-1;i>=0;i--){ System.out.println(list.get(i)); } } } /* [hello, java, modify] modify java hello */ 2.2.2 ListIterator ListIterator：列表迭代器，继承自Iterator 通过List集合的listlterator()方法得到，所以说它是list集合特有的迭代器。 用于允许程序员沿任一方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置。 常用方法： E next()：返回迭代中的下一个元素。 boolean hasNext()：如果迭代具有更多元素，则返回true。 E previous()：返回列表中的上一个元素。 boolean hasPigvious()：如果此列表迭代器在相反方向遍历列表时具有更多元素，则返回true。 void add(e)：将指定的元素插入列表。 package com.study.nanyu.day10; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.ListIterator; public class ListDemo { public static void main(String[] args) { List list=new ArrayList(); //添加元素 list.add(\"hello\"); list.add(\"world\"); list.add(\"java\"); ListIterator lt = list.listIterator(); //正向遍历(很少用) while (lt.hasNext()){ System.out.println(lt.next()); } System.out.println(\"------------------\"); //反向遍历（很少用） while (lt.hasPrevious()){ System.out.println(lt.previous()); } System.out.println(\"------------------\"); //添加元素(很常用) while (lt.hasNext()){ String s = lt.next(); if(s.equals(\"java\")){ lt.add(\"添加了一个元素！\"); } } System.out.println(list); } } /* hello world java ------------------ java world hello ------------------ [hello, world, java, 添加了一个元素！] */ 2.2.3 ArrayList、LinkedList List集合常用子类：ArrayList、LinkedList ArrayList：底层数据结构是数组，查询快，增删慢（数组特点：查询快、增删慢） LinkedList：底层数据结构是链表，查询慢，增删快（链表特点：查询慢，增删快） 程序实例： package com.study.nanyu.day10; import java.util.ArrayList; import java.util.LinkedList; public class ListSon { public static void main(String[] args) { // ArrayList列表练习 ArrayList al=new ArrayList(); al.add(\"hello\"); al.add(\"world\"); for(String s:al){ System.out.println(s); } System.out.println(\"------------------\"); // LinkedList列表练习 LinkedList ll=new LinkedList(); ll.add(\"你好\"); ll.add(\"世界\"); for(String s:ll){ System.out.println(s); } } } /* hello world ------------------ 你好 世界 */ 2.2.2 LinkedList特有方法 LinkedList底层基于链表，链表有查询慢、增删快的特点，增删起来比较方便，只需要修改节点中下一个节点的地址即可。 方法名 说明 public void addFirst(E e) 在该列表开头插入指定元素 public void addLast(E e) 在该列表末尾追加指定元素 public E getFirst() 返回此列表第一个元素 public E getLast() 返回此列表最后一个元素 public E removeFirst() 删除此列表中第一个元素 public E removeLast() 删除此列表中最后一个元素 2.3 Set集合 Set集合特点： 不包含重复元素集合（元素不重复） 没有带索引的方法，不能使用普通for循环遍历 存储没有顺序 Set是一个接口，不能直接实例化，需要根据其实现类，以多态的形式进行实例化 Set最主要的两个实现类：HashSet、TreeSet Set集合与Collection集合没有很大的区别，最重要的不同在于Set集合中没有重复的元素，本章主要探究Set集合如何保证集合中没有重复元素。 程序实例： package day11; import java.util.HashSet; import java.util.Iterator; import java.util.Set; public class SetDemo { public static void main(String[] args) { //Set是一个接口，不能直接实现化，所以要用它的实现类,要用多态的形式实例化 Set set=new HashSet<>(); // Set set1=new LinkedHashSet<>(); // Set set2=new TreeSet<>(); set.add(\"java\"); set.add(\"Hello\"); set.add(\"world\"); for(String s:set){ System.out.println(s); } System.out.println(\"----------------\"); Iterator iterator = set.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } } } /* java world Hello ---------------- java world Hello */ 2.3.1 哈希值 哈希值：是JDK根据对象的地址或者字符串或者数字计算出来的int类型的数值。需要明确的是哈希值并不是对象的地址值。 Object类中有一个方法可以获取对象的哈希值 package day11; import com.study.nanyu.day09.Student; public class HashDemo { public static void main(String[] args) { Student s1 = new Student(\"钉子君\", 39); //同一对象多次调用hashcode()方法，返回哈希值相同 System.out.println(s1.hashCode());//460141958 System.out.println(s1.hashCode());//460141958 System.out.println(\"-----------------------\"); Student s2 = new Student(\"钉子君\", 39); //不同对象调用hashcode()方法，返回哈希值不相同 //通过方法重写，可以实现不同对象的哈希值相同 System.out.println(s2.hashCode());//1163157884 System.out.println(\"-----------------------\"); System.out.println(\"hello\".hashCode());//99162322 System.out.println(\"-----------------------\"); System.out.println(\"world\".hashCode());//113318802 System.out.println(\"-----------------------\"); System.out.println(\"南雨\".hashCode()); System.out.println(\"博客\".hashCode()); } } /* 460141958 460141958 ----------------------- 1163157884 ----------------------- 99162322 ----------------------- 113318802 ----------------------- 700017 684936 */ 默认情况下不同对象的地址值不相同，计算出的哈希值也不同，但在实体类中可以通过重写hashCode()方法来实现让不同的对象哈希值也相同。 因为Java中所有类都默认继承自Object，hashCode()方法就是来自Object，只需要重写该方法，并return一个自己设置的哈希值即可。如果重写了hashCode()方法，每次实例化对象时，对象的哈希值就会变为hashCode()中return的值。 程序实例： package com.study.nanyu.day09; import java.util.Objects; public class Student { private String name; private int age; //省略get和set以及toString方法 @Override public int hashCode() { return 100; } } 总结： 哈希值是计算出来的，同一对象的地址值相同，根据对象的地址值计算出来的哈希值是相同的，所以同一对象的哈希值相同，默认情况下不同对象的地址值不同，所以计算出的哈希值也不同，但通过重写hashCode()可以改变对象的哈希值。 2.3.2 HashSet HashSet具有以下几个特点： 底层的数据结构是哈希表 无序：对集合的迭代顺序不做任何保证，即不能保证存储的和取出的元素一致 无法通过索引获取元素（不能使用普通for循环遍历数据），但可以通过迭代器和增强for循环遍历集合 顶层接口为Set集合，所以不包含重复的元素 程序实例： 观察HashSet集合添加数据时的顺序与最终遍历的数据，发现顺序并不一致，原因如下： HashSet底层基于哈希表，HashSet集合每添加一个数据，就会计算该数据的哈希值，从而计算这个数据应该在哈希表的什么位置。 比如，添加的第一个字符串“java”，计算出哈希值为10123，进一步计算出“java”应该在哈希表的第一个位置；第二个添加的字符串为“hello”，计算出哈希值为12723，进一步计算出“hello”应该在哈希表的第3个位置；第三个添加的字符串为“world”，计算出哈希值为93421，进一步计算出“world”应该在哈希表的第二个位置。 遍历输出时就会按照哈希表中的排列顺序依次输出java world Hello package com.study.nanyu.day11; import java.util.HashSet; import java.util.Iterator; import java.util.Set; public class SetDemo { public static void main(String[] args) { //Set是一个接口，不能直接实现化，所以要用它的实现类,要用多态的形式实例化 Set set=new HashSet(); set.add(\"java\"); set.add(\"Hello\"); set.add(\"world\"); for(String s:set){ System.out.println(s); } System.out.println(\"----------------\"); Iterator iterator = set.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } } } /* java world Hello ---------------- java world Hello */ 2.3.3 HashSet存储元素不重复原理 其实看源码就可以搞明白，HashSet底层基于哈希表，其保证存储元素不重复的原理其实与存储元素的哈希值有关。换句话说，HashSet之所以能保证存储元素不重复，其实是根据元素的哈希值进行判断的，源码刨析： 下面是使用add方法添加数据的代码， HashSet set=new HashSet(); set.add(\"java\"); set.add(\"Hello\"); set.add(\"world\"); add()方法：不妨以add()方法入手，查看其源码的实现，HashSet源码中add()方法的实现如下，add()方法中又调用了put()方法，put()方法的第一个参数e就是我们添加的元素。 public boolean add(E e) { return map.put(e, PRESENT)==null; } put()方法：下面进一步深入put()方法，put()方法中调用了putVal()方法，第一个参数调用了一个hash()方法来计算元素的哈希值，将元素的哈希值作为参数传递至putVal()方法中，第二个参数是添加的元素。 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } hash()方法其实就是调用hashCode()方法来计算元素的哈希值 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } putVal()方法：该方法是核心，里面主要做的工作就是根据元素的哈希值判断元素是否已存在，具体见代码中的注释。 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { /** **/ // 定义一个哈希表（哈希表是基于数组的） Node[] tab; Node p; int n, i; /** 判断哈希表是否被初始化，如果没有被初始化就初始化哈希表 **/ if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; /** 根据对象（元素）的哈希值计算对象的存储位置，如果该位置没元素，则直接存储，如果有元素，则做进一步判断。 **/ if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node e; K k; /** 如果该位置有元素，则比较要存的元素与之前元素的哈希值 如果哈希值不同，则继续详细执行，则继续向下执行，替换原数据，存储该元素 如果哈希值相同，，则调用对象的equal()方法比较key（即添加的元素与之前的元素） 如果返回false，则替换原始数据，存储新数据 如果返回true，则说明元素重复，不存储。 **/ if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size > threshold) resize(); afterNodeInsertion(evict); return null; } 流程图 要保证HashMap元素的唯一性，元素要重写hashCode()方法和equals()方法。比如字符串。 程序实例： 使用HashSet集合存储学生对象，要求只要对象中的成员变量都相等就认为是一个对象。 public class HashSetDemo { public static void main(String[] args) { HashSet hs=new HashSet<>(); Student student1=new Student(\"张三\",10); Student student2=new Student(\"李四\",13); Student student3=new Student(\"王五\",17); // student4与student1应被视为同一对象，只存储一个 Student student4=new Student(\"张三\",10); hs.add(student1); hs.add(student2); hs.add(student3); hs.add(student4); for (Student student:hs){ System.out.println(student); } System.out.println(\"-----------\"); Iterator iterator = hs.iterator(); while (iterator.hasNext()){ System.out.println(iterator.next()); } } } 要保证成员变量相等就认为是一个对象，需要在Student实体类中重写hashCode()与equals()方法。 package com.study.nanyu.day09; import java.util.Objects; public class Student { private String name; private int age; public Student() { } // 已省略get和set以及toString方法 @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age && Objects.equals(name, student.name); } } /** 学生集合{姓名:'王五', 年龄:17} 学生集合{姓名:'张三', 年龄:10} 学生集合{姓名:'李四', 年龄:13} ----------- 学生集合{姓名:'王五', 年龄:17} 学生集合{姓名:'张三', 年龄:10} 学生集合{姓名:'李四', 年龄:13} **/ 2.3.4 LinkedHashSet集合 奇技淫巧：对比之前学的LinkedList可知，LinkedList是基于链表的，而Linked翻译成中文也有链、链接的意思，因此我们不妨推断带有Linked单词的列表底层必然与链表有着很大的关系。本章的LinkedHashSet底层也是基于链表的，同时还是基于哈希表。 LinkedHashSet集合的特点： 底层由哈希表和链表实现的Set接口，具有可以预测的迭代次序 由链表保证元素有序，也就是说元素的存储和取出顺序是一致的（HashSet没有的特点） 由哈希表保证元素的唯一，也就是说没有重复的元素（LinkedList没有的特点） 注意：LinkedHashSet不是HashSet集合的子集，它与HashSet平级，LinkedHashSet同样实现了Set接口，只不过底层与HashSet不太一样而已。 程序实例： public class LinkedHashSetDemo { public static void main(String[] args) { //多态的方式将Set实例化 LinkedHashSet set=new LinkedHashSet<>(); set.add(\"hello\"); set.add(\"hello\"); set.add(\"world\"); set.add(\"world\"); set.add(\"你好\"); set.add(\"1\"); set.add(\"2\"); set.add(\"3\"); set.add(\"4\"); set.add(\"5\"); for (String s:set){ System.out.println(s); } } } /** hello world 你好 1 2 3 4 5 **/ 如上面程序演示所示，集合中不能有重复元素，并且输入数据与输出数据顺序一致 2.3.5 TreeSet集合 TreeSet并非直接实现Set接口，而是间接实现Set集合。 TreeSet集合具有以下特点： 元素有序：这里的顺序并不是指存储和取出的顺序，而是按照一定的规则进行排序，具体的排序方法取决于构造方法 TreeSet()：根据其元素的自然排序进行排序 TreeSet(Comparator comparator)：根据指定的比较器进行排序 没有带索引的方法，遍历需要用增强for循环或迭代器，不能用普通for循环。 间接实现Set接口，所以不包含重复元素 程序实例： public class TreeSetDemo { public static void main(String[] args) { TreeSet set=new TreeSet<>(); set.add(1); set.add(2); set.add(1); set.add(12); set.add(14); set.add(15); set.add(5); for (Integer i:set){ System.out.println(i); } } } /** 1 2 5 12 14 15 **/ 从上面代码的输出结果看，添加数据时是乱序的，然而输出的时候已经经过了排序，这其实是TreeSet在内部使用了自然排序的结果。 为什么TreeSet能实现对上面添加的数据的自然排序？ 集合中存储的是引用类型数据，如Stirng、Integer、Short等等，这些数据类型都实现了Comparable（下面会讲）接口，实现了Comparable接口中的compareTo方法，使得这些元素可以调用compareTo方法与其他元素作比较。 比如，上面输入了Integer类型的2，这里的2是对象不是一般数据类型的int，2会调用compareTo方法与1作比较。 总结： TreeSet间接继承了Set接口，因此还是不能有重复元素，另外与其他Set接口的实现类不同的是，TreeSet在内部实现了对添加的数据的排序，使用无参构造器的话，元素将会按照默认的自然排序法进行排序，但需要在元素对应的实体类中实现Comparable接口，使用有参构造器可以传递一个排序器，将元素按照该排序器进行排序。 2.3.6 自然排序Comparable Comparable是一个接口，接口中只有一个方法(T是泛型，可以是Stirng、Integer、对象等等) @Override public int compareTo(T t) { return 0; } 方法剖析： compareTo(T t) ：传递的参数t是需要比较的数据，比如传入5，则就是与5作比较，传入个对象Student就是与该对象作比较。 return：比较结果的返回值 0：表示两个数据对比相等 1(正数)：表示正序排序 -1(负数)：表示倒序排序 对于Integer、String等引用数据类型，其都实现了Comparable接口，重写了compareTo()方法，因此添加至TreeSet集合中后，元素都可以调用compareTo()方法，从而进行排序。 但是对于我们自己创建的对象该如何进行自然排序？ 只需要对象的实体类继承Comparable接口，并实现compareTo方法即可。 以一个例子来说明自然排序Comparable，要求：以年龄对输入的对象进行排序，如果年龄相同则比较姓名。 Student实体类 该类实现Comparable接口，并重写compareTo方法，在该方法中做对应要求的操作 public class Student implements Comparable { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } //get、set、toString方法已省略 @Override public int compareTo(Student s) { int num = this.age - s.age; //String实现了Comparable接口，并重写了compareTo方法，可以直接调用该方法与其他字符串比较 // 三元表达式，如果num=0，则说明年龄相等，则比较姓名，如果不相等，则继续比较年龄 int num1 = num == 0 ? this.name.compareTo(s.name) : num; return num1; } } 测试类： 添加数据，并遍历集合，查看排序结果 public class ComparableDemo { public static void main(String[] args) { TreeSet set=new TreeSet(); Student student1=new Student(\"zhangsan\",12); Student student2=new Student(\"lisi\",20); Student student3=new Student(\"wangwu\",23); Student student4=new Student(\"xiaoming\",9); Student student5=new Student(\"huangfeihong\",23); set.add(student1); set.add(student2); set.add(student3); set.add(student4); set.add(student5); for(Student s:set){ System.out.println(s); } } } /** 排序结果： 学生集合{姓名:'xiaoming', 年龄:9} 学生集合{姓名:'zhangsan', 年龄:12} 学生集合{姓名:'lisi', 年龄:20} 学生集合{姓名:'huangfeihong', 年龄:23} 学生集合{姓名:'wangwu', 年龄:23} **/ 结论： 用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序 自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法. 重写方法时，注意排序规则按照要求编写。 2.3.7 Comparator比较器 上面使用的是TreeSet的无参构造方法，所以使用的是默认的自然排序，我们可以使用TreeSet的带参构造器，传递一个比较器，使用该比较器对数据进行比较。 而这一章节的Comparator就是一个比较器。 以例子说明，要求如下： 存储学生对象并遍历，创建TreeSet集合使用带参构造方法 按照年龄大小，从小到大排序，年龄相同则按照姓名的首字母进行排序 package com.study.nanyu.day11; import com.study.nanyu.pojo.User; import java.util.Comparator; import java.util.TreeSet; public class TreeSetDemo { public static void main(String[] args) { // 有参构造的形式创建TreeSet集合 TreeSet set=new TreeSet<>(new Comparator() { @Override public int compare(User u1, User u2) { int num=u1.getAge()-u2.getAge(); int num1=num==0?u1.getName().compareTo(u2.getName()):num; return num1; } }); User u1=new User(\"张三\",12); User u2=new User(\"李四\",23); User u3=new User(\"王五\",16); User u4=new User(\"赵六\",38); User u5=new User(\"丁七\",38); set.add(u1); set.add(u2); set.add(u3); set.add(u4); set.add(u5); System.out.println(set); } } /* 输出结果： [User{name='张三', age=12}, User{name='王五', age=16}, User{name='李四', age=23}, User{name='丁七', age=38}, User{name='赵六', age=38}] */ 上面使用的是Treeset的有参构造创建的集合，其中参数是一个比较器，该比较器是匿名内部类的方式传递的。 结论： 用TreeSet集合存储自定义的对象，无参构造方法采用的是默认的排序方法对元素进行排序 用TreeSet集合存储自定义的对象，有参构造方法采用的是比较器排序对元素进行排序 比较器排序就是让集合接收Comparator的实现类对象，重写compare(T o1,T o2)方法 重写方法时一定要注意排序规则必须要按照要求的主要条件和次要条件来写 2.3.8 案例：成绩排序 需求：用TreeSet集合存储多个学生信息（姓名、语文成绩、数学成绩）并遍历该集合 要求：按照总分从高到低出现 实现思路： 定义学生类 创建Treeset集合，通过比较器排序 创建学生对象 将学生对象a至集合 遍历集合 package com.study.nanyu.day11; import com.study.nanyu.pojo.Student; import java.util.Comparator; import java.util.TreeSet; public class Example { public static void main(String[] args) { TreeSet set=new TreeSet<>(new Comparator() { @Override public int compare(Student s1, Student s2) { int grade1=s1.getChineseGrade()+s1.getMathGrade(); int grade2=s2.getChineseGrade()+s2.getMathGrade(); int num=grade2-grade1; int num1=num==0?s1.getUsername().compareTo(s2.getUsername()):num; return num1; } }); Student st1=new Student(\"张三\",78,89); Student st2=new Student(\"李四\",67,90); Student st3=new Student(\"王五\",12,67); Student st4=new Student(\"赵六\",89,78); set.add(st1); set.add(st2); set.add(st3); set.add(st4); for(Student student:set){ System.out.println(student); } } } /* 输出结果： Student{username='张三', chineseGrade=78, mathGrade=89} Student{username='赵六', chineseGrade=89, mathGrade=78} Student{username='李四', chineseGrade=67, mathGrade=90} Student{username='王五', chineseGrade=12, mathGrade=67} */ 2.3.9 案例：不重复随机数 需求：编写一个程序，获取10个1-20之间的随机数，要求随机数不能重复，并在控制台输出 思路： 创建Set集合对象 创建随机数对象 判断集合的长度是不是小于10 是：产生一个随机数，添加到集合 遍历集合 package com.study.nanyu.day11; import java.util.*; public class Example { public static void main(String[] args) { Set set=new HashSet(); Random random=new Random(); while (set.size() 2.4 泛型 2.4.1 泛型概述 泛型是JDK5中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型。它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 一提到参数，最熟悉的就是定义方法时有形参，然后调用方法时传递实参，那么参数化类型怎么理解？顾名思义，就是将类型由原来的具体的类型参数化，然后在使用/调用时传入具体的类型。这种参数类型可以用在类、方法、接口中，分别被称作泛型类、泛型方法、泛型接口。 简单来说就是先不指定具体的数据类型，比如一个方法的返回值先不指定，先用一个参数占着位，当以后调用该参数的时候再指定该方法的返回类型，这就可以使得一个方法能返回不同的数据类型，供不同的场景使用。 泛型定义格式： 指定一种类型的格式。这里的类型可以看成是形参 ：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参 将来具体调用时给定的类型可以看成是实参，并且实参的类型只能是引用数据类型 程序实例： 看下面两段代码，一段是不使用泛型的，另一段是使用泛型的： 不使用泛型 package com.study.nanyu.day11; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; public class TClass { public static void main(String[] args) { // 不使用泛型 Collection c = new ArrayList(); c.add(\"hello\"); c.add(\"world\"); c.add(100); // 不报错 Iterator iterator = c.iterator(); while (iterator.hasNext()) { String obj =(String) iterator.next(); System.out.println(obj); } } } 这段代码因为没指定泛型，所以默认向集合中添加的是Object元素。在向集合中添加元素时分别添加了String类型和int类型的数据，因为String和int都能自动向上转型为Object，遍历集合的时候把所有输出结果全部强制转换为String类型。 这段代码虽然放在编辑器中不会报错，但只要一运行就会发生错误，错误的原因在于我们在添加元素时添加了一个Integer（int）类型的数据，添加时发生了向上转型，转成了集合可以接受的Object，所以在这个阶段没有报错，但是当遍历集合数据时把所有数据强制转换为了String，就发生了错误，因为Integer不能强制转换为String（这种报错在编译阶段不会提示，但是运行起来就会提示，被称为运行时异常） 使用泛型 package com.study.nanyu.day11; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; public class TClass { public static void main(String[] args) { // 使用泛型 Collection collection=new ArrayList<>(); collection.add(\"hello\"); collection.add(\"world\"); collection.add(100); //报错 Iterator it = collection.iterator(); //Iterator迭代器也可以加泛型，之后就不需要强制转换 // Iterator it = collection.iterator(); while (it.hasNext()) { String str = (String) it.next(); System.out.println(str); } } } 这段代码直接发生了报错，因为使用了泛型，在创建集合时使用了泛型，即该集合只接受指定类型的数据，其他类型的数据传递过来直接报错，不能接收。这段代码中在创建集合时指定了泛型为Stirng，即告诉别人，该集合只接受String类型的元素（这种报错会在编译时直接提示出来告诉编写者必须要去处理才能执行程序，被称为编译时异常） 如果把Iterator迭代器也加上泛型，则就不需要下面的强制转换了 //Iterator迭代器也可以加泛型，之后就不需要强制转换 Iterator it = collection.iterator(); while (it.hasNext()) { String str = it.next(); System.out.println(str); } 泛型的好处： 将运行时期的问题提前到编译期间 避免了强制类型转换 2.4.2 泛型类 格式：修饰符 class 类名{} 范例：public class Student{}：此处的T可以随便写为任意标识，常见的如：T、E、K、V等形式的参数常用于表示泛型 如下，定义一个泛型类 package com.study.nanyu.pojo; public class Generic { private T t; public T getT() { return t; } public void setT(T t) { this.t = t; } } 测试代码如下： package com.study.nanyu.day12; import com.study.nanyu.pojo.Generic; import com.study.nanyu.pojo.Student; public class TDemo { public static void main(String[] args) { Generic g1 = new Generic(); g1.setT(\"南雨\"); Generic g2 = new Generic(); g2.setT(1); Generic g3=new Generic(); Student student=new Student(\"南雨\",100,98); g3.setT(student); System.out.println(g1.getT()); System.out.println(g2.getT()); System.out.println(g3.getT()); } } /* 输出结果： 南雨 1 Student{username='南雨', chineseGrade=100, mathGrade=98} */ 泛型类的好处： 原本几个类完成的功能，一个类就能完成 2.4.3 泛型方法 格式：修饰符 返回值 方法名(){} 范例：public void save(){} 具体实例如下： package com.study.nanyu.pojo; public class Generic { // 定义泛型方法 public void save(T t) { System.out.println(t); } /* public String saveString(String str){ System.out.println(str); return str; } public boolean savBoolean(boolean flag){ System.out.println(flag); return flag; } public int savInt(int num){ System.out.println(num); return num; } */ } 测试代码如下： package com.study.nanyu.day12; import com.study.nanyu.pojo.Generic; import com.study.nanyu.pojo.Student; public class TDemo { public static void main(String[] args) { Student student=new Student(\"南雨\",90,88); Generic g = new Generic(); g.save(\"你好\"); g.save(12); g.save(true); g.save(3.1415926); g.save(student); } } /* 输出结果： 你好 12 true 3.1415926 Student{username='南雨', chineseGrade=90, mathGrade=88} */ 分析上面代码，只创建了一个Generic对象，却可以往该对象内传不同数据类型的值，如果不使用泛型，那么需要下面这种方法 public String saveString(String str){ System.out.println(str); return str; } public boolean savBoolean(boolean flag){ System.out.println(flag); return flag; } public int savInt(int num){ System.out.println(num); return num; } ... 这样每增加一个返回类型的需求，就需要多写一个方法，这将会非常的麻烦，那么如过使用泛型方法会怎么样呢？只需要下面这一个方法即可，遵循循环利用的倡导。 public void save(T t) { System.out.println(t); } 泛型方法的好处： 与泛型类一样，可以大大减少冗余代码，原本几个方法完成的操作，一个方法就能完成 2.4.4 泛型接口 格式：修饰符 interface 接口名{} 范例：public interface show{} 程序实例： 泛型接口： package com.study.nanyu.pojo.inter; public interface Generic { void show(T t); } 接口实现： package com.study.nanyu.pojo; import com.study.nanyu.pojo.inter.Generic; public class GenericImpl implements Generic { @Override public void show(T t) { System.out.println(t); } } 测试类： package com.study.nanyu.day12; import com.study.nanyu.pojo.GenericImpl; public class TDemo { public static void main(String[] args) { GenericImpl g = new GenericImpl(); g.show(\"张三\"); g.show(\"李四\"); g.show(\"王五\"); g.show(\"赵六\"); } } /* 输出结果： 张三 李四 王五 赵六 */ 如果一个接口是泛型接口，那么它的实现类也是泛型，被称为泛型类。 对于泛型接口的理解可以联想List集合，为什么List集合可以存入不同的数据类型？原因就是List是泛型接口，其实现类是泛型方法。 List集合是一个接口，该接口是一个泛型接口，其实现类ArrayList、LinkedList等都是泛型类 下面是List接口类的框架 //泛型接口List public interface List extends Collection {} List接口的实现类是泛型类，如下ArrayList类的框架 public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable{} 2.4.5 类型通配符 为了表示各种泛型List的父类，可以使用类型通配符 类型通配符： List：表示元素类型未知的List，它的元素可以匹配到任何的类型 这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中。 类型通配符的上限： 如果我们不希望List是任何泛型List的父类，只希望它代表某一类泛型的父类，可以使用类型通配符的上限。 类型通配符上限： List：Number是最大的类，类型必须是Number或者其子类型 类型通配符的下限： 除了可以指定类型通配符的上限，还可以指定类型通配符的下限 类型通配符下限： List：Number是最小的类，类型必须是Number或者其父类型 程序实例： package com.study.nanyu.day12; import com.study.nanyu.pojo.GenericImpl; import java.util.ArrayList; import java.util.List; public class TDemo { public static void main(String[] args) { // 类型通配符 List list1=new ArrayList(); List list2=new ArrayList(); List list3=new ArrayList(); List list4=new ArrayList(); // 类型通配符上限 Number就是最大的，只能只能找Number或是Number的字类 // List list5=new ArrayList(); 会报错 List list6=new ArrayList(); List list7=new ArrayList(); // 类型通配符的下限 Number就是最小的，只能找Number或Number的父类 // List list8=new ArrayList(); 报错 List list9=new ArrayList(); List list10=new ArrayList(); } } 2.4.6 可变参数 可变参数即参数的个数可变，不固定，作为函数的形参出现时，该函数的参数个数就是可变的了。 格式：修饰符 返回值类型 方法名(数据类型...变量名) 范例：public static int sum(int..a ){} 为什么需要可变参数？ 加入不使用可变参数，看下面代码： public int add(int a, int b, int c) { return a + b + c; } public int add(int a, int b, int c, int d) { return a + b + c + d; } public int add(int a, int b, int c, int d, int e) { return a + b + c + d + e; } public int add(int a, int b, int c, int d, int e, int f) { return a + b + c + d + e + f; } public int add(int a, int b, int c, int d, int e, int f, int g) { return a + b + c + d + e + f + g; } 如果要完成上面的需求，需要写很多代码，如果以后还要传递更多的参数进行累加，那么将会更加麻烦，所以此时便需要用到可变参数。 使用可变参数解决上面需求就非常简单了： public int addNum(int... a) { int num = 0; for (int i = 0; i 可变参数的方法使用起来也非常简单。 注意：可变参数传参数时传递的是一组数据，这些数据以数组的形式传递到方法中，无论传递多少个参数，都会封装到一个数组中，然后将参数以数组的形式传递到方法种。同时需要注意，参数的传递整体可分为下面两种 addNum(int... a)：这种方法传递参数时，无论传递多少个参数都会封装到一个数组中。 addNum1(int b,int... a)：传递时第一个参数单独传递，后面的参数以数组的形式传递 public class TDemo { public static void main(String[] args) { GenericImpl g = new GenericImpl(); g.addNum(12, 12, 23, 45, 67, 8); g.addNum(45, 9, 45, 76); g.addNum1(45, 9, 45, 76); g.addNum1(12, 12, 23, 45, 67, 8); } } /* 结果输出： 167 175 175 167 */ 2.4.7 可变参数的使用 可变参数的使用还看Java为我们提供的样例： 样例一：返回由指定数组支持的固定大小的列表 public class TDemo { public static void main(String[] args) { List list= Arrays.asList(\"hello\",\"world\",\"java\"); for (String str:list){ System.out.println(str); } } } /* 输出结果： hello world java */ 2.5 Map集合 2.5.1 Map集合概述 Map集合是一个接口，与List、Set一样，不能被实例化，可以被实现后通过实现类进行实例化或通过多态的形式实例化。 Map集合存储的数据是键值对，其中键不能重复，相当于id（底层通过哈希进行判断），值允许重复，值的类型可以是普通数据类型也可以是引用数据类型。 总结Map集合： Interface Map K：键的类型；V：值的类型 Map集合是将键映射到值上的对象；不能包含重复的键；每个键可以映射到最多一个值上 例子：、、 Map接口最常用的实现类是HashMap，这里创建Map对象的方式有两种，一种是以多态的形式创建，另一种直接创建其实现类HashMap的实现类。 Map集合添加元素是通过put()方法实现的，当第一次put某个键值对时是往集合种添加元素，当添加的某个键值对的键在集合中已经存在，则会直接替换掉该键值对对应的原来的值。 public class TDemo { public static void main(String[] args) { Map map=new HashMap<>(); map.put(\"10001\",\"张三\"); map.put(\"10002\",\"李四\"); map.put(\"10003\",\"王五\"); map.put(\"10004\",\"赵六\"); map.put(\"10001\",\"南雨\"); System.out.println(map); } } /* 结果输出 {10002=李四, 10001=南雨, 10004=赵六, 10003=王五} */ 2.5.2 Map集合的基本功能 方法名 说明 V put(K key,V value) 添加元素 V remove(Object key) 按键删除键值对元素 void clear() 清空集合 boolean containsKey(Object key) 判断集合中是否包含指定键 boolean containsValue(Object value) 判断集合中是否包含指定值 boolean isEmpty() 判断集合是否为空 int size() 获取集合长度，即集合中键值对的个数 程序实例： package com.study.nanyu.day12; import java.util.Arrays; import java.util.HashMap; import java.util.List; import java.util.Map; public class TDemo { public static void main(String[] args) { Map map = new HashMap<>(); // put方法 map.put(\"1001\",\"张三\"); map.put(\"1002\",\"李四\"); map.put(\"1003\",\"王五\"); System.out.println(map); // remove方法 map.remove(\"1001\"); System.out.println(map); // containsKey System.out.println(map.containsKey(\"1001\")); System.out.println(map.containsKey(\"1002\")); // containsValue System.out.println(map.containsValue(\"李四\")); System.out.println(map.containsValue(\"南雨\")); // size方法 System.out.println(map.size()); // isEmpty方法 System.out.println(map.isEmpty()); // clear方法 map.clear(); System.out.println(map.isEmpty()); } } /* 结果输出： {1003=王五, 1002=李四, 1001=张三} {1003=王五, 1002=李四} false true true false 2 false true */ 2.5.3 Map集合的获取功能 方法 说明 V get(Object key) 根据键获得值 Set keySet() 获取所有键的集合 Collection values() 获取所有值的集合 Set> entrySet() 获取所有键值对对象的集合 程序实例： package com.study.nanyu.day12; import java.util.*; public class TDemo { public static void main(String[] args) { Map map = new HashMap<>(); // put方法 map.put(\"1001\",\"张三\"); map.put(\"1002\",\"李四\"); map.put(\"1003\",\"王五\"); // get方法 System.out.println(map.get(\"1001\")); // keySet方法：获取Map集合中所有的键，并存储到Set集合中 Set strings = map.keySet(); for(String str:strings){ System.out.println(str); } // values方法：获取Map结合中所有的值，并存储到Collection结合中 Collection values = map.values(); for (String str:values){ System.out.println(str); } // entrySet方法：获取到Map集合中所有的键值对，并将其存入Set集合中,形式如下： // {,,} Set> entries = map.entrySet(); for (Map.Entry entry:entries){ System.out.println(entry); } } } /* 结果输出： 张三 1003 1002 1001 王五 李四 张三 1003=王五 1002=李四 1001=张三 */ 注意： 尤其关注entrySet方法，它获取的是Map集合中全部的键值对，让后将键值对转换为entry形式（key=value）存入到Set集合中 其实它也是遍历Map集合的一种方法： public class TDemo { public static void main(String[] args) { Map map = new HashMap<>(); // put方法 map.put(\"1001\",\"张三\"); map.put(\"1002\",\"李四\"); map.put(\"1003\",\"王五\"); // entrySet方法：获取到Map集合中所有的键值对，并将其存入Set集合中,形式如下： // {,,} Set> entries = map.entrySet(); for (Map.Entry entry:entries){ String key= entry.getKey(); String value=entry.getValue(); System.out.println(key+\":\"+value); } } } /* 输出结果： 1003:王五 1002:李四 1001:张三 */ 2.5.4 HashMap集合练习 需求一： 使用Map集合存储学生对象，要求键是字符串，值是学生对象。最后对集合进行遍历 解决1： package com.study.nanyu.day12; import com.study.nanyu.pojo.Student; import java.util.*; public class TDemo { public static void main(String[] args) { Map map = new HashMap<>(); Student student1=new Student(\"张三\",12,78); Student student2=new Student(\"李四\",90,98); Student student3=new Student(\"王五\",67,80); map.put(\"1001\",student1); map.put(\"1002\",student2); map.put(\"1003\",student3); Set> entries = map.entrySet(); for(Map.Entry entry:entries){ String key=entry.getKey(); Student value=entry.getValue(); System.out.println(\"学号：\"+key+\"\\n\"+\"学生信息：\"+value); } } } /* 输出结果： 学号：1003 学生信息：Student{username='王五', chineseGrade=67, mathGrade=80} 学号：1002 学生信息：Student{username='李四', chineseGrade=90, mathGrade=98} 学号：1001 学生信息：Student{username='张三', chineseGrade=12, mathGrade=78} */ 需求二： ArrayList集合存储HashMap元素并遍历。创建一个ArrayList集合，存储三个元素，每一个元素都是HashMap，每一个HashMap的键和值都是String，并遍历。 package com.study.nanyu.day12; import com.study.nanyu.pojo.Student; import java.util.*; public class TDemo { public static void main(String[] args) { ArrayList> list=new ArrayList<>(); Map map1 = new HashMap<>(); map1.put(\"1001\",\"张三\"); map1.put(\"1002\",\"李四\"); Map map2 = new HashMap<>(); map2.put(\"1003\",\"王五\"); map2.put(\"1004\",\"赵六\"); Map map3 = new HashMap<>(); map3.put(\"1005\",\"丁二\"); map3.put(\"1006\",\"周一\"); list.add(map1); list.add(map2); list.add(map3); // 遍历方式一 // ListIterator> mapListIterator = list.listIterator(); // 遍历方式二 // Iterator> iterator = list.iterator(); // 遍历方式三 for(Map map:list){ Set> entries = map.entrySet(); for(Map.Entry entry:entries){ String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+\":\"+value); } } } } 回顾以下ArrayList集合的遍历，ArrayList集合遍历的迭代器有两种，一种是List集合通用的迭代器Iterator，另一种是ListIterator，这两种迭代器有什么区别？ ListIterator迭代器可以正向遍历和逆向遍历，而Iterator只能正向遍历。 需求三： HashMap集合存储ArrList集合。 package com.study.nanyu.day12; import com.study.nanyu.pojo.Student; import java.util.*; public class TDemo { public static void main(String[] args) { HashMap> map = new HashMap<>(); ArrayList list1 = new ArrayList<>(); list1.add(\"唐僧\"); list1.add(\"孙悟空\"); map.put(\"西游记\", list1); ArrayList list2 = new ArrayList<>(); list2.add(\"鲁智深\"); list2.add(\"武松\"); map.put(\"水浒传\", list2); ArrayList list3 = new ArrayList<>(); list3.add(\"曹操\"); list3.add(\"诸葛亮\"); map.put(\"三国演义\", list3); Set>> entries = map.entrySet(); for (Map.Entry> entry:entries){ String key = entry.getKey(); ArrayList value = entry.getValue(); for(String v:value){ System.out.println(key+\":\"+v); } } } } /* 输出结果： 水浒传:鲁智深 水浒传:武松 三国演义:曹操 三国演义:诸葛亮 西游记:唐僧 西游记:孙悟空 */ 需求四： 通过键盘录入一段字符串，统计字符串中每个字符出现的次数 package com.study.nanyu.day12; import com.study.nanyu.pojo.Student; import java.util.*; public class TDemo { public static void main(String[] args) { Scanner sc=new Scanner(System.in); System.out.println(\"请输入资格字符串:\"); String line = sc.nextLine(); HashMap map = new HashMap<>(); // 向hashMap集合中添加元素 for (int i=0;i> entries = map.entrySet(); StringBuilder sb=new StringBuilder(); for (Map.Entry entry:entries){ Character key = entry.getKey(); Integer value = entry.getValue(); sb.append(key).append(\":\").append(value).append(\"\\n\"); } String s = sb.toString(); System.out.println(s); } } /* 结果输出： 请输入资格字符串: qwesdfsfasfda q:1 a:2 s:3 d:2 e:1 f:3 w:1 */ 此时如果向对这些字符进行排序，该如何操作？ 在学习Set集合时我们学到了TreeSet集合，回顾一下TreeSet集合的特点： 间接实现Set接口，不包含重复元素 没有带索引的方法，不能通过索引获取元素，遍历需要用增强for或者迭代器 元素有序，如果使用TreeSet的无参构造器创建集合对象，则默认集合内部的元素使用自然排序进行排序，如果使用TreeSet的有参构造器创建集合对象，则需要传递一个比较器，集合内的元素会按照比较器的规则进行排序。 对TreeSet集合有了一定的了解，那么我们同样可以使用Treemap集合对Map集合内的元素进行排序（按照Key进行排序），如下，其他代码不变，只需要改一行即可。 TreeMap map = new TreeMap<>();、 /* 输出结果： asdafagf a:3 d:1 f:2 g:1 s:1 */ 2.6 综合练习 2.6.1 模拟斗地主 需求： 通过程序实现斗地主的洗牌，发牌和看牌操作。 实现思路： 创建一个牌盒，即定义一个集合对象，用ArrayList集合实现、 在牌盒里装牌 洗牌，将牌的顺序打乱，使用Collections的shuffle()方法 发牌，遍历集合，为三个玩家发牌 package com.study.nanyu.day12; import java.util.ArrayList; import java.util.Collections; public class PlayPoke { // 斗地主发牌 public static void main(String[] args) { ArrayList poke = new ArrayList<>(); // 定义花色与牌号 String[] colors = {\"♥\", \"♠\", \"♦\", \"♣\"}; String[] nums = {\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\"}; // 组合花色与牌号存入列表 for (String color : colors) { for (String num : nums) { String p = color + num; poke.add(p); } } // 加入大小王 poke.add(\"大王\"); poke.add(\"小王\"); // 洗牌 Collections.shuffle(poke); //发牌 ArrayList play1 = new ArrayList<>(); ArrayList play2 = new ArrayList<>(); ArrayList play3 = new ArrayList<>(); ArrayList dp = new ArrayList<>(); for (int i = 0; i = poke.size() - 3) { dp.add(s); } else if (i % 3 == 0) { play1.add(s); } else if (i % 3 == 1) { play2.add(s); } else if (i % 3 == 2) { play3.add(s); } } System.out.println(play1); System.out.println(play2); System.out.println(play3); System.out.println(dp); } } /* 输出结果： [♣7, ♥7, ♠5, ♣4, ♣9, ♣Q, ♣K, ♥3, ♠6, ♣6, ♦K, ♦9, ♦3, ♠A, ♠10, ♦A, ♣8] [♥A, ♣5, ♠4, ♦8, ♠J, ♠Q, ♥9, 大王, ♣A, ♥2, ♦5, ♣10, ♦Q, ♠2, ♦10, ♥8, ♦4] [♥K, ♥10, ♦J, ♠3, ♥5, ♥Q, ♣2, ♠9, ♥J, ♣J, ♠7, ♣3, ♦6, ♥6, 小王, ♦7, ♦2] [♠8, ♥4, ♠K] */ 2.6.2 模拟斗地主进阶 需求： 对上面发到玩家手里的牌进行排序 思路： 创建HashMap，键是编号，值是牌 创建ArrayList，存储编号 创建花色数组和点数数组 从0开始往HashMap里面存储编号，并存储对应的牌。同时往ArrayList中存储编号 洗牌，洗的是编号，用Collection的shuffle打乱存储编号的ArrayList列表 发牌，发的也是编号，为保证编号是排序的，创建TreeSet集合接收 调用看牌方法 package com.study.nanyu.day12; import java.util.*; public class PlayPoke1 { public static void main(String[] args) { HashMap pokes = new HashMap<>(); ArrayList indexs = new ArrayList<>(); // 定义花色与牌号 String[] colors = {\"♥\", \"♠\", \"♦\", \"♣\"}; String[] nums = {\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\"}; int index = 0; // 组合花色与牌号存入列表 for (String color : colors) { for (String num : nums) { String poke = color + num; pokes.put(index, poke); indexs.add(index); index++; } } pokes.put(index, \"大王\"); indexs.add(index); index++; pokes.put(index, \"小王\"); indexs.add(index); // 洗牌，只洗索引即可 Collections.shuffle(indexs); // 发牌 TreeSet play1 = new TreeSet<>(); TreeSet play2 = new TreeSet<>(); TreeSet play3 = new TreeSet<>(); TreeSet dp = new TreeSet<>(); for (int i = 0; i = indexs.size() - 3) { dp.add(num); } else if (i % 3 == 0) { play1.add(num); } else if (i % 3 == 1) { play2.add(num); } else if (i % 3 == 2) { play3.add(num); } } lookPoke(\"play1\",play1,pokes); lookPoke(\"play2\",play2,pokes); lookPoke(\"play3\",play3,pokes); lookPoke(\"dp\",dp,pokes); } public static void lookPoke(String name,TreeSet treeSet,HashMap map){ System.out.println(\"角色：\"+name); for(Integer tr:treeSet){ String poke = map.get(tr); System.out.print(poke+\" \"); } System.out.println(); } } /* 输出结果： 角色：play1 ♥6 ♥9 ♥10 ♥A ♠2 ♠4 ♠6 ♠9 ♠K ♦2 ♦10 ♦J ♣6 ♣8 ♣J ♣K 小王 角色：play2 ♥2 ♥4 ♥5 ♥8 ♥J ♥Q ♥K ♠7 ♦3 ♦4 ♦6 ♦7 ♦9 ♦K ♣2 ♣7 ♣Q 角色：play3 ♥3 ♠3 ♠5 ♠8 ♠10 ♠J ♠A ♦5 ♦8 ♦Q ♣3 ♣4 ♣5 ♣9 ♣10 ♣A 大王 角色：dp ♥7 ♠Q ♦A */ 上面实现的原理： 将所有扑克牌放入HashMap集合中，键为0-54的索引，值为扑克牌（意为牌盒） 通过ArrayList存储索引，并使用shuffle方法打乱索引（意为洗牌） 将索引发放到每个用户的TreeSet列表中（意为发牌并排序） 根据每个用户TreeSet中的索引获取HashMap中的扑克牌 "},"1-Java/7-Java学习笔记七-File类及IO流.html":{"url":"1-Java/7-Java学习笔记七-File类及IO流.html","title":"7. Java学习笔记七 File类及IO流","keywords":"","body":""},"1-Java/8-Java学习笔记八-多线程及网络.html":{"url":"1-Java/8-Java学习笔记八-多线程及网络.html","title":"8. Java学习笔记八 多线程及网络","keywords":"","body":"1. 多线程 1.1 进程与线程 进程：进程是程序的一次执行过程，进程是系统进行资源分配和调用你的基本单位，每一个进程都有自己的内存空间和系统资源 线程：线程是进程中的单个顺序控制流，是一条执行路径，一个进程中可以有多个线程。一个进程中的所有线程共享进程的存储空间和系统资源，线程是CPU调度的最小单位。线程分为单线程与多线程。 单线程：一个进程如果只有一条执行路径，则称其为单线程程序。比如炒菜这个进程，需要先放油，等油热了再放菜，不可能同时放油又放菜，这就是一个线程。 多线程：一个进程如果有多条执行路径，则称为多线程程序。比如我们经常玩的扫雷程序，在玩游戏的过程中会自动计时，计时不会随着你的操作停止，玩游戏和计时是两个同时进行的步骤，这就是两个线程。 1.2 实现多线程方式一 进程是应用程序的一次执行过程，程序是静态的，进程是动态的。Java虚拟机允许应用程序执行多个线程，即允许一个进程中包含多个线程。 要想新开辟一个线程，有两种方法： 让自定义的线程类继承自Thread类（Thread即为线程类，Java提供的，无需导包即可使用），这个自定义的线程类中需要重写Thread类中的run方法，run方法中是该线程具体要执行的操作代码。 自定义Runnable类，并实现Runnable接口，重写其中的run方法，run方法种编写该线程需要执行的程序代码，创建自定义的Runnable类的对象，通过Thread类的有参构造创建线程（该有参构造的参数就是自定义的Runnable对象） 这一小节我们介绍第一种创建线程的方法。总结一下该方法实现多线程的步骤如下： 定义一个自定义线程类MyThread，让其继承自Thread 在MyThread类中重写run()方法 创建MyThread的对象 启动线程 程序实例： 定义MyThread并集成Thread package com.study.nanyu.day12; public class MyThread extends Thread { @Override public void run() { for (int i = 0; i 创建测试类 package com.study.nanyu.day12; public class ThreadDemo { public static void main(String[] args) { // 创建第一个线程 MyThread t1=new MyThread(); // 创建第二个线程 MyThread t2=new MyThread(); // 创建第三个线程 MyThread t3=new MyThread(); // t1.run(); t1.start(); t2.start(); t3.start(); } } 创建一个自定义类的MyThread类的对象就相当于创建了一个线程。启动线程使用的方法是线程对象调用start()方法。 注意：启动线程调用的不是run方法，如果使用对象调用run()方法，那只是普通的方法调用并不是启动线程。启动线程的方法是Thread提供的start()方法。 问题1：为什么要重写run方法？ 因为run()方法是用来封装被线程执行的代码 问题2：run()方法和start()方法的区别？ run()：封装线程执行的代码，直接调用的话相当于普通方法的调用 start()：启动线程，然后由JVM调用此线程run()方法 1.3 设置和获取线程名称 Thread类提供了设置和获取线程名称的方法： 方法 说明 void setName(String name) 将线程名称更改为等于参数name String getName() 返回线程的名称 Thread(String name) 通过Thread提供的有参构造设置线程名 其实看上面的方法不难发现，其实name就是Thread类的一个私有属性，并且Thread为这个私有属性提供了get、set方法以便设置和获取这个属性的值。 1.3.1 获取线程名 因为MyThread直接集成自Thread，所以Thread类中的所有非private和非final修饰的方法都可以直接使用。 package com.study.nanyu.day12; public class MyThread extends Thread { @Override public void run() { for (int i = 0; i 测试类： package com.study.nanyu.day12; public class ThreadDemo { public static void main(String[] args) { // 创建第一个线程 MyThread t1=new MyThread(); // 创建第二个线程 MyThread t2=new MyThread(); // 创建第三个线程 MyThread t3=new MyThread(); t1.start(); t2.start(); t3.start(); } } /* 输出结果： Thread-0:0 Thread-2:0 Thread-1:0 Thread-2:1 Thread-0:1 Thread-2:2 Thread-1:1 Thread-1:2 Thread-0:2 */ 思考：为什么直接获取线程名，结果会是Thread-num？ 这个需要分析其源码： 首先我们是通过无参构造器创建的线程对象，同时我们没有使用setName方法为线程名name属性赋值，所以我们并没有为线程中的属性赋值，也就是说，Thread线程中的name此时使用的是默认的线程名，是Thread自动生成的线程名。 既然我们是通过无参构造器创建的MyThread对象，则相当于调用了Thread无参构造器，要想了解Thread是如何为新线程提供默认的线程名的，还需要了解这个用来创建对象的Thread无参构造器。 如下，Thread()源码如下： public Thread() { init(null, null, \"Thread-\" + nextThreadNum(), 0); } // 第一个init方法 private void init(ThreadGroup g, Runnable target, String name, long stackSize) { init(g, target, name, stackSize, null, true); } // 第二个init方法 private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) { // 核心代码 if (name == null) { throw new NullPointerException(\"name cannot be null\"); } this.name = name; // 此处省略若干行代码 } // nextThreadNum方法 private static int threadInitNumber; private static synchronized int nextThreadNum() { return threadInitNumber++; } nextThreadNum方法是为线程名设置序号的，开始时定义一个静态的变量threadInitNumber，它的值默认为0，如果有新的线程则会先返回threadInitNumber的值，然后再把threadInitNumber加1，依次为新线程设置序号。 为name的赋值经过了两个init方法，最终在第二个init方法中先判断了name是否为空，不为空的情况下使用this.name=name将name的值赋给name属性。 这就解释了，如果我们没有使用有参构造或setName()方法为线程设置名称，则当我们获取线程名称时，Thread的无参构造会自动为我们创建一个默认的名称。 1.3.2 设置线程名 设置线程名有两种方式： 方法 说明 String setName() 通过set方法设置线程名 Thread(String name) 通过Thread提供的有参构造器设置线程名 代码演示： package com.study.nanyu.day12; public class MyThread extends Thread { @Override public void run() { for (int i = 0; i 测试类： package com.study.nanyu.day12; public class ThreadDemo { public static void main(String[] args) { // 创建第一个线程 MyThread t1=new MyThread(); t1.setName(\"张飞\"); // 创建第二个线程 MyThread t2=new MyThread(); t2.setName(\"关羽\"); // 创建第三个线程 MyThread t3=new MyThread(); t3.setName(\"刘备\"); // t1.run(); t1.start(); t2.start(); t3.start(); } } /* 结果输出： 刘备:0 张飞:0 关羽:0 张飞:1 刘备:1 张飞:2 关羽:1 刘备:2 关羽:2 */ 第二种方法是通过有参构造形式设置线程名： 自定义线程类MyThread中需要定义一个有参构造 package com.study.nanyu.day12; public class MyThread extends Thread { public MyThread() { } public MyThread(String name){ super(name); } @Override public void run() { for (int i = 0; i 测试类： package com.study.nanyu.day12; public class ThreadDemo { public static void main(String[] args) { MyThread t1=new MyThread(\"猪八戒\"); MyThread t2=new MyThread(\"孙悟空\"); MyThread t3=new MyThread(\"沙悟净\"); t1.start(); t2.start(); t3.start(); } } /* 结果输出： 猪八戒:0 沙悟净:0 孙悟空:0 沙悟净:1 猪八戒:1 沙悟净:2 孙悟空:1 孙悟空:2 猪八戒:2 */ Thread提供的有参构造源码如下： // 有参构造 public Thread(String name) { init(null, null, name, 0); } // 第一个init方法 private void init(ThreadGroup g, Runnable target, String name, long stackSize) { init(g, target, name, stackSize, null, true); } // 第二个init方法 private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) { // 核心代码 if (name == null) { throw new NullPointerException(\"name cannot be null\"); } this.name = name; // 省略若干行代码 } 该方法与通过无参构造设置默认的线程名思路完全一样。 1.3.3 currentThread方法 如何获取当前正在执行的线程对象的引用呢？ Thread提供了currentThread方法来获取当前正在执行的线程的对象的引用，该方法是静态的，可以通过Thread直接调用。 以每个类中的入口方法main为例介绍一下currentThread的使用方法： package com.study.nanyu.day12; public class ThreadDemo { public static void main(String[] args) { // 获取main方法所属线程的线程对象的引用 Thread thread = Thread.currentThread(); // 获取main方法的所属线程的线程名 String name = thread.getName(); // 设置main方法的所属线程的线程名 // thread.setName(\"good\"); System.out.println(name); } } /* 输出结果： main */ 1.4 线程优先级 线程调度： 分时调度：所有线程轮流使用CPU，平均分配每个线程占用CPU的时间片 抢占式调度：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个。优先级较高的线程，获取CPU时间片相对较多 Java使用的是抢占式调度模型 假如一个计算机只有一个CPU，那么CPU在某个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权才可以执行指令。所以说多线程程序的执行有随机性。 Thread类中设置和获取线程优先级的方法如下： 方法 说明 public final int getPriority 返回此线程的优先级 public final void setPriority(int newPriority) 更改此线程的优先级 如果我们没有为线程设置优先级，那这个线程是否有优先级，有的话是多少？ package com.study.nanyu.day12; public class ThreadDemo { public static void main(String[] args) { MyThread t1=new MyThread(\"武松\"); MyThread t2=new MyThread(\"林冲\"); MyThread t3=new MyThread(\"宋江\"); System.out.println(t1.getPriority()); System.out.println(t2.getPriority()); System.out.println(t3.getPriority()); } } /* 输出结果： 5 5 5 */ 通过上面代码我们发现，如果没有手动为线程设置优先级，那么该线程优先级默认为5。 下面我们手动为这些线程设置优先级 package com.study.nanyu.day12; public class ThreadDemo { public static void main(String[] args) { MyThread t1 = new MyThread(\"武松\"); MyThread t2 = new MyThread(\"林冲\"); MyThread t3 = new MyThread(\"宋江\"); // 为线程设置优先级 t1.setPriority(8); t2.setPriority(2); t3.setPriority(5); System.out.println(t1.getPriority()); System.out.println(t2.getPriority()); System.out.println(t3.getPriority()); System.out.println(\"-------------\"); t1.start(); t2.start(); t3.start(); } } /* 输出结果： 8 2 5 ------------- 宋江:0 林冲:0 武松:0 武松:1 武松:2 林冲:1 宋江:1 宋江:2 林冲:2 */ 注意： 线程的优先级只能设置在1-10之间，否则会出错，优先级越高说明该线程抢占CPU的几率越大。优先级高的线程 并不一定先执行完毕，优先级高只能说明该线程抢占CPU的概率比较大，并不能保证该线程一定先执行完毕。 1.5 线程控制 方法 说明 static void sleep(long millis) 使当前正在执行的线程停留（暂停执行）指定的毫秒数 void join() 等待这个线程死亡，这个线程没死亡之前不会执行其他线程 void setDaemon(boolean on) 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 1.5.1 sleep()方法 自定义的MyThread线程类： 使用sleep方法时每输出一个数字就会使该线程睡眠1s package com.study.nanyu.day12; public class MyThread extends Thread { public MyThread() { } public MyThread(String name){ super(name); } @Override public void run() { for (int i = 0; i 测试类： package com.study.nanyu.day12; public class ThreadDemo { public static void main(String[] args) { MyThread t1 = new MyThread(\"武松\"); MyThread t2 = new MyThread(\"林冲\"); MyThread t3 = new MyThread(\"宋江\"); t1.start(); t2.start(); t3.start(); } } /* 输出结果： 林冲:0 武松:0 宋江:0 宋江:1 林冲:1 武松:1 宋江:2 武松:2 林冲:2 */ 第一个抢到CPU的线程输出一个数字，进入睡眠状态，然后剩下两个开始强CPU，第二个抢到CPU的线程输出一个数字然后进入睡眠状态；此时第一个睡眠的线程可能已经睡眠结束（也可能没结束），会和第三个线程抢CPU。 1.5.2 join()方法 如果一个线程调用了join()方法，则这个线程执行完毕之后其他线程才能执行，如下程序实例： package com.study.nanyu.day12; public class ThreadDemo { public static void main(String[] args) { MyThread t1 = new MyThread(\"武松\"); MyThread t2 = new MyThread(\"林冲\"); MyThread t3 = new MyThread(\"宋江\"); try { t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } t1.start(); t2.start(); t3.start(); } } /* 输出结果： 林冲:0 林冲:1 林冲:2 宋江:0 武松:0 武松:1 宋江:1 武松:2 宋江:2 */ 1.5.3 setDaemon()方法 当主线程结束，Java虚拟机中只剩下守护线程时，Java虚拟机会退出。 下面以关羽、张飞为守护线程、刘备为主线程为例： 自定义的MyThread： package com.study.nanyu.day12; public class MyThread extends Thread { public MyThread() { } public MyThread(String name){ super(name); } @Override public void run() { for (int i = 0; i 测试类： package com.study.nanyu.day12; public class ThreadDemo { public static void main(String[] args) { MyThread t1 = new MyThread(\"关羽\"); MyThread t2 = new MyThread(\"张飞\"); // 设置main方法为主线程 Thread thread = Thread.currentThread(); thread.setName(\"刘备\"); t1.setDaemon(true); t2.setDaemon(true); t1.start(); t2.start(); // 主线程中数字的遍历 for(int i=0;i 从输出结果来看，关羽和张飞都没有输出到99，只有刘备输出完毕，原因就是刘备这个线程是主线程，当主线程执行结束后，剩下的关羽和张飞两个线程都是守护线程，当Java虚拟机发现剩下的线程都是守护线程时，虚拟机会关闭，所以线程将不再执行。 为什么刘备线程执行完毕之后关羽和张飞线程没有立即被停止？ 可以理解为缓冲，CPU执行的很迅速，在Java虚拟机关闭的那一段时间CPU还在执行线程。 1.6 线程的生命周期 线程的生命周期如下： 文字描述： 首先创建一个线程，并调用start()方法启动线程，此时处于新建态 此时的线程有执行的资格，但没有执行的权力（此时线程获得了出CPU以外的所有资源），此时处于就绪态 线程抢到CPU，获得执行的权力，执行该线程，此时处于运行态 其他高优先级线程抢走CPU，此时线程处于就绪状态 如果线程运行的过程中调用sleep()方法或其他阻塞式方法，线程会变为阻塞态，该状态下线程没有执行的资格，也没有执行的权力。 当处于阻塞态下的某线程sleep()方法时间到或调用了其他结束阻塞的方法，线程会进入就绪态，抢夺CPU 当处于运行态的某线程自然执行结束，或调用了stop()方法，会转变为死亡态，变成垃圾 1.7 实现多线程方式二 这一小节记录实现多线程的第二种方式，总结一下该方法实现多线程的步骤、 自定义MyRunnable类，并实现Runnable接口 重写run()方法，在run()中编写线程需要执行的代码 创建MyRunnable对象 使用Thread的有参构造（Thread(Runnable,name)）创建线程，并将MyRunnable对象作为有参构造的参数传递进去 调用线程的start()方法，启动线程 程序实例： 自定义一个MyRunnable类，并集成Runnable接口，重写run()方法 package com.study.nanyu.day12; public class MyRunnable implements Runnable{ @Override public void run() { for(int i=0;i 创建MyRunnable对象，使用Thread有参构造创建线程对象，并将MyRunnable对象和线程名作为参数传递进去 package com.study.nanyu.day12; public class ThreadDemo { public static void main(String[] args) { MyRunnable runnable = new MyRunnable(); Thread t1 = new Thread(runnable,\"孙悟空\"); Thread t2 = new Thread(runnable,\"刘备\"); Thread t3 = new Thread(runnable,\"诸葛亮\"); t1.start(); t2.start(); t3.start(); } } /* 结果输出： 刘备:0 诸葛亮:0 孙悟空:0 诸葛亮:1 刘备:1 诸葛亮:2 孙悟空:1 诸葛亮:3 刘备:2 诸葛亮:4 孙悟空:2 孙悟空:3 孙悟空:4 刘备:3 刘备:4 */ 总结： 上面一共有两种创建线程的方式： 继承Thread 实现Runnable接口 那这两种创建线程的方式我们改用哪个呢？推荐使用第二种实现Runnable接口的方式 相比于继承Thread，实现Runnable接口有以下好处： 避免了Java单继承的局限性，因为Java只能单继承，多以如果使用继承Thread方式就不能再继承其他类，而实现Runnable接口的方式则可以再继承其他类，从而进一步扩展功能 适合多个相同程序的代码去处理同一资源的情况，把线程和程序的代码、数据有效的分离，较好的体现了面向对象的思想 1.8 案例：卖票 需求：某动物园有10张票，有三个卖票窗口，以此设计一个程序模拟电影院卖票 实现思路： 定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets=100;表示100张票 在SellTicket类中重写run()方法实现卖票，代码步骤如下： 判断票数大于0，就卖票，并告知哪个窗口 卖了票之后，总票数减1 票没有了，也可能有人来问，所以使用死循环让卖票一直执行 定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下： 创建SellTicket类的对象 创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称。 启动线程 程序实例： 自定义的SellTicket类 package com.study.nanyu.day12; public class SellTicket implements Runnable { private int tickets = 10; @Override public void run() { // 保证一直能卖票，即使票数为0，也可以告知麦票人 while (true) { if (tickets > 0) { System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\"); tickets--; } } } } 测试类： package com.study.nanyu.day12; public class ThreadDemo { public static void main(String[] args) { SellTicket runnable = new SellTicket(); Thread t1 = new Thread(runnable,\"窗口1\"); Thread t2 = new Thread(runnable,\"窗口2\"); Thread t3 = new Thread(runnable,\"窗口3\"); t1.start(); t2.start(); t3.start(); } } /* 结果输出： 窗口1正在出售第10张票 窗口3正在出售第10张票 窗口2正在出售第10张票 窗口3正在出售第8张票 窗口1正在出售第9张票 窗口3正在出售第6张票 窗口2正在出售第7张票 窗口3正在出售第4张票 窗口1正在出售第5张票 窗口3正在出售第2张票 窗口2正在出售第3张票 窗口1正在出售第1张票 */ 其实从上面的输出情况中我们就可以看出一些问题，窗口1、窗口2、窗口3同时出售第10张票，这显然是有问题的，这个问题我们下一章节会分析并解决它。 1.9 卖票程序缺陷 正常情况下出票是有一定时间的，所以我们可以在出票前加个延时来模拟真实的卖票场景，代码如下： package com.study.nanyu.day12; public class SellTicket implements Runnable { private int tickets = 10; @Override public void run() { // 保证一直能卖票，即使票数为0，也可以告知麦票人 while (true) { if (tickets > 0) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\"); tickets--; } } } } 如上，在出票之前加了一个时长为1s的sleep()。测试和输出结果如下： package com.study.nanyu.day12; public class ThreadDemo { public static void main(String[] args) { SellTicket runnable = new SellTicket(); Thread t1 = new Thread(runnable,\"窗口1\"); Thread t2 = new Thread(runnable,\"窗口2\"); Thread t3 = new Thread(runnable,\"窗口3\"); t1.start(); t2.start(); t3.start(); } } /* 输出结果 窗口3正在出售第10张票 窗口1正在出售第10张票 窗口2正在出售第10张票 窗口3正在出售第7张票 窗口2正在出售第7张票 窗口1正在出售第7张票 窗口1正在出售第4张票 窗口2正在出售第4张票 窗口3正在出售第4张票 窗口1正在出售第1张票 窗口3正在出售第1张票 窗口2正在出售第1张票 */ 从输出结果上我们可以发现出现了很大的问题，同一张票，竟然被三个窗口同时售卖（和上一节出现的问题相似）。那究竟是怎么产生这个问题的呢？分析如下： 其实问题就出在下面这段代码中，当窗口1执行代码到Thread.sleep(1000)时，窗口1线程进入休眠状态；此时窗口2线程刚好也执行到Thread.sleep(1000)，窗口2也进入休眠；窗口3线程此时刚好执行到Thread.sleep(1000)。 此时刚好窗口1线程醒来，继续执行打印门票，此时ticket假设等于10，窗口1输出正在出售第10张票。 此时窗口2醒来，从醒来的地方开始继续执行代码，由于是从醒来的地方继续执行代码，所以ticket仍然等于10，窗口2输出正在出售第10张票。 此时窗口3醒来，从醒来的地方开始继续执行代码，由于是从醒来的地方继续执行代码，所以ticket仍然等于10，窗口3输出正在出售第10张票。 三个窗口线程都执行完了打印门票这一步骤，又都进入tickets--操作，窗口1线程执行tickets--，窗口2执行tickets--，窗口3执行tickets--，一共执行了三次tickets--，所以最后票一下子少了三张。 if (tickets > 0) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\"); tickets--; } /* 结果输出： 窗口3正在出售第10张票 窗口1正在出售第10张票 窗口2正在出售第10张票 窗口3正在出售第7张票 窗口2正在出售第7张票 窗口1正在出售第7张票 窗口1正在出售第4张票 窗口2正在出售第4张票 窗口3正在出售第4张票 窗口1正在出售第1张票 窗口3正在出售第1张票 窗口2正在出售第1张票 */ 为什么出现上面的问题？ 因为线程的执行具有随机性，对于一个公共资源，三个线程可能\"同时\"在操作，因此就造成了上面的结果。对于这种问题的解决就引出了线程同步 1.10 线程同步 1.10.1 问题描述 为什么会出现上面的问题（这也是我们判断多线程程序是否会有数据安全问题的标准） 是否是多线程环境 是否有共享数据 是否有多条语句操作共享数据（每条语句来自一个线程） 同时满足上面三个条件一定会出现数据安全问题，也被称为多线程安全问题 如何解决多线程安全问题？ 基本思想：让程序没有安全问题的环境，只需要破坏上面出现线程安全问题条件的其中一个即可。 多线程环境：不可破坏 共享数据：也不可破坏 多条语句操作共享数据：可破坏 如何实现？ 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可。 Java提供了同步代码块的方式来解决 1.10.2 同步代码块 基本思想： 既然线程安全问题造成的原因之一是因为存在对共享数据进行操作的代码。那么我么可以就让同一时刻只能有一个线程执行该代码块，只要有线程正在执行这段操作共享数据的代码，其他线程就不允许执行该代码块，等这个线程完成了自己的操作之后，其他线程才能执行该代码块，同样还是同一时刻只能有一个线程执行代码。 其实Java提供了解决线程安全问题的办法，就是使用同步代码块，思想就是上面的思想。当有一个线程进入代码块执行代码时，使用同步代码块，将操作共享数据的代码块锁起来，其他线程禁止入内，当该线程执行结束，会解锁，放一个线程进如同步代码块，再次上锁，由此避免线程安全问题。 同步代码块书写格式如下： synchronized (任意对象) { // 多条语句操作共享数据的代码 } 这个代码就相当于给代码块上了一把锁，大括号相当于围墙，任意对象相当于那把锁，任意对象就是可以是任意类型的对象都可以实现上锁 如下代码就是把对共享数据操作的那一块代码上了锁，同一时刻只能进入一个线程，保证了线程安全。 注意：那把锁不一定非要是Object对象，可以是任意对象，比如：Integer、String、Math、Random、Thread等等，任意对象均可。 package com.study.nanyu.day12; public class SellTicket implements Runnable { private int tickets = 10; private Object object=new Object(); @Override public void run() { // 保证一直能卖票，即使票数为0，也可以告知麦票人 while (true) { synchronized (object) { if (tickets > 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\"); tickets--; } } } } } 测试类： package com.study.nanyu.day12; public class ThreadDemo { public static void main(String[] args) { SellTicket runnable = new SellTicket(); Thread t1 = new Thread(runnable,\"窗口1\"); Thread t2 = new Thread(runnable,\"窗口2\"); Thread t3 = new Thread(runnable,\"窗口3\"); t1.start(); t2.start(); t3.start(); } } /* 结果输出： 窗口1正在出售第10张票 窗口1正在出售第9张票 窗口1正在出售第8张票 窗口3正在出售第7张票 窗口3正在出售第6张票 窗口3正在出售第5张票 窗口3正在出售第4张票 窗口3正在出售第3张票 窗口3正在出售第2张票 窗口3正在出售第1张票 */ 同步代码块下多线程执行流程： // 1. 窗口1线程进入同步代码块执行 // 4. 窗口2线程抢到CPU，开始执行 // 6. 窗口3线程抢到CPU，开始执行 while (true) { // 5. 窗口2线程发现代码上了锁，等待 // 7. 窗口3线程发现代码上了锁，等待 synchronized (object) { // 2， 代码上锁，票数大于0，继续往下执行 if (tickets > 0) { try { // 3. 休眠100毫秒，下CPU Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } // 8. 窗口1线程休眠结束，重新夺回CPU，继续执行同步代码块中的代码，出票 System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\"); // 9. 票数减一 tickets--; } } // 执行完毕，出代码块，解锁 } 同步的优缺点： 优点：解决了多线程数据安全问题 缺点：当线程很多时，每个线程都会去判断同步上的锁，这是很消耗资源的，无形中会降低程序的运行效率 注意： 一个锁可以同时锁多个代码块，如果两个 synchronized (object) {}同步代码块用的是同一把锁，比如Object，则Object这把锁可以同时锁住两个代码块，只要一个代码块中有线程在执行，那么这两个同步代码块都会被上锁。如下： while (true) { if (tickets > 0) { synchronized (object) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\"); tickets--; } } else { synchronized (object) { System.out.println(\"上面被锁的同时，我也被锁了\"); } } } 1.10.3 同步方法 同步方法：就是将synchronized关键字加到方法上 格式：修饰符 synchronized 返回值类型 方法名(方法参数){} 其实上面的代码可以优化成下面形式： package com.study.nanyu.day12; public class SellTicket implements Runnable { private int tickets = 10; private Object object = new Object(); @Override public void run() { // 保证一直能卖票，即使票数为0，也可以告知麦票人 while (true) { setTickets(); } } public synchronized void setTickets() { if (tickets > 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\"); tickets--; } } } 上面就是使用同步方法解决问题的形式，但使用同步方法时应注意如下几点 非静态同步方法的锁是this，this表示的是本类对象。如下，在同步代码块中也使用this（本类对象）作为锁可以同时锁住同步代码块中的内容，也可以锁住方法中的内容。 package com.study.nanyu.day12; public class SellTicket implements Runnable { private int tickets = 10; @Override public void run() { // 保证一直能卖票，即使票数为0，也可以告知麦票人 while (true) { synchronized (this) { if (tickets > 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\"); tickets--; }else{ setTickets(); } } } } public synchronized void setTickets() { if (tickets > 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\"); tickets--; } } } 静态同步方法的锁是该类的字节码文件，static修饰的是与类相关的，所以静态同步方法的锁是该类的字节码文件对象。 package com.study.nanyu.day12; public class SellTicket implements Runnable { private int tickets = 10; @Override public void run() { // 保证一直能卖票，即使票数为0，也可以告知麦票人 while (true) { synchronized (SellTicket.class) { if (tickets > 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\"); tickets--; }else{ setTickets(); } } } } public static synchronized void setTickets() { if (tickets > 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\"); tickets--; } } } 1.10.4 小结 出现线程安全问题的三个条件 处于多线程环境 是否有共享数据 是否有多条语句操作共享数据 解决线程安全问题的措施：破环多条语句操作共享数据这一条件 同步代码块格式：synchronized (任意对象) {// 多条语句操作共享数据的代码}，其中任意对象充当的角色是一把锁 同步方法：public （static） synchronized void setTickets() {// 操作共享数据的代码块} 非静态同步方法的锁对象是this 静态同步方法的锁对象是该类的字节码文件对象（类.class） 1.11 线程安全的类 Java提供的线程安全的类有：StringBuffer、Vector、HashTable StringBuffer 线程安全，可变的字符序列 从版本JDK5开始，被StringBuilder替代。通常使用StringBuilder类，因为它支持所有相同的操作，但它更快 StringBuffer中部分同步方法 @Override public synchronized int length() { return count; } @Override public synchronized int capacity() { return value.length; } Vector 从Java2平台v1.2开始，该类改进了List接口，使其称为Java Collection Framework的成员。与新的集合实现不同，Vector被同步，如果不需要被同步，建议使用ArrayList替代Vector Vector类中部分同步方法 public synchronized void trimToSize() { modCount++; int oldCapacity = elementData.length; if (elementCount 0) { modCount++; ensureCapacityHelper(minCapacity); } } HashTable 该类实现了一个哈希表，它将键映射到值，任何非null对象都可用作键或者值 从Java2平台v1.2开始，该类进行了改进，实现了Map接口，使其成为Java Collection Framework的成员，与新的集合不同，HashTable被同步。如果不需要被同步，HashTable HashTable中部分同步方法 public synchronized int size() { return count; } public synchronized boolean isEmpty() { return count == 0; } public synchronized Enumeration keys() { return this.getEnumeration(KEYS); } 总结： StringBuffer对标的是StringBuilder，StringBuffer是StringBUilder线程安全的替代类 Vector对标的是ArrayList集合，Vector是ArrayList线程安全的替代类 HashTable对标的是HashMap，HashTable是HashMap线程安全的替代类 所有线程安全的类相比于其线程不安全的替代类，都有效率低，速度慢的特点，原因在于线程安全的类往往需要判断线程是否处于安全状态，增加了耗时。 单线程环境下，推荐用线程非安全的类 1.12 Lock锁 虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，Jdk5以后提供了一个新的锁对象Lock。 Lock实现提供了比使用synchrinized方法和语句可以获得更广泛的锁定操作，他提供了下面两个方法获得锁和释放锁 void lock() // 获得锁 void unlock() // 释放锁 Lock是一个接口，不能用来实例化，应该使用它的实现类已多态的形式实例化，或者直接实例化其实现类。我们通常使用它的实现类ReentranLock来实例化，使用ReentranLock的无参构造器创建对象 ReentranLock() // 创建一个ReentranLock的实例 程序实例： package com.study.nanyu.day12; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class SellTicket implements Runnable { // 共享数据 private int tickets = 10; // 创建锁对象 private Lock lock=new ReentrantLock(); @Override public void run() { while (true) { // 加锁 lock.lock(); if (tickets > 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\"); tickets--; } // 解锁 lock.unlock(); }}} 上面的代码虽然能够实现加锁解锁的操作，但是我们一般不会这样使用，因为，当lock.lock();与lock.unlock();中间的代码出现了问题时，就会停止执行，不会执行到释放锁的位置，所以，我们一般不采用这种形式加锁与释放锁，而是使用try...catch的形式，在finally中释放锁，这样就能保证无论如何都会把锁释放。代码如下： package com.study.nanyu.day12; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class SellTicket implements Runnable { // 共享数据 private int tickets = 10; // 创建锁对象 private Lock lock = new ReentrantLock(); @Override public void run() { while (true) { try { // 加锁 lock.lock(); if (tickets > 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\"); tickets--; } }finally { // 解锁 lock.unlock(); } } } } 1.13 生产者与消费者 生产者消费者模式是一个十分经典的多线程协作模式，弄懂了生产者消费者问题能够让我们对多线程编程的理解更加深刻 所谓的生产者消费者问题，实际上主要包含了两类线程 一类是生成者线程用于生成数据 一类是消费者线程用于消费数据 为了解耦生产者与消费者的关系，通常会采用共享的数据区域，就像一个仓库 生产者生产了数据之后直接放置在共享数据区中，并不需要关心消费者行为 消费者只需要从共享数据区中获取数据，并不需要关心生产者行为。 举例解释： 现有两个角色，一个是送牛奶的A，一个是和牛奶的B，送牛奶A的每天会送一瓶牛奶到B家门口的牛奶箱box中，喝牛奶的B每天会从奶箱box中取出牛奶来喝。这就是一个消费者与生产者的问题。 送牛奶的A就是成产者线程，喝牛奶的B就是消费者线程，奶箱box就是存放生产出数据的仓库（可以理解为临界区） 为了体现生产者和消费者过程中的等待和唤醒，Java提供了下面几个方法供我们使用，这几个方法在Object类中 方法名 说明 void wait() 导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法 void notify() 唤醒正在等待对象监视器的单个线程 void notifyAll() 唤醒正在等待对象监视器的所有线程 生产者与消费者案例： 类结构： 奶箱类（Box）：定义一个成员变量，表示第x瓶奶，提供存储牛奶和获取牛奶的操作 生产者类（Producer）：实现Runnable接口，重写run()方法，调用存储牛奶的操作 消费者类（Cunstomer）：实现Runnable接口，重写run()方法，调用获取牛奶的操作 测试类（BoxDemo）：里面有main方法，main方法中代码步骤如下： 创建奶箱对象，这是共享数据区域 创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作 创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作 创建两个线程对象，分别把生产者和消费者对象作为构造方法参数传递 程序实例： Box类： package com.study.nanyu.day12.example; public class Box { // 表示第i瓶牛奶 private int milk; // 表示奶箱的状态,奶箱中有牛奶味true，没有为false private boolean statue=false; public synchronized void set(int milk){ // 如果奶箱中有牛奶，等待消费完再生产 if(statue){ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 如果奶箱中没牛奶，就会生产牛奶 this.milk=milk; System.out.println(\"送奶工正在把第\"+this.milk+\"瓶奶放进奶箱\"); // 生产完毕之后，修改奶箱状态为true statue=true; // 唤醒被等待的获取牛奶的进程来消费牛奶 notifyAll(); } public synchronized void get(){ // 如果奶箱中没有牛奶，则等待生产 if(!statue){ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 如果奶箱中有牛奶，则获取牛奶 System.out.println(\"顾客正在享用第\"+this.milk+\"瓶奶\"); // 获取牛奶后，设置奶箱状态为false statue=false; // 唤醒被等待的生产牛奶的进程来生产牛奶 notifyAll(); } } 生产者类： package com.study.nanyu.day12.example; public class Producer implements Runnable{ private Box box; public Producer(Box box){ this.box=box; } @Override public void run() { // 发牛奶 for (int i=1;i 消费者类： package com.study.nanyu.day12.example; public class Customer implements Runnable{ private Box box; public Customer(Box box){ this.box=box; } @Override public void run() { // 获取牛奶 while (true) { box.get(); } } } 测试类： package com.study.nanyu.day12.example; public class BoxDemo { public static void main(String[] args) { Box box=new Box(); Producer producer=new Producer(box); Customer customer=new Customer(box); Thread p=new Thread(producer,\"生产者\"); Thread c=new Thread(customer,\"消费者\"); p.start(); c.start(); } } 注意： 生产和消费方法一定要加上同步，原因在于线程的执行具有随机性，加上同步的可以在生产者调用set()方法生产牛奶的同时会锁定获取牛奶的方法，从而达到生产牛奶的时候不能获取牛奶。反之也是，保证消费者通过get()方法获取牛奶的同时，生产者不能生产牛奶。保证不会出现线程安全问题 2. 网络编程 2.1 网络编程概述 计算机网络： 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。 网络编程 在网络通信协议下，实现在网络互联的不同计算机上运行的程序间可以进行数据交换 2.2 网络编程三要素 IP地址： 要想让网络中的计算机之间能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而这个IP地址就是这个标识号，也就是设备的标识。更简单来说，IP地址就是在网络中的门牌号，通过门牌号你可以找到别人，并给别人发送数据，别人也可以通过你的门牌号找到你，并向你发送数据。 端口： 网络的通信，本质上是两个应用程序之间的通信。每台计算机都有很多个应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序，也就是应用程序的唯一标识。更简单来说，IP地址时为了让别人在网络中找到你这台计算机的位置，而端口则是让计算机可以找到应用程序在计算机中的位置。 两台计算通信本质上是两台计算机上的应用程序在通信，以QQ为例，两台计算机中的QQ可以相互发信息，那是因为两台计算机中的QQ采用了相同的端口号，双方在发送信息给对方时都会找对方计算机中端口对应的应用程序进行通信。又比如QQ不能直接发信息到微信，原因就是QQ与微信使用的不是相同的端口号，双方发送信息给对方电脑，但是不能通过QQ端口号找到微信。 协议： 通过计算机网络可以使多台计算机连接起来，位于同一网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路上行驶要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守协议才能完成数据交换，常见的协议有UDP和TCP协议。 2.3 IP地址 IP地址：IP地址是网络中设备的唯一标识 IP地址分为两大类： IPV4：为每个连接在网络上的主机分配一个32bit的地址，按照TCP/IP规定，IP地址用二进制表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的Ip地址是11000000 10101000 00000001 01000010，这样以来不便我们记忆，我们通常使用更好记忆的十进制来表示IP地址192.168.1.66，以十进制表示的IP地址叫做”点分十进制表示法“。 IPV6：互联网用户的数量不断激增导致IP地址的需求变得越来越大，IPV4已经不够用户使用了，所以为了扩大地址空间，通过IPV6重新定义地址空间，采用128为地址长度，每16个字节一组，分成8组十六进制数。据说IPV6可以为地球上的每一粒沙子都分配一个IP地址。 获取本机IP地址： Win系统：ipconfig Linux系统：ip a 测试IP是否可用： ping ip 特殊IP地址： 127.0.0.1：回送地址，可代表本机，一般用来测试 2.4 InetAddress的使用 为了方便我们对IP地址的获取和操作，Java提供了一个类InetAddress供我们使用。 InetAddress：此类表示Interne协议（IP）地址。 该类内部没有构造器，我们无法通过构造器的形式创建InetAddress对象，但InetAddress内部提供了获取InetAddress对象的静态方法： 方法 说明 static InetAddress getAllByname(String host) 根据主机名称，根据系统上配置的名称服务返回其IP地址数组 static InetAddress getByAddress(byte [] addr) 根据二进制的IP地址创建InetAddress对象 static InetAddress getByAddress(String host,byte [] addr) 根据提供的主机名和IP地址创建InetAddress对象 static InetAddress getByName(String host) 根据主机名称或IP地址获取InetAddress对象 另外，InetAddress中比较常用的方法有 方法 说明 String getHostName() 获取此IP地址的主机名 String getHostAddress() 返回文本显示中的IP地址字符串 程序实例： nanyu：是我电脑的主机名 package com.study.nanyu.day13; import java.net.InetAddress; import java.net.UnknownHostException; public class InetAddressDemo { public static void main(String[] args) throws UnknownHostException { // 通过主机名获取InetAddress对象 InetAddress inetAddress = InetAddress.getByName(\"nanyu\"); // 通过IP地址获取InetAddress对象 // InetAddress inetAddress = InetAddress.getByName(\"192.168.154.1\"); String address = inetAddress.getHostAddress(); String hostName = inetAddress.getHostName(); System.out.println(address); System.out.println(hostName); } } /* 输出结果： 192.168.154.1 nanyu */ 2.5 端口与协议 端口：设备上应用程序的唯一标识 端口号：用两个字节表示的整数，它的取值范围是0~65535。其中0~1023之间的端口号用于一些指明的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被玲一个服务或应用占用，会导致当前程序启动失败。 协议：计算机网络中，连接和通信的规则被称为网络通信协议。 UDP协议： 用户数据包协议（User Datagram Protocol） "},"1-Java/9-Java反射.html":{"url":"1-Java/9-Java反射.html","title":"9. Java反射","keywords":"","body":"Java反射 1.1 反射概述 Java反射机制：指在运行时去获取一个类的变量和方法信息，然后通过获取到的信息来创建对象，调用方法的一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行器仍然可以扩展。 1.2 获取Class对象 要想通过反射去使用一个类，首先要获取该类的字节码文件对象，即类型为Class类型的对象。 三种获取Class类型对象的方式： 使用类的class属性来获取该类对应的Class对象，例如：Student.class将会返回Studen类对应的Class对象。 调用对象的getClass()方法，返回该对象所属类对应的Class对象。该方法时Object类中的方法，所有的Java对象都可以调用该方法。 使用Class类中的静态方法forName(String className)，该方法需要传入字符串参数，该字符串参数的值是某个类的全路径，也是完整包名的路径。 构建一个Student类： package com.zut.nanyu; public class Student { private String name; int age; public String address; public Student(String name, int age, String address) { this.name = name; this.age = age; this.address = address; } Student(String name, int age) { this.name = name; this.age = age; } private Student(String name) { this.name = name; } public Student() { } private void function(){ System.out.println(\"function\"); } public void menthod1(){ System.out.println(\"menthod1\"); } public void menthod2(String s){ System.out.println(\"menthod2\"+s); } public String menthod3(String s,int i){ return s+\",\"+i; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", address='\" + address + '\\'' + '}'; } } 方式一：使用类的class属性来获取类对应的Class对象 package com.zut.nanyu; public class Test1 { public static void main(String[] args) throws ClassNotFoundException { // Student s=new Student(); // System.out.println(s); //方式一:使用类的class属性来获取类对应的Class对象 使用时最方便 Class c1 = Student.class;//获取student类的字节码对象 System.out.println(c1);//输出结果为：class com.zut.nanyu.Student System.out.println(\"--------------------------------------------------\"); } } 方式二：调用getClass()方法，返回对象所属类对应的Class对象 package com.zut.nanyu; public class Test1 { public static void main(String[] args) throws ClassNotFoundException { /* Class c1 = Student.class;//获取student类的字节码对象 System.out.println(c1);//输出结果为：class com.zut.nanyu.Student System.out.println(\"--------------------------------------------------\"); */ //方式二:调用getClass()方法，返回对象所属类对应的Class对象。 Student s=new Student(); Class c2 = s.getClass(); System.out.println(c2); //一个类在内存中只能存在一个字节码文件对象，因此c1与c2相等 System.out.println(c1==c2);//true System.out.println(\"--------------------------------------------------\"); } } 方式三：使用Class类中的静态方法forName(String className) package com.zut.nanyu; public class Test1 { public static void main(String[] args) throws ClassNotFoundException { /* //方式一:使用类的class属性来获取类对应的Class对象 Class c1 = Student.class;//获取student类的字节码对象 System.out.println(c1);//输出结果为：class com.zut.nanyu.Student System.out.println(\"--------------------------------------------------\"); //方式二:调用getClass()方法，返回国企对象所属类对应的Class对象。 Student s=new Student(); Class c2 = s.getClass(); System.out.println(c2); //一个类在内存中只能存在一个字节码文件对象，因此c1与c2相等 System.out.println(c1==c2);//true System.out.println(\"--------------------------------------------------\"); */ // 方式三:使用Class类中的静态方法forName(String className) 灵活性更高 Class c3 = Class.forName(\"com.zut.nanyu.Student\"); System.out.println(c1==c3); } } 1.3 反射获取构造方法并使用 Class类中用于获取构造方法的方法 Constructor[getConstructors0):返回所有公共构造方法对象的数组 Constructor[getDeclaredConstructors):返回所有构造方法对象的数组 Constructor getConstructor(Class ... parameterTypes):返回单个公共构造方法对象 Constructor getDeclaredConstructor(Class...parameterTypes);返回单个构造方法对象 Constructor类中用于创建对象的方法 T newlnstance(Object... initargs):根据指定的构造方法创建对象 package com.zut.nanyu; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; /* 反射获取构造方法并使用 */ public class Test1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { //获取Class对象 Class c = Class.forName(\"com.zut.nanyu.Student\"); //返回一个包含Constructor对象的数组，Constructor对象反应了由该class对象表示的类的所有公共的构造函数 Constructor[] cons = c.getConstructors(); //返回一个包含Constructor对象的数组，Constructor对象反应了由该class对象表示的类的所有的构造函数 Constructor[] d = c.getDeclaredConstructors(); for(Constructor con :d){ // System.out.println(con); } //获取指定的构造函数；参数：表示要获取的构造方法的参数个数和数据类型对应的字节码文件对象 //获取无参构造器 Constructor constructor = c.getConstructor(); //Constructor提供了一个类的单个构造函数的信息和访问权限 Object o = constructor.newInstance(); System.out.println(o); } } 1.4 反射获取构造方法并使用练习 练习1:通过反射实现如下操作 Student s = new Student(\"林青霞\",30,\"西安\"); System.out.printIn(s); 通过正常方法得到的对象与通过反射的到的对象结果是一样的，只不过实现的形式不同而已。 package com.zut.nanyu; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; public class Test2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { /* 通过正常方法得到的对象 */ Student s=new Student(\"轩辕钢蛋\",20,\"美国\"); System.out.println(s);//输出结果:Student{name='轩辕钢蛋', age=20, address='美国'} /* 通过反射得到的对象 */ //获取Class对象c Class c = Class.forName(\"com.zut.nanyu.Student\"); //通过c调用getConstructor()方法得到构造方法对象con Constructor con = c.getConstructor(String.class,int.class, String.class); //通过构造方法对象con调用newInstance()方法得到对象 Object o = con.newInstance(\"轩辕钢蛋\",20,\"美国\"); System.out.println(o);//输出结果:Student{name='轩辕钢蛋', age=20, address='美国'} } } 练习2：通过反射实现如下操作 Student s=new Student(\"慕容傻根\") System.out.print(s) privaye修饰的构造函数不能用正常的方法获取构造方法对象，需要通过暴力反射 package com.zut.nanyu; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; public class Test2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { // 获取Class对象 Class c = Class.forName(\"com.zut.nanyu.Student\"); // 此构造函数是privaye修饰的，因此获取构造方法对象时要使用getDeclaredConstructor（） Constructor con= c.getDeclaredConstructor(String.class); // 暴力反射,对于私有构造函数不能按照常规方法来生成对象，需要通过暴力反射 con.setAccessible(true); // 生成一个对象 Object obj = con.newInstance(\"赵四\"); System.out.println(obj);//输出结果：Student{name='赵四', age=0, address='null'} } } 1.5 反射获取成员变量并使用 getFields（）只能获取公共的成员变量 public class Test1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { //获取Class对象 Class c = Class.forName(\"com.zut.nanyu.Student\"); //获取公共的成员变量 Field[] fields = c.getFields(); for(Field file:fields){ System.out.println(file); } } } // 输出结果 // public java.lang.String com.zut.nanyu.Student.address getDeclaredFields()可以方法获取全部变量（包括private修饰的变量） public class Test1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { //获取Class对象 Class c = Class.forName(\"com.zut.nanyu.Student\"); //获取公共的成员变量 Field[] fields = c.getDeclaredFields(); for(Field file:fields){ System.out.println(file); } } } // 输出结果 // private java.lang.String com.zut.nanyu.Student.name public修饰的变量 // int com.zut.nanyu.Student.age 默认的变量 // public java.lang.String com.zut.nanyu.Student.address private修饰的变量 getFile(String name)方法获取一个指定的公共的成员变量 getDeclaredFields(String name)方法获取一个指定的公共的成员变量 public class Test1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException { //获取Class对象 Class c = Class.forName(\"com.zut.nanyu.Student\"); //获取指定的public修饰的成员变量 Field name = c.getField(\"address\"); //获取指定的private修饰的成员变量 Field fields = c.getDeclaredField(\"name\"); //获取指定的默认修饰的成员变量 Field age = c.getDeclaredField(\"age\"); System.out.println(fields); System.out.println(name); System.out.println(age); } } 1.6 反射获取成员变量并使用练习 练习一：使用反射实现如下功能 Student s=new Student(); s.address=\"广州\"; System.out.println(s); 利用反射为成员变量赋值 public class Test1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException { //获取Class对象 Class c = Class.forName(\"com.zut.nanyu.Student\"); //获取无参构造函数对象 Constructor con = c.getConstructor(); //利用无参构造方法对象创建对象 Object obj = con.newInstance(); //获取指定的成员变量对象 Field address = c.getDeclaredField(\"address\"); //利用指定的成员变量对象获取set()方法，为成员变量赋值 address.set(obj,\"广州\"); System.out.println(obj); } } 练习二：使用反射实现如下操作 Student s =new Student(); s.name=\"李四\"; s.age=20; s.address=\"深圳\"; System.out.println(s); 实现步骤 public class Test1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException { //获取Class对象 Class c = Class.forName(\"com.zut.nanyu.Student\"); //获取成员变量对象 Field name = c.getDeclaredField(\"name\"); name.setAccessible(true); Field address = c.getDeclaredField(\"address\"); name.setAccessible(true); Field age = c.getDeclaredField(\"age\"); name.setAccessible(true); //创建有参构造函数对象 Constructor con = c.getDeclaredConstructor(); //利用有参构造函数对象创建对象 Object obj = con.newInstance(); address.set(obj,\"深圳\"); age.set(obj,20); name.set(obj,\"李四\"); System.out.println(obj); } } 1.7 反射获取成员方法并使用 getMethods()方法获取类或接口的所有公共方法对象，包括由类或接口声明的对象以及从父类或接口中继承的类 public class Test1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException { //获取Class对象 Class c = Class.forName(\"com.zut.nanyu.Student\"); Method[] methods = c.getMethods(); for(Method m:methods){ System.out.println(m); } } } /* 输出结果 public java.lang.String com.zut.nanyu.Student.toString() public java.lang.String com.zut.nanyu.Student.menthod3(java.lang.String,int) public void com.zut.nanyu.Student.menthod2(java.lang.String) public void com.zut.nanyu.Student.menthod1() public final void java.lang.Object.wait() throws java.lang.InterruptedException public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException public boolean java.lang.Object.equals(java.lang.Object) public native int java.lang.Object.hashCode() public final native java.lang.Class java.lang.Object.getClass() public final native void java.lang.Object.notify() public final native void java.lang.Object.notifyAll() */ getMethods()方法获取类或接口的所有方法对象，不包括由类或接口声明的对象以及从父类或接口中继承的类 public class Test1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException { //获取Class对象 Class c = Class.forName(\"com.zut.nanyu.Student\"); Method[] methods = c.getDeclaredMethods(); for(Method m:methods){ System.out.println(m); } } } /* 输出结果 public void com.zut.nanyu.Student.menthod1() public void com.zut.nanyu.Student.menthod2(java.lang.String) public java.lang.String com.zut.nanyu.Student.menthod3(java.lang.String,int) public java.lang.String com.zut.nanyu.Student.toString() private void com.zut.nanyu.Student.function() */ getMethod()获取单个公共成员方法对象 getDeclaredMethod()获取单个成员方法对象 invoke()方法对方法进行调用和传参 public class Test1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException { //获取Class对象 Class c = Class.forName(\"com.zut.nanyu.Student\"); //获取无参构造函数对象 Constructor con = c.getConstructor(); //使用无参构造函数创建Student对象 Object obj = con.newInstance(); //创建指定公共无参成员方法对象 //Method method = c.getMethod(\"menthod2\"); //创建指定无参数的成员方法对象 Method m = c.getDeclaredMethod(\"menthod1\"); //创建有参数的成员方法对象 Method method = c.getDeclaredMethod(\"menthod2\",String.class); //对方法进行调用和传参 Object invoke(Object obj,Object args……) //args:表示成员方法中的参数，无参方法可以不写 m.invoke(obj); method.invoke(obj,\"调用成功了\"); } } 1.8 反射获取成员方法并使用练习 练习：使用反射实现如下操作 Student s=new Student(); s.method1(); s,method2(\"张三\"); String ss=method3(\"张三\",20); System.out.print(ss); s.function(); 因为function()方法属于私有方法，因此需要m4.setAccessible(true);方法来关闭检查 public class Test1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException { //获取Class对象 Class c = Class.forName(\"com.zut.nanyu.Student\"); //使用Class对象创建无参构造函数对象 Constructor con = c.getConstructor(); //通过无参构造函数对象创建对象 Object obj = con.newInstance(); //获取指定的成员方法对象 Method m1 = c.getDeclaredMethod(\"menthod1\"); m1.invoke(obj); //获取指定的成员方法对象 Method m2 = c.getDeclaredMethod(\"menthod2\", String.class); m2.invoke(obj,\"张三\"); //获取指定的成员方法对象 Method m3 = c.getDeclaredMethod(\"menthod3\", String.class, int.class); Object o = m3.invoke(obj, \"张三\", 20); System.out.println(o); //获取指定的成员方法对象 Method m4 = c.getDeclaredMethod(\"function\"); m4.setAccessible(true); m4.invoke(obj); } } 1.9 反射练习 练习一：有一个ArrayList集合，若要在这个几个中田间一个字符串数据，该怎么做？ public class Test1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException { //创建集合 ArrayList list=new ArrayList(); //获得list集合对象 Class a = list.getClass(); //获取方法对象 Method add = a.getMethod(\"add\", Object.class); add.invoke(list,\"Hello\"); add.invoke(list,\"Java\"); add.invoke(list,\"Why\"); System.out.println(list); } } /* 输出结果 [Hello, Java, Why] */ 练习二：通过配置文件练习类中的方法 使用配置文件的方式相对灵活，不至于把程序写死，用户只需要修改配置文件的内容，程序即可对相应的配置文件做出反应。 创建一个学生类 package com.zut.nanyu; public class Student { public void study(){ System.out.print(\"好好学习，天天向上\"); } } 创建一个教师类 package com.zut.nanyu; public class Teacher { public void teach() { System.out.print(\"教书育人\"); } } 创建一个配置文件 classname=com.zut.nanyu.Student methodName=study 编写测试类 package com.zut.nanyu; import java.io.FileReader; import java.io.IOException; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Properties; public class Test1 { public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { //加载数据 Properties prop=new Properties(); FileReader fr=new FileReader(\"./class.txt\"); prop.load(fr); fr.close(); //读取配置文件中的内容 String classname = prop.getProperty(\"classname\"); String methodName = prop.getProperty(\"methodName\"); //通过反射来使用 //通过com.zut.nanyu.Student，创建Class对象 Class c = Class.forName(classname);//此处classname=com.zut.nanyu.Student //获取无参构造器 Constructor con = c.getConstructor(); //通过无参构造器创建一个对象 Object obj = con.newInstance(); //通过Class对象获取成员方法对象 Method m = c.getMethod(methodName); m.invoke(obj); } } //输出结果:好好学习，天天向上 "},"10-Spark/1-Spark.html":{"url":"10-Spark/1-Spark.html","title":"1. Spark","keywords":"","body":"1. Spark简介 Spark是用于大规模数据分析的统一引擎，是一种多语言引擎，用于在单节点机器或集群上执行数据工程、数据科学和机器学习。 Spark官网：https://spark.apache.org/ 技术栈数据统计：stackoverflow "},"10-Spark/2-ElasticSearch.html":{"url":"10-Spark/2-ElasticSearch.html","title":"2. ElasticSearch","keywords":"","body":"1.1 简介 Elasticsearch是一个高度可扩展的开源全文搜索和分析引擎。它允许您快速，近实时地存储，搜索和分析大量数据。它通常被用作基础的技术来赋予应用程序复杂的搜索特性和需求。 假设你有一个在线网上商城，提供用户搜索你所卖的商品功能。在这个例子中，你可以使用Elasticsearch去存储你的全部的商品目录和存货清单并且提供搜索和搜索自动完成以及搜索推荐功能。 假设你想去收集日志或者业务数据，并且去分析并从这些数据中挖掘寻找市场趋势、统计资料、摘要信息或者反常情况。在这个例子中，你可以使用Logstash(ELK架构中的一个模块)去收集、聚合并且解析你的数据，然后通过Logstash将数据注入Elasticsearch。一旦数据进入Elasticsearch，你就可以运行搜索和聚集并且从中挖掘任何你感兴趣的数据。 假设你运行一个价格预警平台，它可以让那些对价格精明的客户指定一个规则，比如：“我相中了一个电子产品，并且我想在下个月任何卖家的这个电子产品的价格低于多少钱的时候提醒我”。在这个例子中，你可以抓取所有卖家的价格，把价格放入Elasticsearch并且使用Elasticsearch的反向搜索(过滤器/抽出器)功能来匹配价格变动以应对用户的查询并最终一旦发现有匹配结果时给用户弹出提示框。 假设您有分析/业务智能需求，并希望快速调查，分析，可视化并询问有关大量数据的特定问题（试想数百万或数十亿条记录）。在这种情况下，您可以使用Elasticsearch存储数据，然后使用Kibana（ELK架构中的一个组件）构建自定义仪表板，以便可视化对您来说重要的数据方面。此外，您可以使用Elasticsearch聚合功能针对您的数据执行复杂的商业智能查询。 Elasticsearch与其他数据库的对比 指标RedisMySQLElasticsearchHBaseHadoop/Hive容量/容量扩展低中较大海量海量查询时效性极高中等较高中等低查询灵活性较差 k-v模式非常好，支持SQL较好，关联查询较弱，但是可以全文检索，DSL语言可以处理过滤、匹配、排序、聚合等各种操作较差，主要靠RowKey, Scan的话性能不行，或者建立二级索引非常好，支持SQL写入速度极快中等较快较快慢一致性、事务弱强弱弱弱 1.2 Lucene Lucene是apache软件基金会jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎。 目前市面上流行的搜索引擎软件，主流的就两款，Elasticsearch和solr,这两款都是基于Lucene的搭建的，可以独立部署启动的搜索引擎服务软件。由于内核相同，所以两者除了服务器安装、部署、管理、集群以外，对于数据的操作，修改、添加、保存、查询等等都十分类似。就好像都是支持SQL语言的两种数据库软件。只要学会其中一个另一个很容易上手。 从实际企业使用情况来看，ElasticSearch的市场份额逐步在取代solr，国内百度、京东、新浪、滴滴都是基于ElasticSearch实现的搜索功能。国外就更多了 像维基百科、GitHub、Stack Overflow等等也都是基于ES的。 1.3 环境搭建 1.3.1 环境要求 Elasticsearch至少需要Java 8版本。ES要求的用户为非root用户。 1.3.2 文件下载 ElasticSearch ES目录结构 目录名含义bin运行ES实例和管理插件的一些脚本config配置文件目录libES所需要使用的库dataES存放数据的地方logs日志文件夹modules加载的模块列表，其实就是内置插件目录plugins自定义插件目录 1.3.3 安装ES ES不能在Root目录下启动，需要另外创建一个新的用户，在该用户下启动。 环境配置 ##创建用户和用户组【所有节点同时操作】 [root@node01 ~]# groupadd es [root@node01 ~]# useradd es -g es -p 123456 ##关闭防火墙并禁止开机自启【所有节点同时操作】 [root@node01 ~]# systemctl stop firewalld [root@node01 ~]# systemctl disable firewalld.service ##创建相应目录并赋权给es用户【所有节点同时操作】 [root@node01 ~]# mkdir -p /var/es/logs [root@node01 ~]# mkdir -p /var/es/data [root@node01 ~]# chown -R es:es /var/es/* # 解压 [root@node01 apps]# tar -zxvf elasticsearch-7.6.2-linux-x86_64.tar.gz ##赋予权限【所有节点同时操作】 [root@node01 apps]# chown -R es:es /opt/apps/elasticsearch-7.6.2/* ##修改配置文件 [root@node01 elasticsearch-7.6.2]# vim config/elasticsearch.yml #配置es的集群名称，es会自动发现在同一网段下的es，如果同一网段下有多个集群，可以用这个属性来区分不同的集群。 cluster.name: nanyu #节点名称 node.name: node01 #设置索引数据的存储路径，可以设置多个存储路径，用逗号隔开 path.data: /var/es/data #设置日志文件的存储位置 path.logs: /var/es/logs #设置为true来锁住内存，因为当JVM开始swapping时候es的效率会降低，所以保证它不swap，可以把ES_MIN_MEM和ES_MAX_MEM两个环境变量设置成同一个值，所以保证机器有足够的内存分配给es bootstrap.memory_lock: true #设置绑定的ip地址，可以是ipv4或者ipv6，默认为0.0.0.0,如果配置，对应的是各个节点的IP地址 network.host: 192.168.100.101 #设置对外服务的http端口，默认为9200 http.port: 9200 #此设置通常应包含群集中所有可以成为master节点的地址 discovery.seed_hosts: [\"node01\", \"node02\", \"node03\"] #指定了哪些节点在初始化的时候将会参加选举 cluster.initial_master_nodes: [\"node01\", \"node02\", \"node03\"] #只要此许多数据或主节点已加入群集，即可恢复。 gateway.recover_after_nodes: 2 #对一些人来说，能够用单个命令来删除所有数据可能会导致可怕的后果。设置为true，可以避免这种情况 action.destructive_requires_name: true # 支持跨域访问 http.cors.enabled: true http.cors.allow-origin: \"*\" ##三台虚拟机同时操作 [root@node01 elasticsearch-7.6.2]# vim /etc/security/limits.conf es soft nofile 65536 es hard nofile 65536 es soft memlock unlimited es hard memlock unlimited [root@node01 elasticsearch-7.6.2]# vim /etc/sysctl.conf vm.max_map_count=262144 # 让设置立即生效 [root@node01 elasticsearch-7.6.2]# sysctl -p 启动集群 ## 将node01上的es目录远程拷贝到其他节点 [root@node01 apps]# scp -r elasticsearch-7.6.2 root@node02:/opt/apps/ [root@node01 apps]# scp -r elasticsearch-7.6.2 root@node03:/opt/apps/ ## 对应每个节点修改节点名称 #节点名称 node.name: node02 network.host: 192.168.154.102 ## 启动【所有节点同时操作】 # 切换用户 [root@node01 apps]# su es [es@node01 elasticsearch-6.5.0]$ ./bin/elasticsearch # 返回root用户,需要输入密码 [es@node01]$ su root 测试是否启动成功 http://192.168.154.101:9200/ { \"name\" : \"node01\", \"cluster_name\" : \"nanyu\", \"cluster_uuid\" : \"JV-92EKkTlGPAiE4QSLTlQ\", \"version\" : { \"number\" : \"7.6.2\", \"build_flavor\" : \"default\", \"build_type\" : \"tar\", \"build_hash\" : \"ef48eb35cf30adf4db14086e8aabd07ef6fb113f\", \"build_date\" : \"2020-03-26T06:34:37.794943Z\", \"build_snapshot\" : false, \"lucene_version\" : \"8.4.0\", \"minimum_wire_compatibility_version\" : \"6.8.0\", \"minimum_index_compatibility_version\" : \"6.0.0-beta1\" }, \"tagline\" : \"You Know, for Search\" } 查看集群状态 http://192.168.154.101:9200/_cluster/health { \"cluster_name\":\"nanyu\", \"status\":\"green\", \"timed_out\":false, \"number_of_nodes\":3, \"number_of_data_nodes\":3, \"active_primary_shards\":0, \"active_shards\":0, \"relocating_shards\":0, \"initializing_shards\":0, \"unassigned_shards\":0, \"delayed_unassigned_shards\":0, \"number_of_pending_tasks\":0, \"number_of_in_flight_fetch\":0, \"task_max_waiting_in_queue_millis\":0, \"active_shards_percent_as_number\":100.0 } 问题集锦 此问题是由于先使用root用户执行了，执行后会导致产生了root用户创建的一些临时文件，而切换至es用户启动后，es用户没有权限删除或修改这些文件 # es用户没有修改文件的权限 FileNotFoundException: /var/es/logs/nanyu_server.json (权限不够) # 使用下面命令修改指定文件夹 cd /var/es chown es:es -R logs/ 1.3.4 安装Head插件 Head 插件就是一个集群监控和操作的一个可视化软件 ## 安装解压缩软件 [root@node01 es]# yum install zip unzip -y ## 安装http服务，用于访问head [root@node01 es]# yum install httpd -y ## 进入到html目录，上传head [root@node01 es]# cd /var/www/html ## 解压 [root@node01 html]# tar -zxvf elasticsearch-head-5.0.0.tar.gz ## 重命名 [root@node01 html]# mv elasticsearch-head-5.0.0 head ## 重启httpd服务 [root@node01 html]# systemctl restart httpd、 ## 修改es的配置文件 # 是否支持跨域 http.cors.enabled: true # 支持哪些域名，这里表示支持所有域名 http.cors.allow-origin: \"*\" http.cors.allow-credentials: true 测试是否安装成功： http://node01/head 1.3.5 安装Kibana Kibana实现数据可视化，其作用就是在ElasticSearch中进行分析。Kibana能够以图表的形式呈现数据，并且具有可扩展的用户界面，可以全方位的配置和管理ElasticSearch。 Kibana最早的时候是基于Logstash创建的工具，后被Elastic公司在2013年收购。 Kibana可以提供各种可视化的图表； 可以通过机器学习的技术，对异常情况进行检测，用于提前发现可疑问题； ## 解压 [root@node01 module]# tar -zxvf kibana-7.17.2-linux-x86_64.tar.gz ## 重命名 [root@node01 module]# mv kibana-7.17.2-linux-x86_64 kibana ## 修改配置文件 [root@node01 kibana]# vim config/kibana.yml # 访问端口 server.port: 5601 #主机地址 server.host: \"node01\" #ES集群地址 elasticsearch.host: [\"http://node01:9200\", \"http://node02:9200\", \"http://node03:9200\", \"http://node04:9200\", \"http://node05:9200\"] #kibana数据索引 kibana.index: \".kibana\" #语言环境 i18n.locale: \"zh-CN\" ##启动 "},"10-Spark/KafKa安装配置.html":{"url":"10-Spark/KafKa安装配置.html","title":"3. KafKa安装配置","keywords":"","body":"KAFKA安装配置 KAFKA压缩包下载： https://kafka.apache.org/downloads 1. 上传并解压压缩包 ## 1. 解压 [root@node01 apps]# tar -zxf kafka_2.12-2.7.1.tgz [root@node01 apps]# ls kafka_2.12-2.7.1 kafka_2.12-2.7.1.tgz [root@node01 apps]# rm -rf kafka_2.12-2.7.1.tgz [root@node01 apps]# mv kafka_2.12-2.7.1 kafka [root@node01 apps]# cd kafka [root@node01 kafka]# ls bin config libs LICENSE NOTICE site-docs 2. 环境配置 [root@node01 kafka]# mkdir logs [root@node01 kafka]# cd config/ ## 2. 修改Server端的配置 [root@node01 config]# vi server.properties ## 修改以下内容 ## 每一台broker必须有唯一的一个id【重点注意】 broker.id=1 ## 处理网络请求的线程数量 num.network.threads=3 ## 用来处理磁盘IO的线程数量 num.io.threads=8 ## 日志目录 log.dirs=/opt/module/kafka/logs ## 分区数 num.partitions=1 ## Zookeeper 地址【重点注意】 zookeeper.connect=node01:2181,node02:2181,node03:2181 ## 3. 远程复制到其他节点 [root@node01 module]# scp -r kafka root@node02:/opt/module/ [root@node01 module]# scp -r kafka root@node03:/opt/module/ ## 4. 修改其他节点的broker.id配置【node02修改为2，node03修改为3】 [root@node02 ~]# vim /opt/module/kafka/config/server.properties [root@node03 ~]# vim /opt/module/kafka/config/server.properties ## 5.配置Kafka环境变量：node01、node02、node03都需要 [root@node01 ~]# vim /etc/profile export KAFKA_HOME=/opt/apps/kafka export PATH=$PATH:$KAFKA_HOME/bin [root@node01 ~]# source /etc/profile ## 6. 启动服务端【注意：daemon是后台启动】 [root@node01 ~]# kafka-server-start.sh -daemon ${KAFKA_HOME}/config/server.properties [root@node02 ~]# kafka-server-start.sh -daemon ${KAFKA_HOME}/config/server.properties [root@node03 ~]# kafka-server-start.sh -daemon ${KAFKA_HOME}/config/server.properties ## 7. 查看集群状态 [root@node01 ~]# jps ****************************** ---------node01--------- 10308 DataNode 10612 ResourceManager 10900 NodeManager 10055 QuorumPeerMain 10199 NameNode 11289 HRegionServer 11833 Kafka 11133 HMaster 12045 Jps ---------node02--------- 10609 Kafka 10086 HMaster 10009 HRegionServer 9882 NodeManager 10778 Jps 9630 QuorumPeerMain 9694 DataNode 9775 SecondaryNameNode ---------node03--------- 9681 DataNode 9922 HRegionServer 9795 NodeManager 10550 Kafka 9623 QuorumPeerMain 9999 HMaster 10687 Jps ****************************** ## 8. 关闭集群 [root@node01 ~]# kafka-server-stop.sh stop [root@node02 ~]# kafka-server-stop.sh stop [root@node03 ~]# kafka-server-stop.sh stop "},"2-JavaWeb/1-BootStrap.html":{"url":"2-JavaWeb/1-BootStrap.html","title":"1. BootStrap","keywords":"","body":"1.1 BootStrap介绍 官网：点击下载 中文网：点击下载 Bootstrap是一套现成的CSS样式集合，是两个推特的员工干出来的。Bootstrap是最受欢迎的HTML、CSS和JS框架，用于开发响应式布局、移动设备优先的WEB项目。Bootstrap特别适合那种没有设计师的团队(甚至说没有前端的团队)，可以快速的出一个网页。 1.1.1 BootStrap特点 简洁、直观、强悍的前端开发框架，html、css、javascript工具集，让 web开发更速、简单。 基于html5、css3的bootstrap，具有大量的诱人特性：友好的学习曲线，卓越的兼容性，响应式设计，12列格网，样式向导文档。 自定义JQuery插件，完整的类库，bootstrap3基于Less，bootstrap4基于Sass的CSS预处理技术 Bootstrap响应式布局设计；让一个网站可以兼容不同分辨率的设备。Bootstrap响应式布局设计，给用户提供更好的视觉使用体验。 丰富的组件 1.2 下载与使用 BootStrap源码下载：点击下载 下载之后将Bootstrap源码中的dist中的css和js文件拷贝到我们的项目中。 由于bootstrap的js需要依赖于jquery.js才能使用，所以项目中还要引用jquery.js。 JQuery官网：点击进入 jquery.js下载：在下面url中替换成要下载的版本，进入页面页面后右键另存即可。 https://code.jquery.com/${jquery的版本} https://code.jquery.com/jquery-3.4.1.js 基本模板： 在线引入：需要电脑联网才能使用 Bootstrap 101 Template 你好，世界！ 离线引入：需要把源码下载下来，拷贝到项目中才能使用（常用） Bootstrap测试 你好，世界！ 如果只用到bootstrap的样式的话可以不用引入bootstrap.js和jquery.js，而只需要引入css即可，但如果需要使用其插件就需要引入。 viewport cmeta>标记用于指定用户是否可以缩放Web页面 width和height指令分别指定视区的逻辑宽度和高度。他们的值要么是以像素为单位的数字，要么是一个特殊的标记符号。 width 指令使用device-width标记可以指示视区宽度应为设备的屏幕宽度。 height指令使用device-height标记指示视区高度为设备的屏幕高度。 initial-scale指令用于设置Web页面的初始缩放比例。默认的初始缩放比例值因智能手机浏览器的不同而有所差异。通常情况下设备会在浏览器中呈现出整个Web页面，设为1.0则将显示未经缩放的Web文档, 1.3 布局容器与栅格系统 1.3.1 布局容器 .container：用于固定宽度并支持响应式布局的容器 固定布局，内容不会占满全屏，页面两端会有空白间距,并且是响应式布局 container-fluid：用于100%宽度布局，占据全部视口（viewport）的容器 会占据整个视口viewport，页面两端不会有空白间距 两种布局容器不能嵌套使用，但是同一种容器之间可以相互嵌套。 1.3.2 栅格系统 Bootstrap提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口(viewport)尺寸的增加，系统会自动分为最多12列。栅格系统用于通过一系列的行（row）)与列(column)的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。 网格系统的实现原理非常简单，仅仅是通过定义容器大小，平分12份(也有平分成24份或32份，但12份是最常见的)，再调整内外边距，最后结合媒体查询，就制作出了强大的响应式网格系统。Bootstrap框架中的网格系统就是将容器平分成12份。 使用顺序应该是container->row->xs (xsmall phones)/sm (small tablets)/md (middle desktops)/lg (larger desktops) xs/sm/md/lg分别对应超小屏(自动)，小屏(750px)，中屏(970px)和大屏(1170px)，几种样式可以同时使用，会根据屏幕大小响应式切换样式 .row必须包含在容器.container中，以便为其赋予合适的对齐方式和内距(padding). .row中可以添加列.column，只有列column才可以作为行容器.row的直接子元素，但列数之和不能超过平分的总列数，比如12。如果大于12,则自动换到下一行。 具体内容应当放置在列容器(column)之内 1.3.2.1 列组合 总列数能超过12，超过12后会自动换行，是全部换行。 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 如果总列数超过12了会自动换行 4 4 6 1.3.2.2 列偏移 如果我们不希望相邻的两个列紧靠在一起，但又不想使用margin或者其他的技术手段来。这个时候就可以使用列偏移(offset)功能来实现。使用列偏移也非常简单，只需要在列元素上添加类名col-md-offset.*(其中星号代表要偏移的列组合数)，那么具有这个类名的列就会向右偏移几个列数。例如，在列元素上添加col-md-offset-8 表示该列向右移动8个列的宽度(要保证列与偏移列的总数不超过12，不然会致列断，换行显示)。 4 4 1.3.2.3 列排序 列排序其实就是改变列的方向，就是改变左右浮动，并且设置浮动的距离。在Bootstrap框架的网格系统中是通过添加类名col-md-push-*和col-md-pull-*(其中星号代表移动的列组合数)。往前pull，往后push, 右移9格 4 4 4 左移5格 1.3.2.4 列嵌套 Bootstrap框架的网格系统还支持列的嵌套。可以在一个列中添加一个或者多个行row容器，然后在这个row中插入列。 7 5 6 6 1.4 常用样式 1.4.1 排版 1.4.1.1 标题 Bootstrap和普通的HTML页面一样，定义标题都是使用标签到，只不过Bootstrap覆盖了其默认的样式。使用其在所有浏览器下显示的效果一样。 为了让非标题元素和标题使用相同的样式，还特意定义了.h1~.h6六个类名。同时后面可以紧跟着一行小的副标题或使用.small 二级标题：第一种形式 二级标题：第二种形式 二级标题：第一种形式，副标题：第一种形式 二级标题：第二种形式， 副标题：第二种形式 1.4.1.2 段落 通过.lead来突出强调内容，其主要是增大文本字号，加粗文本而且对行高和margin也做相应的处理。可以使用以下标签给文本做突出样式处理： ：小号字 /：加粗字体 /：斜体 .lead的主要功能是增大文本字号，加粗文本而且对行高和margin也做相应的处理。 现在的你，一定会感激现在努力的自己。，加油 1.4.1.3 强调 定义了一套类名，这里称其为强调类名，这些强调类都是通过颜色来表示强调，具本说明如下: .text-muted：提示，使用浅灰色(#999) .text-primary：主要，使用蓝色(#428bca) .text-success：成功，使用浅绿色(#3c763d) .text-info：通知信息，使用浅蓝色(#31708f) .text-warning：警告，使用黄色(#8a6d3b) .text-danger：危险，使用褐色(#a94442) 提示信息，使用浅灰色(#999) 提示信息，使用蓝色(#428bca) 提示信息，使用浅绿色(#3c763d) 提示信息，使用浅蓝色(#31708f) 提示信息，使用黄色(#8a6d3b) 提示信息，使用褐色(#a94442) 1.4.1.4 对齐 在CSS中常常使用text-align来实现文本的对齐风格的设置。其中主要有四种风格: 左对齐，取值left 居中对齐，取值center 右对齐，取值right 两端对齐，取值justify 为了简化操作，方便使用，Bootstrap通过定义四个类名来控制文本的对齐风格: .text-left：左对齐 .text-center：居中对齐 .text-right：右对齐 .text-justify：两端对齐。 居中 左对齐 右对齐 两端对齐 1.4.1.5 列表 HTML中的列表： 无序列表：(...) 有序列表：（...） 定义列表：（......） 无序列表 无序列表 无序列表 无序列表 无序列表 无序列表 Html 超文本标记语言，学起来不难，用起来很棒 Java 编译型高级编程语言，知识体系很庞大，不是很好学 BootStrap中的列表： 去点列表：class=\"list-unstyled\" 无序列表 无序列表 无序列表 内联列表：class=\"list-inline\" 无序列表 无序列表 无序列表 自定义列表：class=\"dl-horizontal\" Html 超文本标记语言，学起来不难，用起来很棒 Java 编译型高级编程语言，知识体系很庞大，不是很好学 1.4.1.6 代码 在Bootstrap主要提供了三种代码风格：单行内联代码、多行代码、快捷键代码 使用来显示单行内联代码 单行内联代码演示：a code 使用来显示用户输入代码,如快捷键 快捷键：ctrl+s保存 使用来显示多行块代码 样式:：pre-scrollable (height.max-height高度固定，为340px，超过存在滚动条) 多行代码演示： public class HelloWorld{ public static void main(String [] args){ System.out.println(\"HelloWorld\") } } 当内容长度超过指定值时，可以加个滚动条 有序列表 有序列表 有序列表 有序列表 有序列表 有序列表 有序列表 有序列表 有序列表 有序列表 有序列表 有序列表 有序列表 有序列表 有序列表 有序列表 有序列表 有序列表 1.4.1.7 表格 Bootstrap为表格提供了1种基础样式和4种附加样式以及1个支持响应式的表格。在使用Bootstrap的表格中，只需要添加对应的类名就可以得到不同的表格风格： 基础样式： .table：基础表格 附加样式： .table-striped：斑马线表格 .table-bordered：带边框的表格 .table-hover：鼠标悬停高亮的表格 .table-condensed：紧凑型表格，单元格没内距或者内距较其他表格的内距小 tr、th、td样式： 类 描述 .actice 将悬停的颜色应用在行或者单元格上 .sucsess 表示成功的操作 .info 表示信息变化的操作 .warning 表示警告的操作 .danger 表示危险的操作 Java 数据库 Python JVM MySQL Flask 面向对象 Redis 数据分析 JVM MySQL Flask 面向对象 Redis 数据分析 1.4.2 表单 表单主要功能是用来与用户做交流的一个网页控件，良好的表单设计能够让网页与用户更好的沟通。表单中常见的元素主要包括:文本输入框、下拉选择框、单选按钮、复选按钮、文本域和按钮等。 1.4.2.1 表单控件 .form-control .input-lg：较大 .input-sm：较小 .form-control是每一个表单控件必须要加的 文本框input 下拉复选框select 请选择城市 上海 北京 浙江 请选择城市 上海 北京 浙江 文本域textare 复选框checkbox 垂直显示：.checkbox 水平显示：.chechbox-inline 篮球 乒乓球 游戏 学习 单选框：.radio 男 女 按钮：.button 使用button实现 ​ 基础样式：.btn ​ 附加样式：btn-primary btn-info btn-success btn-warning btn-danger btn-link btn-default 普通按钮 基础按钮 提示按钮 警告按钮 危险按钮 链接按钮 默认按钮 多标签支持：使用a、div等制作标签 div标签按钮 span标签按钮 a标签按钮 按钮大小 类名 说明 .btn-xs 超小按钮 .btn-sm 小型按钮 .btn-lg 超大按钮 超小按钮.btn-xs 小型按钮.btn-sm 正常按钮 超大按钮.btn-lg 按钮禁用 方式一：添加disabled属性 禁用按钮 方式二：在元素标签中添加disabled类，此方法只是在样式上禁用了，但实际上并没有禁用，可以通过JS或其他手段使用该按钮 禁用按钮 1.4.2.2 表单布局 基本的表单结构是Bootstrap自带的，个别的表单控件自动接收一些全局样式。下面列出了创建基本表单的步骤： 把标签和控件放在一个带有class.form-group的中。这是获取最佳间距所必需的。 向所有的文本元素、和添加class =\"form-control\" 1.4.2.2.1 水平表单 同一行显示用.form-horizontal，配合BootStrap框架的网格系统 姓名 密码 爱好 篮球 乒乓球 爱好 请选择城市 上海 北京 浙江 简介 提交 1.4.2.2.2 内联表单 姓名 密码 按钮 1.4.3 缩略图 缩略图在电商类的网站很常见，最常用的地方就是产品列表页面。缩略图的实现是配合网格系统一起使用。同时还可以让缩略图配合标题描述内容，按钮等。 天弘7号 来自于天弘星球，旁观者 喜欢 评论 南雨 出生于火星，保卫者 喜欢 评论 代号-Z 来自于狮子座星云，侵略者 喜欢 评论 王五 出生于金星，身份未知 喜欢 评论 1.4.4 面板panel 默认的.panel组件所做的只是设置基本的边框(border）和内补(padding)来包含内容。 panel-default：默认样式 panel-heading：面板头 panel-body：面板主体内容 明星合集 天弘7号 来自于天弘星球，旁观者 喜欢 评论 南雨 出生于火星，保卫者 喜欢 评论 代号-Z 来自于狮子座星云，侵略者 喜欢 评论 王五 出生于金星，身份未知 喜欢 评论 1.5 BootStrap 1.5.1 导航 使用下拉于按钮组合可以制作导航 要点： 基本样式：.nav与\".nav-tabs\"、\"nav-pills\"组合制作导航 分类： 标签型：nav-tabs导航 胶囊型：nav-pills导航 堆栈：nav-stacked导航 自适应：nav-justified导航，单独使用样式，不与nav一起使用，直接加入到ol、ul中即可，一般用于导航、主要起作用是告诉用户现在所处页面的位置。 状态：选中状态active；禁用状态disable 二级菜单 标签式导航 Home SVN IOS Java PHP 普通胶囊式导航 Home SVN IOS Java PHP 面包屑导航 Home SVN IOS Java PHP 1.5.2 分页导航 分页随处可见，分为页码导航和翻页导航 页码导航：ul标签上加pagination [pagination-lg | pagination-sm] 翻页导航： ul标签上加pager 1.5.2.1 页码导航 页码导航 &laquo; Home SVN IOS Java PHP &raquo; 翻页导航 上一页 下一页 1.5.3 下拉菜单 在使用BootStrap框架的下拉菜单时，必须使用两个js 使用要点： 使用一个类名为dropdown 或btn-group的div包裹整个下拉框: 默认向下dropdown。向上弹起加入.dropup即可 使用button作为父菜单，使用类名.dropdown-toggle和自定义data-toggle属性 在button中使用font制作下拉箭头 下拉菜单项使用一个ul列表，并且定义一个类名为.dropdown-menu 分组分割线:添加类名.divider来实现添加下拉分隔线的功能 分组标题：li添加类名.dropdown-header来实现分组的功能 对齐方式: dropdown-menu-left左对齐默认样式 dropdown-menu-right右对齐 激活状态.active和禁用状态.disabled 喜欢的视频 --搞笑-- 脱口秀 德云社 极限挑战 --儿童-- 大头儿子小头爸爸 喜羊羊与灰太狼 哆啦A梦 开心超人 1.5.4 模态框 模态框(Modal）是覆盖在父窗体上的子窗体。通常，目的是显示来自一个单独的源的内容，可以在不离开父窗体的情况下有一些互动，子窗体可提供信息、交互等。 1.5.4.1 用法 两种使用方式，一种自动打开（通过属性），一种手动打开，通过JS 通过data属性：在控制器元素(比如按钮或者链接)上设置属性 data-toggle=\"modal\"，同时设置data- target=\"#identifier\"或href=\"#identifier\"来指定要切换的特定的模态框(带有id=\"identifier\") 通过JavaScript：使用下面这种技术，可以通过JavaScript来调用带有id=\"identifier\"的模态框。 $(\"#identifier\").modal(option) 自动打开模态框 JS打开模态框 模态框头部 &times; 模态框内容.. 关闭 // 绑定点击按钮事件 $('#btn').click(function() { // 手动打开模态框 $(\"#myModal\").modal(\"show\"); }) "},"5-JavaScript/1-JS学习.html":{"url":"5-JavaScript/1-JS学习.html","title":"2. JS学习","keywords":"","body":"2.1 初识JavaScript 由布兰登艾奇发明，最初命名为LiveScript，最后与网景公司合作，改名为JavaScript(简称JS)，但JS与Java没有任何关系。 2.1.1 什么是JS JavaScript是世界上最流行的语言之一, 是一种运行在客户端的脚本语言( Script是脚本的意思) 脚本语言:不需要编译,运行过程中由js解释器(js引擎)逐行来进行解释并执行 现在也可以基于Node.js技术进行服务器端编程 2.1.2JS能做什么 表单动态校验 (密码强度检测) ( JS产生最初的目的) 网页特效 服务端开发(Node.js) 桌面程序(Electron) App(Cordova) 控制硬件-物联网(Ruff) 游戏开发(cocos2d-js) 2.1.3 JS/CSS/HTML区别与联系 描述类语言：HTML/CSS标记语言 HTML：html决定网页结构和内容（决定人看到什么），相当于人的身体。 CSS：CSS决定网页呈现给用户的样式，相当于人化妆、穿衣服。 编程类语言：JS脚本语言 JS：实现页面控制（决定功能）和业务逻辑，相当于人的各种动作。 2.1.4 浏览器执行JS原理 浏览器分成两部分:渲染引擎和JS引擎 渲染引擎:用来解析HTML与CSS ，俗称内核,比如chrome浏览器的blink ,老版本的webkit。 JS引擎:也称为JS解释器，用来读取网页中的JavaScript代码,对其处理后运行,比如chrome浏览器的V8。 浏览器本身并不会执行S代码，而是通过内置JavaScript引擎(解释器)来执行JS代码。 JS 引擎执行代码时逐行解释每一句源码(转换为机器语言) ，然后由计算机去执行,，以JavaScript语言归为脚本语言，会逐行解释执行。 2.1.5 JS三部分组成 ECMAScript: ECMAScript是由ECMA国际(原欧洲计算机制造商协会)进行标准化的一编程语言, 这种语言在万维网上应用广 泛，ECMAScript规定了JS的编程语法和基础核心知识,是所有浏览器厂商共同遵守的一套S语法工业标准。它往往被 称为JavaScript或JScript ，但实际上后两者是ECMAScript语言的实现和扩展，可简单理解为ECMAScript就是JS。 DOM-文档对象模型： 文档对象模型( Document Object Model ，简称DOM)，是W3C组织推荐的处理可扩展标记语言的标准编程接口。 通过DOM提供的接口可以对页面上的各种元素进行操作(大小、位置、颜色等)。 BOM-浏览器对象模型： 浏览器对象模型(Browser Object Model ，简称BOM)，是指浏览器对象模型，它提供了独立于内容的、可以与浏览 器窗口进行互动的对象B结构。通过BOM可以操作浏览器窗口,比如B弹出框、控制浏览器跳转、获取分辨率等。 2.1.6JS三种书写方式 JS有三种书写方式（与CSS相同），分别为行内式、内嵌式、外联式 行内式（一般不使用）： 内嵌式（使用最多）： alert('JS测试') 外联式： 2.1.7输入输出语句 prompt用法： // 用户输入框 prompt('请输入姓名'); alter用法： // 弹出框 alert('南雨'); console.log用法： // 输出到控制台，用于程序员观看分析 console.log('程序员观看'); 2.2变量 白话:变量就是一个装东西的盒子。 通俗:变量是用于存放数据的容器。我们通过变量名获取数据，甚至数据可以修改。 本质:变量是程序在内存中申请的一块用来存放数据的空间。 2.2.1 变量的使用 变量在使用时分为两部分：声明变量、赋值 变量使用方法一： //生命变量 var age; //给变量赋值 age=12; console.log('程序员:' + yourname + '观看'); 变量使用方法二： //声明变量并赋值 var age=12; alert(yourname); 变量使用方法三： // 用户输入框 var yourname = prompt('请输入姓名'); // 弹出框 alert(yourname); var是一个JS关键字，用来声明变量( variable变量的意思)。使用该关键字声明变量后，计算机会自动为变量分配内 存空间，不需要程序员管。 age是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间。 2.2.2 变量的使用 变量重新赋值： // 用户输入框 var yourname = prompt('请输入姓名'); // 输出到控制台，用于程序员观看分析 console.log( yourname); yourname = \"南雨\"; console.log(yourname); 申请多变量： var myname = \"钉子君\", age = 18, salary = 2000; console.log(myname); console.log(age); console.log(salary); 只声明变量不赋值： //只声明变量不赋值，系统无法识别，结果是undefined，未识别的 var myname console.log(myname); 不声明变量直接赋值： //不声明变量直接赋值，可以直接使用 myname=1000 console.log(myname); 变量值的交换： var temp; var qing = \"青苹果\" var hong = \"红苹果\" temp = qing; qing = hong; hong = temp; console.log(qing); console.log(hong); 2.2.3 变量的命名规范 由字母(A-Za-z)、数字(0-9)、 下划线( )、元符号($ )组成，如: usrAge, num01, name+ 严格区分大小写。var app；和var App；是两个变量 不能以数字开头。18age 是错误的 不能是关键字、保留字。例如: var、for、 while 变量名必须有意义。MMD BBD n|- → age . 遵守驼峰命名法。首字母小写,后面单词的首字母需要大写 myFirstName 2.3 数据类型 在计算机中,不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。 变量是用来存储值的所在处,它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算的 内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型,在程序运行过程中，类型会被自动确定。 // int num = 10; java var num;//这里的num我们是不确定属于哪种数据类型的 var num =10; // num属于数字型 //js的变量数据类型是只有程序在运行过程中，根据等号右边的值来确定的 在代码运行时，变量的数据类型是由JS引擎根据=右边变量值的数据类型来判断的，运行完毕之后，变量就确定了数据类型。 // js是动态语言变量的数据类型是可以变化的 varx=10;//x是数字型 x='pink';// x字符串型 2.3.1 数据类型分类 JS把数据类型分为两类: 简单数据类型( Number , String , Boolean, Undefined, Null ) 复杂数据类型( object) 简单数据类型： 数字型（Number）： var num=10;//num为数字型 var num=10.0//num数字型 //数字型最大值 var num=Number.MAX_VALUE //数字型最小值 var num=Number.MIN_VALUE //数字型三个特殊值 var num=Number.MAX_VALUE*2//结果为Infinity var num=Number.MIN_VALUE*2//结果为-Infinity var num=‘钉子君’-12//结果为NaN alert (Infinity) ;//Infinity ,代表无穷大,大于任何数值 alert(-Infinity) ; //-Infinity ,代表无穷小,小于任何数值 alert (NaN) ;//Not a number ,代表一个非数值 字符串型（String）： 字符串型可以是引号中的任意文本,其语法为双引号\"\"和单引号\"，因为HTML标签里面的属性使用的是双引号，JS这里我们更推荐使用单引号。 var strMsg = \"我爱北京天安门~\"; // 使用双引号表示字符串 var strMsg2 = '我爱吃猪蹄~'; // 使用单引号表示字符串 var strMsg3 = '我爱吃\"猪蹄\"~'; //‘ ’里面套“ ” var strMsg4 = \"我爱吃'猪蹄'~\"; //\" \"里面套 ' ' //常见错误 var strMsg3 =我爱大肘子;//报错，没使用引号,会被认为是js代码,但j s没有这些语法 布尔类型（boolean）： 布尔类型有两个值: true和false ，其中true表示真(对) ，而false表示假(错)。 //布尔型 var flag = true; var flag1 = false; //进行数学运算时，true代表的是1，false代表的是0 console.log(true + 1);//2 console.log(false + 1);//1 未定义类型(Undefined): 如果一个变量声明时未被赋值，则输出结果就是Undefined var age; console.log(age);//Undefined console.log(age+'pink');//Undefinedpink console.log(age + 1); // NaN(非数字) undefined 和数字相加最后的结果是NaN 空值类型(null): var age = null; console.log(age + 'pink');//nullpink console.log(age + 1);//1 转义字符： //字符串转义字符都是用 \\ 开头但是这些转义字符写道引号里面 varstr1=“我是个'高富帅'的\\n程序员\"; alert('大大大大大大大大大\\n小小小小小小小小小\\n\"收破烂啦~\"') 2.3.2 字符串length属性及拼接 字符串长度属性：length var len = \"钉子君\".length; alert(len); var str = \"南雨\"; alert(str.length); 字符串拼接： 多个字符串之间可以使用+进行拼接,其拼接方式为字符串+任何类型=拼接之后的新字符串 var len = \"钉子君\"; var str = \"南雨\"; console.log(len + \"喜欢\" + str + 2021);//钉子君喜欢南雨2021 console.log(12+12)//24 console.log(\"12\"+12)//1212 2.3.3 获取变量数据类型 typeof:typeof可用来获取检测变量的数据类型 var num = 10; console.log(typeof num);//number var str = \"pink\"; console.log(typeof str);//string var flag = true; console.log(typeof flag);//boolean var variable = undefined; console.log(typeof variable);//undefined var times = null; console.log(typeof times);//object //prompt获取到的值是字符串型的 var age=prompt(\"请输入年龄：\"); console.log(typeof age);//string 2.3.4 数据类型的转换 使用表单、prompt获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量 的数据类型。通俗来说，就是把一种数据类型的变量转换成另外一种数据类型。 编程中通常有三种形式的转换：转换为字符串类型、转换为数字型、转换为布尔型 2.3.4.1 其他类型转换为字符串类型： var str = 10; console.log(typeof str);//number console.log(str.toString());//10 console.log(typeof str.toString());//string console.log(String(str));//10 console.log(typeof String(str));//string 2.3.4.2 其他类型转换为数字类型： var str = \"10.0\"; var str1 = \"120px\"; var str2 = \"rem120px\"; console.log(typeof str);//string console.log(parseInt(str));//10 console.log(parseInt(str1));//120 console.log(parseInt(str2));//NaN console.log(typeof parseInt(str));//Number console.log(parseFloat(str));//10.0 console.log(typeof parseFloat(str));//Number console.log(typeof Number(str));//Number //隐式转换 console.log(str - 0);//10 console.log(typeof (str - 0));//Number console.log(\"120\" - \"110\");//10 console.log(\"120\" * 1);//120 2.3.4.3 其他类型转换为布尔类型： 代表空、否定的值会被转换为false，如\"、 0、NaN、 null undefined 其余值都会被转换为true console.log(Boolean(''));//false console.log(Boolean(0));//false console.log(Boolean(\"12\"));//true console.log(Boolean(undefined));//false console.log(Boolean(null));//false console.log(Boolean(NaN));//false console.log(Boolean(12));//true 2.4 扩展内容 编译语言与解释语言的区别： 计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能 执行程序。程序语言翻译成机器语言的工具，被称为翻译器。 翻译器翻译的方式有两种: 一个是编译，另外一个是解释。两种方式之间的区别在于翻译的时间点不同 编译器是在代码执行之前进行编译，生成中间代码文件（比如Java语言，执行代码时会用编译器编译成javac.class临时文件，当代码全部编译成javac.class文件后，再用解释器进行解释） 解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候,也称之为解释器)（比如JS语言，JS每读取一行代码，就直接被解释器解释） 类似于请客吃饭: 编译语言:首先把所有菜做好，才能上桌吃饭 解释语言:好比吃火锅，边吃边涮，同时进行 2.5 运算符 运算符( operator )也被称为操作符，用于实现赋值、比较和执行算数运算等功能的符号。 JS中常用运算符：算数运算符、递增和递减运算符、比较运算符、逻辑运算符、赋值运算符 2.5.1 算数运算符 概念:算术运算使用的符号，于执行两个变量或值的算术运算。 console.log(1 + 1);//2 console.log(1 - 1);//0 console.log(1 / 1);//1 console.log(1 * 2);//2 console.log(4 % 2);//0 console.log(5 % 3);//2 console.log(3% 5;//3 浮点数计算时有精度问题： 浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。不能直接用浮点数来判断是否相等 console.log(0.1 + 0.2);//0.30000000000000004 console.log(0.07 * 100);//7.000000000000001 2.5.2 自增与自减 如果需要反复给数字变量添加或减去1 ,可以使用递增( ++ )和递减( -- )运算符来完成。 在JavaScript中，递增( ++ )和递减( -- )既可以放在变量前面，也可以放在变量后面。放在变量前面时，我们可以称为前置递增(递减)运算符，放在变量后面时，我们可以称为后置递增(递减)运算符。 注意：递增和递减运算符必须和变量配合使用。 递增： 前置递增与后置递增单独使用时没有任何区别，但当他们用于其他情况时产生的结果就不一样了 前置递增： 先加1，后返回值。 var age=10; ++age;//类似于age=age+1 console.log(age);//11 console.log(++age +10)//21 后置递增： 先后返回原值，后加1。 var age=10; age++;//类似于age=age+1 console.log(age);//11 console.log(age++ +10)//20 2.5.3 比较运算符 概念：比较运算符(关系运算符)是两个数据进行比较时所使用的运算符，比较运算后会返回一个布尔值( true / false )作为比较运算的结果。 console.log(18 == '18'); console.log(15 >= 18); // 左右的18数据类型不同 console.log(18 === '18'); 2.5.4 逻辑运算符 概念：逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断。 逻辑中断（短路与）： 逻辑与短路运算：如果表达式1结果为真，则返回表达式2，如果表达式1为假，那么返回表达式1。 console.log(123&&456);//456 console.log(0&&456);//0 console.log(0&&1+23&&4*56);//0 console.log(null&&1+23&&4*56);//null console.log(''&&1+23&&4*56);//'' 逻辑中断（短路或）： 逻辑或短路运算：如果表达式1结果为真，则返回的是表达式1，如果表达式1结果为假，则返回表达式2 console.log(123||456);//123 console.log(0||456);//456 console.log(0||4*56);//4*56 console.log(null||4*56);//4*56 2.3.5 赋值运算符 2.6 流程控制 在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码 的执行顺序来实现我们要完成的功能。 简单理解:流程控制就是来控制我们的代码按照什么结构顺序来执行 流程控制主要有三种结构，分别是顺序结构、分支结构和循环结构， 这三种结构代表三种代码执行的顺序。 顺序流程控制：顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行。 分支流程控制：由上到下执行代码的过程中，根据不同的条件,执行不同的路径代码(执行代码多选-的过程) ，从而得到不同的结果 if(条件表达式){ //条件成立时执行的代码语句 }else if(条件表达式){ //条件成立时的语句 }else{ //条件不成立时的表达式 } 2.执行思路如果if里面的条件表达式结果为真true，则执行大括号里面的执行语句。如果if条件表达式结果为假，则不执行大括号里面的语句，则执行if语句后面的代码。 //if语句 if(2>1){ console.log('你好'); } //if else语句 if(2>1){ console.log('你好'); }else{ console.log('你不好'); } 三元表达式：条件表达式？表达式1 ：表达式2 如果条件表达式结果为真，则返回表达式1的值，如果条件表达式结果为假，则返回表达式2的值 var num=10; num>5 ? '是的':'不是的'; 分支流程控制语句： switch语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的特定值的选项 时，就可以使用switch。 //语法结构,break不可省略 switch(表达式){ case value1: break; case value2: break; default; } //实例，break不可省略,case值与switch值必须全等（即类型与数值都相等） var num=2; switch(num){ case 1; console.log('这是1'); break; case 2; console,log('这是2'); break; default; console.log('啥也不是'); } 2.7 循环控制 三种主要循环：for循环、while循环、do while循环 在程序中，一组被重复执行的语句被称之 为循环体，能否继续重复执行，取决于循环的终止条件。由循环体 及循环的终止条件组成的语句，被称之为循环语句 2.7.1 for循环 //语法结构 for(初始化变量;条件表达式;循环表达式){ //循环语句 } //实例 for(var i=0;i 双重for循环 很多情况下，单层for循环并不能满足我们的需求，比如我们要打印一个5行5列的图形、打印一个倒直角三角形 等，此时就可以通过循环嵌套来实现。循环嵌套是指在一个循环语句中再定义一个循环语句的语法结构，例如在 for循环语句中，可以再嵌套一个for循环，这样的for循环语句我们称之为双重for循环。 //双重for循环语法结构 //外循环一次，里循环执行全部 for(外层初始化变量;外层条件表达式;外层的操作表达式){ for(里层初始化变量;里层条件表达式;里层的操作表达式){ //循环语句 } } for(var i=0;i 2.7.2 while循环 //语法结构 当 成立的是时候，执行循环语句 while(条件表达式){ 循环体 } //当表达式结果为true时，执行循环体，否则则退出 var age = prompt('请输入年龄') - 0; while (age 2.7.3 do while循环 do... while语句其实是while语句的一一个变体。该循环会先执行次代码块 ，然后对条件表达式进行判断，如果条件 为真，就会重复执行循环体，否则退出循环。 //do while循环语法结构 do{ //循环体 }while(条件表达式) //与while循环的不同之处在于它会先执行一遍循环体再执行条件表达式，如果条件为真，则继续执行，如果条件为假，则退出循环 var age = prompt('请输入年龄') - 0; do { alert('禁止'); age++; } while (age 2.7.4 continue关键字 continue关键宇用于立即跳出本次循环，继续下一次循环(本次循环体中continue之后的代码就会少执行一次)。例 如，吃5个包子，第3个有子，就扔掉第3个，继续吃第4个第5个包子，其代码实现如下: for (var i = 0; i 2.7.5 break关键字 break关键字用于立即跳出整个循环(循环结束)。例如,吃5个包子，吃到第3个发现里面有半个虫子，其余的不吃了，其代码实现如下: for (var i = 0; i 2.8 数组 数组是指一组数据的集合 ，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一种将一组 数据存储在单个变量名 下的优雅方式。 数组可以把一组相关的数据一 起存放，并提供方便的访问(获取)方式。 //数组：即一组数据的集合，储存在单个变量下的优雅方式 //利用new创建数组 var arr=new Arrary();//空数组 //使用数组字面量来创建数组 var arr2=[];//空数组 var arr1=[1,2,3,4,5,'hahaha',true] 数组的字面量是方括号[ ]，声明数组并赋值称为数组的初始化。 2.8.1数组的访问 var arr = new Array();//创建了一个空数组 arr = [1, 2, 5, '钉钉']; console.log(arr);//[1, 2, 5, \"钉钉\"]0: 1 /* 1: 2 2: 5 3: \"钉钉\" length: 4 __proto__: Array(0)*/ 数组的索引： var arr = new Array();//创建了一个空数组 arr = [1, 2, 5, '钉钉']; console.log(arr[0]);//1 2.8.2数组的遍历 var arr = ['迪丽热巴', '鹿晗', 1, 2] for (var i = 0; i 2.8.3 spilt的使用方法 var str = 'nihao nihaoma 1'; var arr = str.split(' ');//通过' '将字符串切割为数组 for (var i = 0; i 2.8.4 数组属性的修改 //修改数组长度（扩容数组） var arr=[1,2,3]; console.log(arr.length);//3 arr.length=5;//扩容数组 //修改数组索引 arr[3]=4;//新增元素 arr[4]=5;//新增元素 arr[1]=6;//修改索引为1的元素 //修改数组的数据类型 arr='优点意思'//不能直接给数名复制，否则会替换掉之前数组中的内容。 console.log(arr);//有点意思 2.8.5 数组实操 筛选出大于10 的数组元素 var arr = [1, 2, 3, 6, 8, 4, 23, 56, 6, 34, 76]; var newarr = new Array(); for (var i = 0, j = 0; i 10) { newarr[j] = arr[i]; j++; } } for (var k = 0; k 删除指定数组元素 var arr = [0, 56, 3, 3, 78, 0, 67, 0, 0, 67, 34]; var newarr = new Array(); for (var j = 0, i = 0; i 翻转数组 var arr = [1, 2, 3, 4, 5, 6]; var newarr = []; for (var i = arr.length - 1; i >= 0; i--) { newarr[newarr.length] = arr[i]; } console.log(newarr); 冒泡排序 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就 把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算 法的名字由来是因为越小的元素会经由交换慢慢浮“到数列的顶端。 var arr = [3, 5, 7, 9, 0, 1, 4]; for (var i = 0; i arr[j + 1]) { var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } console.log(arr); 2.9 函数 在JS里面,可能会定义非常多的相同代码或者功能相似的代码,这些代码可能需要大量重复使用。虽然for循环语句也 能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用JS中的函数。 函数:就是封装了一段可被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用。 2.9.1 函数的使用 函数的使用分为两部分：声明函数和调用函数 函数的使用： //声明函数方法一 function 函数名(){ //函数体（代码块） } //实例 function sayHi(){ consolge.log('Hi'); } //声明函数方法二 var 变量名=function(){ } //实例 var fun=function(num){ console.log('我是函数表达式'); } 注意： function为声明函数的关键字，全部为小写 函数是做某件事情，函数名一般为动词 函数如果不被调用，自己是无法执行的 函数的调用： //函数名（） sayHi(); //实例 //声明函数 function getSum() { var sum = 0; for (var i = 1; i 注意： 调用函数时一定要加(); 2.9.2 函数的封装 函数的封装是把一个或者多 个功能通过函数的方式封装起来，对外只提供一个简单的函数接口 2.9.3 函数的参数 形参与实参： //函数声明时，（）里是形参 function getSum(形参1,形参2,形参3){ //代码块 } //调用时，传递的为实参 function cook(food){//food为形参 } food('西红柿炒鸡蛋');//西红柿炒鸡蛋为实参 2.9.4 函数形参与实参不匹配问题 在JS中，形参的默认值为undefinded。 function getSum(num1,num2,num3){ console.log(num1+num2); } getSum(1,2,3)//3 getSum(1,2)//3 getSum(1)//NaN getSum(1, 2, 3, 4);//3 2.9.5 函数的返回值return //函数的返回值格式 //function 函数名(){ return 需要返回的值 } //函数知只是实现某种功能，最终的结果需要返回给函数的调用者 function getResult(num){ return num; } console,log(getResult(666)); function getSum(num1,num2){ return num1+num2; } console.log(getSum(1,4)); 2.9.6 return使用时的注意事项 //1.return为终止位置，return之后的代码不会被执行 function getSum(num1,num2){ return num1+num2; alert('111');//不会被执行，return之后的代码不会被执行 } //2.return只能返回一个值 function getSum(num1,num2){ return num1,num1+num2;//只返回num1+num2的结果 } //3.如果函数中有return，则返回return后的值，如果没有则返回undefined function fun1(){ return 666; } fun1();//返回666 function fun2(){ } fun2();//返回值为undefined 2.9.7 argument的使用 当我们不确定有多少个参数传递的时候，可以用arguments来获取。在JavaScript中， arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个arguments对象， arguments对象中存储了传递的所有实参。 argument的使用： function fun(){ console.log(arguments)//里面存储了所有传递过来的实参 } fun(1,2,3,4)//返回[1,2,3,4]伪数组 function fun1(){ for(var i=0;i 伪数组： 具有数组的length属性 按照数组的索引进行存储 没有真正数组的一些方法，比如pop()、push() 2.9.8 函数封装冒泡排序 function sort(arr) { for (var i = 0; i arr[j + 1]) { var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } return arr; } var arr1 = sort([1, 4, 3, 8, 5]); console.log(arr1); 3 作用域 通常来说,，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个 名字的作用域。作用域的使用提高了程序逻辑的局部性,增强了程序的可靠性,减少了名字冲突。 3.0.1 全局变量与局部变量 JS的作用域：全局作用域、局部作用域 //全局作用域（在整个代码中都会起作用） var num=10; //在函数内部就是局部作用域，只在函数内部起作用 function fun(){ var num1=10; } 从执行效率来看全局变量和局部变量 全局变量只有浏览器关闭的时候才会销毁，比较占内存资源 局部变量当我们程序执行完毕就会销毁， 比较节约内存资源 3.0.2 块级作用域 if(i 3.1 预解析 JS引擎运行JS代码时分为：预解析、代码执行 预解析JS引擎会把JS里面所有的var还有function，提升到当前作用域的最前面。 预解析分为：变量预解析(变量提升 )和函数预解析( 函数提升) 变量提升：就是把所有的变量声明提升到当前的作用域最前面不提升赋值操作 函数提升：就是把所有的函数声明提升到当前作用域的最前面但不调用函数 须注意点： //情形一 console.log(num);//结果报错 //情形二 变量提升var num提升到最前边，但不提升赋值 console.log(num);//结果为undefined var num=10; //情形三 函数提升 fun();//结果为10 function fun(){ console.log(10); } //情形四 变量提升，提升var fun,但不提升后边的function（） fun();//结果报错 var fun=function(){ console.log(10); } 3.2 JS对象（Object） 什么是对象？ 现实生活中：万物皆对象，对象是一个具体的事物 ，看得见摸得着的实物。例如，一本书、一辆汽车、 一个人 可以是”对象”，一个数据库、一张网页、 一个与远程服务器的连接也可以是“对象”。 在JavaScript中，对象是一组无序的相关属性和方法的集合 ，所有的事物都是对象，例如字符串、 数值、数 组、函数等。对象是由属性和方法组成的。 属性:事物的特征，在对象中用属性来表示(常用名词) 方法:事物的行为，在对象中用方法来表示(常用动词) 为什么需要对象？ 保存一个值时，可以使用变量，保存多个值( 一组值)时，可以使用数组。如果要保存一个人的完整信息（身高、体重和、年龄等属性）呢? 例如： 用数组储存钉子君的各种属性 var person=['钉子君',''男\",21,175,147];//不合适，表述不清楚 用对象储存钉子君的属性 dingzijun.名字= '钉子君'； person.name='钉子君'； dingzijun.性别='男'； person.sex='男'； dingzijun.年龄=21 ; person.age=21 ; dingzijun.身高=175; person.height=175; 3.1.1 创建对象的三种方式 利用字面量创建对象 对象字面量：即花括号{}里面包含了表达这个具体事物（对象 ）的属性和方法 //创建对象 var obj = { //键值对的形式，多个属性之后用 ， 隔开 uname: '钉子君', age: 21, uheight: 175, uweight: 147, //方法冒号后面跟匿名函数 sayHi: function () { console.log('这是' + num + '呀！'); } } //调用对象中的方法 obj.sayHi(2); //调用对象中的属性 console.log(obj.age); //第二种调用方式 console.log(obj['age']); 利用new object创建对象 new object创建对象：与创建数组 new Arrary（）原理类似 //创建对象 var obj = new Object(); //添加属性 obj.uname = '钉子君'; obj.age = 21; obj.uheight = 175; obj.sayHi = function (num) { console.log('这是' + num + '呀！'); } //调用对象 console.log(obj.age); obj.sayHi(2); 利用构造函数来创造对象 使用上述两种方法一次只能创建一个对象，具有一定的局限性，因此可以利用函数的方法将属性封装如函数中，即为构造函数。 构造函数：将对象里面相同的属性和方法抽象出来封装到函数里 //使用方法 function start(属性1,属性2){ this.属性1=属性1; this.属性2=属性2; } //调用 new start(实参1,实参2) function(uname,age,sex){ this.name='刘德华 this.sex='男' this.age=18 this.sang=function(sang){ console.log(sang) } } var ldh=new start('刘德华',18,'男','冰雨') console.log(typeof ldh)//object console.log(ldh.age)//18 ldh.sang('冰雨') 3.1.2 遍历对象 for - in 遍历对象 for(变量in对象){ } //实例 var obj={ name:'钉子君'; age:18 sex:'男'; } for(var k in obj){ console.log(k);//结果为属性名 console.log(obj[k]);//结果为属性值 } 3.3 JS内置对象 JS中的对象分为:内置对象 、自定义对象、浏览器对象 内置对象：指JS语言自带的对象，这些对象供开发者使用，并提供了一些常用的或是最基本必要的功能 3.3.1 查阅文档 MDN：https://developer.mozilla.org/zh-CN/ 3.3.2 内置对象Math //内置对象Math的几种方法 Math.PI //圆周率 Math.floor();//向下取整 Math.ceil();//向上取整 Math.round();//四舍五入取整 Math.abs();//绝对值 Math.max();//最大值 Math.min();//最小值 Math.random();//返回一个[0,1)之间的随机数 3.3.3 内置对象Date 日期对象必须通过构造函数来创建（即通过new关键字来创建） //构造日期对象函数 //若Date（）里无参数，则返回系统的当前时间 var date = new Date(); console.log(date); //若有参数，在参数写法如下 var date1=new Date(2021,2,22);//数字型 console.log(date);//返回的是3月，不是2月 var date1=new Date('2020-2-22 8:8:8');//字符串型 console.log(date);//返回的是2月 格式化日期格式 var date = new Date(); console.log(date.getFullYear());//返回当前日期的年 var date1 = new Date(); console.log(date1.getMonth()+1);//返回当前月份，不过返回的月份比当前的月份小一个月（国外原因），因此需要加1 获得时间戳 var date=new Date(); console.log(valueOf());//获得现在到1970年的毫秒数 console.log(getTime());//获得现在到1970年的毫秒数 console.log(Date.now());//获得现在到1970年的毫秒数 时间戳转换为时分秒格式 var nowTime= +new Date();//获取当前的毫秒数（时间戳） var times=nowTime/1000//获取总的秒数 var day=parsentInt(times/60/60/24);//获取天数（整数） var hours=parsentInt(times/60/60%24);//获取小时数（整数） var mintues=parsentInt(times/60%60);//获取分钟数（整数） var seconds=parsentInt(times%60);//获取当前秒数（整数） 3.3.4 内置对象Array 检测是否为数组 var arr=[];//数组 var obj={};//对象 cosole.log(arr instanceof Array);//true 为数组 cosole.log(obj instanceof Array);//false 不为数组 Array.isArray(arr);//ture 为数组 Array.isArray(obj);//false 不为数组 在数组末尾添加数组元素 var arr=[1,2,3];//数组 arr.push(1,'丁')//在数组末尾新增两个数组元素，返回数组的长度 在数组开头添加数组元素 var arr=[1,2,3];//数组 arr.unshift(1,'丁')//在数组开头新增两个数组元素，返回数组的长度 删除数组的最后一个元素 var arr=[1,2,3];//数组 arr.pop()//删除数组最后一个元素，一次只能删除一个，返回的结果为被删除的元素 删除数组的第一个元素 var arr=[1,2,3];//数组 arr.shift()//删除数组第一个元素，一次只能删除一个，返回的结果为被删除的元素 数组排序 var arr=[1,2,3];//数组 Array.reverse();//数组翻转3,2,1 var arr=[4,2,3];//数组 arr.sort();//数组排序2,3,4 数组索引 var arr=[1,2,3];//数组 console.log(arr.indexOf(1));//返回结果为0 console.log(arr.indexOf(5));//找不到元素，返回结果为-1 console.log(arr.latindexOf(1));//从后面开始查找，但结果不变，返回结果为0（与indexOf（）效果一样） 数组转换为字符串 var arr=[1,2,3];//数组 console.log(arr.toString());//1,2,3 使用toString（）转化 console.log(arr.join());//1,2,3 使用join（）转化 console.log(arr.join('-'));//1-2-3 使用join（）转化，可自定义分隔符 其他方法 3.3.5 内置对象字符串 基本包装数据类型 var str='ding'; //把简单数据类型包装成为复杂数据类型 var temp=new String('ding'); //把临时变量赋值给str str=temp; //销毁临时变量 temp=null; 字符串不可变性 var str='ding'; str='nanyu'; console.log(str);//nanyu 字符串的不可变指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，每次对字符串的操作完成都会返回一个新的字符串（开辟了一个新的地址）。 var str=''; for(var i=0;i根据字符返回字符的位置 字符串操作方法 3.4 简单数据类型与复杂数据类型 简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。 值类型︰简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型。string , number , boolean , undefined , null。其中简单数据类型null返回的是一个空的对象object var times=null; console.log(typeof times);//object 引用类型∶复杂数据类型，在存储时变量中存储的仅仅是地址(引用)，因此叫做引用数据类型通过new关键字 创建的对象（系统对象、自定义对象），如Object、Array、Date等 3.4.1 堆和栈 堆空间和栈空间分配区别 1、栈(操作系统）︰由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。简单数据类型存放到栈里面 2、堆（操作系统）∶存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型存放到堆里面 3.4.2 简单数据类型内存分配 值类型（简单数据类型) : string , number , boolean , undefined , null 值类型变量的数据直接存放在变量(栈空间)中 简单数据类型直接存放在栈中，存放的是值。如下图中的age就是简单数据类型 引用类型(复杂数据类型)∶通过new关键字创建的对象（系统对象、自定义对象），如Object、Array、Date等。 引用类型变量（栈空间)里存放的是地址，真正的对象实例存放在堆空间中 复杂数据类型首先在栈中存放地址（十六进制表示），然后这个地址再指向堆中的值。如下图中的数组。 3.4.3 简单数据类型传参 3.4.4 复杂数据类型传参 3.5 WebAPIs 3.5.1 Web APIs与JS基础的关联性 JS的组成： 在JS基础阶段学习的主要是ECMAScript，而Web APIs阶段主要学习DOM和BOM。 JS的基础阶段： 学习的是ECMAscript标准规定的基本语法 要求掌握Js基础语法 只学习基本语法，做不了常用的网页交互效果 目的是为了Js 后面的课程判基础、做铺垫 Web APIs阶段： web APIs是w3c组织的标准 web APIs 主要学习DOM和BOM web APIs是JS所独有的部分 主要学习页面交互功能 需要使用Js基础的课程内容做基础 JS基础学习ECMAscript基础语法为后面作铺垫，WEB API是JS的应用，大量使用JS基础语法做交互效果 3.5.2 API与Web API API： APl( Application Programming Interface,应用程序编程接口)是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。 简单理解︰API是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能。 Web API： Web API是浏览器提供的一套操作浏览器功能和页面元素的API( BOM和DOM)。现阶段我们主要针对于浏览器讲 解常用的API，主要针对浏览器做交互效果。 比如我们想要浏览器弹出一个警示框，直接使用alert(‘弹出’) MDN API参考：https://developer.mozilla.org/zh-CN/docs/Web/API 总结： API是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结内部何实现. Web API主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果。 Web API一般都有输入和输出（函数的传参和返回值），Web API很多都是方法（函数），比如alert()方法。 学习Web API可以结合前面学习内置对象方法的思路学习 3.6 DOM 什么是DOM： 文档对象模型(Document Object Model，简称DOM)，是W3C组织推荐的处理可扩展标记语言(HTML或者XML )的标准编程接口。 W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式。 DOM树： 文档：一个页面就是一个文档，DOM中使用document表示 元素：页面中的所有标签都是元素，DOM中使用element表示 节点︰网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示 3.6.1 获取元素 DOM在我们实际开发中主要用来操作元素。 如何来获取页面中的元素呢? 获取页面中的元素可以使用以下几种方式: 根据ID获取 根据标签名获取 通过HTML5新增的方法获取 特殊元素获取 3.6.1.1 根据ID获取元素 钉子君 //get 获得 Elemnet 元素 BYId 通过Id 驼峰命名法 //里面的参数是大小写敏感的字符串 //返回的元素是一个对象 var timer = document.getElementById('time'); console.log(timer); //返回结果 钉子君 console.log(typeof timer); //object //打印我们返回的元素对象，更好的查看里面的属性和方法 console.dir(timer); 3.6.1.2 根据标签名获取 使用getElementsByTagName()方法可以返回带有指定标签名的对象的集合。 作业雨疏风骤，浓睡不消残酒 作业雨疏风骤，浓睡不消残酒 作业雨疏风骤，浓睡不消残酒 //返回的是获取过来元素对象的集合以伪数组的形式存储的 var result = document.getElementsByTagName('li'); console.log(result); console.log(result[0]);//获取第一个li标签里的内容 console.log(result[0]); //获取第一个li标签里的内容 for (var i = 0; i 因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。得到元素对象是动态的 获取某一父元素内指定的子元素 复杂版： 昨夜雨疏风骤 昨夜雨疏风骤 昨夜雨疏风骤 浓睡不消残酒 浓睡不消残酒 浓睡不消残酒 //如果想获取的是ol里面的li标签，而不要ul里面的 var ol = document.getElementsByTagName('ol'); //先通过ol标签名获取所有ol标签（存入数组中），又因为文档中只有一个ol标签，因此数组中的下标为0返回的是一个数组对象 console.log(ol[0].getElementsByTagName('li')); //再通过ol[0]获得整个ol标签，最后通过父元素来获得li标签 简单版： 昨夜雨疏风骤 昨夜雨疏风骤 昨夜雨疏风骤 浓睡不消残酒 浓睡不消残酒 浓睡不消残酒 //为父元素加个id，通过id获取父元素对象 var ol=document.getElementsByTagName('ol'); //再通过父元素对象，获得子元素标签 console.log(ol.getElementsByTagName('li')); 3.6.1.3 H5新增获取元素 通过类名获得标签元素 盒子1 盒子2 //根据类名获取元素 var box = document.getElementsByClassName('box1'); console.log(box); H5新增方法（query'Selector） 返回指定选择器的第一个元素对象 盒子1 盒子2 昨夜雨疏风骤 昨夜雨疏风骤 昨夜雨疏风骤 //H5新增方法querySelector var firstbox = document.querySelector('.box'); //类选择器 var firstol = document.querySelector('#ol'); //id选择器 返回指定选择器的所有对象 盒子1 盒子2 昨夜雨疏风骤 昨夜雨疏风骤 昨夜雨疏风骤 //H5新增方法querySelector var firstbox = document.querySelectorAll('.box'); //类选择器 var firstol = document.querySelectorAll('#ol'); //id选择器 3.6.1.3 获取body元素 var getBody = document.body; console.log(getBody); 3.6.1.4 获取html元素 var getHtml = document.documentElement; console.log(getHtml); 3.6.2 事件基础 事件概念：（触发---响应机制） JavaScript使我们有能力创建动态页面，而事件是可以被JavaScript侦测到的行为。 网页中的每个元素都可以产生某些可以触发JavaScript的事件，例如，我们可以在用户点击某按钮时产生一个事件，然后去执行某些操作。 事件有三部分组成（事件三要素）：事件源、事件类型、事件处理程序 事件源：事件被触发的对象 事件类型：如何触发？什么事件？比如鼠标点击（onclick）还是鼠标经过，还是键盘按下 事件处理程序：通过一个函数赋值的方式完成 比如点击一个按钮，弹出对话框 //事件源 var btn = document.getElementById('btn'); btn.onclick事件类型（点击） btn.onclick = function() { //事件处理程序 弹出对话框 alert('南雨'); } 3.6.2.1 执行事件的步骤 获取事件源 注册事件（绑定事件） 添加事件处理程序（采取函数赋值的形式） 123 //获取事件源 var div=document.querySelector('div'); //注册事件（绑定事件） div.onclick //添加事件处理程序（采取函数赋值的形式） div.onclick= function(){ alert('我被选中了'); } 常见鼠标事件 3.6.3 操作元素 JavaScript的DOM操作可以改变网页内容、结构和样式，我们可以利用DOM操作元素来改变元素里面的内容、属性等。注意以下都是属性 3.6.3.1 改变元素内容 从起始位置到终止位置的内容,但它去除 html标签，同时空格和换行也会去掉 element.innerText 起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行``` element.innerHTML element.innerText 显示当前系统时间 当前时间 //需求 当点击按钮，div里面的时间会发生变化 //获取元素（事件源） var btn = document.querySelector('button'); var div = document.querySelector('div'); //注册事件 btn.onclick = function() { var timer = new Date(); div.innerText = timer; } 元素可以不添加事件(只要刷新页面就会执行) //不用注册事件 var p = document.querySelector(\".p1\"); p.innerText = getDate(); element.innerHTML与element.innerText的区别 element.innerHTML不识别Html标签，非标准 innerHTML可以识别引号里面的HTML标签 测试 var test = document.querySelector('#test'); test.innerHTML = '今天是：2021年'; element.innerText识别Html标签，W3S标准 innerText不可以识别引号里面的HTML标签 测试 var test = document.querySelector('#test'); test.innerTests = '今天是：2021年'; 这两个属性是可读取的 可以获取元素里面的内容 我是用来测试的 我也是 var p = document.querySelector('p'); console.log(p.innerText);//innerText会去除空格和标签 我是用来测试的 我也是 console.log(p.innerHTML);//会空格和标签 /**我是用来测试的 我也是**/ 3.6.3.2 常用元素的属性操作 案例一：通过点击不同的图片，会展示出不同的图片。 钉子君 南雨 var ding = document.querySelector('.ding'); var yu = document.querySelector('.yu'); var img = document.querySelector('img'); ding.onclick = function() { img.src = 'image/ding.jpg';//修改图片链接属性 img.alt = '这是钉子君'; } yu.onclick = function() { img.src = 'image/yu.png';//修改图片链接属性 img.alt = '这是我老婆'; } 案例二：根据不同的时间显示不同的图片，不同的问候语 //获取图片元素 var img = document.querySelector('img'); //获取时间对象 var nowTime = new Date(); //获取时间格式 function getHour() { var nowhour = nowTime.getHours(); return nowhour; } // console.log(getHour()); if (getHour() 3.6.3.3 表单属性修改 按钮 var btn = document.querySelector('button'); var input = document.querySelector('input'); btn.onclick = function() { input.value = '皮一下'; //修改input中的value属性 btn.disabled = true; //禁用点击 } 仿登录隐藏密码案例： "},"3-MySql/1-Mysql基本语句.html":{"url":"3-MySql/1-Mysql基本语句.html","title":"3. Mysql基本语句","keywords":"","body":"1.1 SQL简介 数据库是指在计算机的存储设备上合理存放相关联、有结构的数据集合 SQL，指结构化查询语言（Structured Query Language），是用于访问和处理数据库的标准的计算机语言。 可让使用者访问和处理数据库。 数据库服务器、数据库和表的关系 数据在数据库中的存储方式 1.2 SQL能做什么 SQL 面向数据库执行查询 SQL 可从数据库取回数据 SQL 可在数据库中插入新的记录 SQL 可更新数据库中的数据 SQL 可从数据库删除记录 SQL 可创建新数据库 SQL 可在数据库中创建新表 SQL 可在数据库中创建存储过程 SQL 可在数据库中创建视图 SQL 可以设置表、存储过程和视图的权限 1.3 数据库基本操作 SQL对数库的操作语句，大致可分为：创建数据库、删除数据库、修改数据库等。 创建数据库 create database if not exists WebData character set utf8; --haracter set utf8 用于指定数据库的字符集类型 查看数据库 show databases； 查看数据库创建时的命令 show create database student; 删除数据库 drop database ding; 备份(导出)数据库 mysqldump -uroot -p test > new.sql; 切换数据库 use db2； 恢复（导入）数据库 --mysql导入 mysql -uroot -p123456 数据库的存储引擎 show ENGINES; 数据库的主要的三种存储引擎： Mylsqm存储引擎： 不支持事物，也不支持外键，所以访问速度较快。适用于：对事务没有要求的。使用MyISAM引擎创建数据库，将生产3个文件。文件的名字以表的名字开始，扩展名指出文件类型：fm文件存储表定义，数据文件的扩展名MYD，索引文件的扩展名是.MYI InnpDB储存引擎： 支持事务，但会占用更多的空间，适用类型：需频繁更新、删除操作的，同时还对事务的完整性要求较高。 Memory储存引擎： 使用内存来存储数据，速度很快，但安全性较低。适用于：数据量少，需要进行快速访问的 存储引擎对比 1.3.1 数据类型 1.3.1.1 数值类型 1.3.1.2 日期和时间类型 1.3.1.3 字符串类型 1.3.1.4 创建数据表字段类型选择 1.3.2 运算符 MySQL主要有以下几种运算符： 算术运算符 比较笨运算符 逻辑运算符 位运算符 1.3.2.1 算术运算符 MySQL支持的算术运算符包括： 运算符 作用 + 加 - 减 * 乘 /或DIV 除，如果除数为0，将是非法除数，返回结果为null %或MOD 模，如果除数为0，将是非法除数，返回结果为null #加 select 2-1;#结果为1 #减 select 1+2;#结果为3 #乘 select 2*2;#结果为4 #除 select 12/4;#结果为3 #模 select 12%5;#结果为2 1.3.2.2 比较运算符 如果比较结果为真，则返回结果为1，如果比较结果为假，则返回结果为0。 #等于 select 2=2;#结果为1 select null=null;#结果为null #不等于 select 2<>2#结果为0 selecg 3!=1#结果为1 #大于 select 2=2;#结果为1 #between and select 2 BETWEEN 1 and 4;#结果为1 #in select 3 in (1,2,3,4,5);#结果为1 # select null null# 结果为1 #Like模糊查查询 select '1234' like '12%';#结果为1 select '1234' like '12_';#结果为0 #正则匹配 select \"shanghai\" regexp \"ang\";#结果为1 select \"shanghai\" regexp \"as\"#结果为0 #is null select \"as\" is null;#结果为0 select null is null;#结果为1 #is not null select \"as\" is null;#结果为1 1.3.2.3 逻辑运算符 逻辑运算符用来判断表达式的真假，如果表达式为真，则返回结果为1，如果结果为假，则返回结果为0。 运算符 作用 NOT或! 逻辑非 AND 逻辑与 OR 逻辑或 XOR 逻辑异或（即二进制不进位加法） #逻辑与 select 1 and 0;#结果为0 select 1 and 2;#结果为1 select 0 and 0;#结果为0 select 3 and 5;#结果为1 #逻辑或 select 2 or 7;#结果为1 select 5 or 0;#结果为1 select 0 || 0;#结果为0 #NOT select not 0;#结果为1 select !1;#结果为0 select not 5;#结果为0 #逻辑异或（即二进制不进位加法，如0+1=1，1+0=1，1+1=0（不进位）） select 0 xor 0;#结果为0 select 1 xor 0;#结果为1 select 1 xor 1;#结果为0 select 0 xor 1;#结果为1 1.3.2.4 位运算符 位运算符是在二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。然后再将计算结果从二进制数变回十进制数。 运算符号 作用 & 按位与 \\ 按位或 ^ 按位异或 ! 取反 左移 >> 右移 1.4 数据表基本操作 1.4.1 基本SQL语句 1.4.1.1 SQl创建表操作 #创建数据表时可以指定数据库存储引擎，如果不指定的化默认就是innodb存储引擎 create table student02( eid int(11) primary key, ename varchar(15) ) character set utf8 engine innodb; #创建一个Myisam存储引擎的数据表 create table student02( eid int(11) primary key, ename varchar(15) ) character set utf8 engine myisam; 1.4.1.2 查看所有表 show tables; table student02 1.4.1.3 查看建表语句 show create table student02; Table Crate Table student02 CREATE TABLE student02( eid int(11) DEFAULT NULL, ename varchar(15) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8 1.4.1.4 查看表结构 desc student02; 1.4.1.5 修改表结构 通过SQl语句可以直接对表进行如下操作：表的重命名、向表中指定位置新增一列、修改表中字段的数据类型（modify）、移动表中字段的顺序（modify）、修改表中字段的名称（change）、删除表中的字段（drop） #重命名表名称 rename table student02 to student; #向表中新增一列，数据类型位int，长度限制为4，新增列的位置在表最后面 alter table student add column classroom int(4); #向表中新增一列，数据类型为int，长度限制为3，新增列的位置在表的最前面 alter table student add column age int(3) first; #向指定位置新增一列 alter table student add column age int(3) after yourname; #将新增的列的数据类型修改为varchar类型，长度设置为25 alter table student modify classroom varchar(25); #修改列的顺序，将某个列移动到另一列的后面 alter table student modify age int(3) after ename; #修改某一列的属性名称 alter table student change eid id int(11); alter table student change ename yourname varchar(20); #删除表中的某一字段 alter table student drop age; #删除表 drop table if exists student; 1.4.1.6 对数据操作 student表结构如下： 插入数据 插入数据方法一：插入一条数据 #正确示范 #数据中的每个值必须与表中的字段相对应，不能少值或多值，数据类型不能错，各个值之间的顺序不能乱 insert into student values(1001,\"小明\",22,\"1班\"); #错误示范一:少了一个字段值 #insert into student values(1001,\"小明\",22); #错误示范二:多了一个字段值 #insert into student values(1001,\"小明\",22,\"1班\",'男'); #错误示范三:数据类型与表中不匹配 #insert into student values(1001,\"小明\",22,1班); #错误示范四:数值顺序混乱 #insert into student values(\"小明\",1001,22,\"1班\"); 插入数据方法二：对表中的指定字段进行插入 #插入数据时也可以选择对表中的指定字段进行插入，其他字段会根据建表时的设置进行填充，如果未设置就默认为空 #数据值要与字段相互对应 insert into student (id,yourname,age) values (1002,\"小刚\",20); 插入数据方法三：一次性插入多条数据 #一次性插入多条数据，每条数据之间用英文 , 隔开 INSERT INTO student VALUES ( 1003, \"小钉\", 20, \"2班\" ), ( 1004, \"小胡\", 20, \"4班\" ), ( 1005, \"小花\", 21, \"2班\" ), ( 1006, \"小赵\", 19, \"3班\" ); 数据插入结果： 查询数据 # 查询全部字段 select * from student; # 查询自定字段 select id,yourname from studnet; # 设置查询条件 select * from student where age>20 更新数据 # 更新数据 update student set classroom=\"4班\" where id=1002; update student set age=18,classroom=\"我也不知道我是哪班的\" where id=1003; 数据更新结果： 删除数据 # 删除一行数据 delete from student where id =1003; 删除数据结果： 1.4.2 约束 这里的约束即字面意思，就像老师约束我们上课不能玩手机一样。在数据库中约束就是对某些字段进行约束，规定该字段中应该存什么类型的值，不应该存什么类型的值。 约束的作用：约束的作用就是防止数据库中含有不符合语义规定的数据 1.4.2.1 约束的分类 键约束：主键约束、外键约束、唯一键约束 非空约束 检查约束 自增约束 默认约束 1.4.2.2 主键约束 主键约束特点 一个表有且只能有一个主键约束 主键约束意味着非空，并且唯一 主键约束格式：primary key 创建主键会自动创建对应主键索引，删除主键，对应的索引也随之消失 主键约束分类 单列主键约束 多列主键约束（复合主键约束） 创建单列主键约束 方式一：建表时直接指定主键 create table student( id int(11) primary key, yourname varchar(15) ) character set utf8; 方式二：建表之后指定主键 alter table student add primary key(id); 创建多列主键约束 方式一：建表时直接指定主键 create table student( id int(11), yourname varchar(15), classroom varchar(20), primary key(id,yourname) ) character set utf8; 方式二：建表之后指定主键 alter table student add primary key(id,yourname); 删除主键约束 删除主键约束之后，相应的索引也会消失 alter table student drop primary key; 1.4.2.3 外键约束 主表：主键用于与其他表相关联，并且作为在主表中的唯一性标识。主表是被参考的，被依赖的 从表：以主表的主键值为外键的表，可通过外键与主表进行关联查询 从表与主表通过外键进行关联查询，从表就是参考别的表，依赖别的表，如果对主表进行修改，那么从表上对应的数据也会做出相应的改动。 比如下图中的两个表，一个是专业信息表，一个是学生信息表。对于学生信息表，mid就是它的外键，通过这个外键把学生信息表与专业信息表联系了起来。 专业信息表为主表，因为表中mid字段被学生信息表所依赖 学生信息表为从表，因为它需要依赖专业信息表中的字段 专业信息表 字段名 说明 mid 专业ID mname 专业名 学生信息表 字段名 说明 sid 学生ID sname 学生姓名 mid 专业名 外键约束特点 一个表可以有很多个外键约束，一个表可以同时关联很多个主表 外键约束是需要一个表的两个字段或两个表的两个字段之间建立外键约束 在从表中外键约束的列，与在主表中外键约束参考的列，这两个列的名称可以不同，但是意义、数据类型必须一致 外键约束是同时约束双方的行为的。对于主表来说，修改和删除就受约束了，因为如果删除主表中的某一条记录，这个记录正好被从表依赖，那么从表就可能会发生变化。对于从表来说，添加和修改就受约束了，因为从表只能添加和修改主表中有的记录 主表被参考的字段/列必须是键列 建表时，先建主表，再建从表。删表时，先删从表，再删主表 约束等级 约束等级即当主表中的数据发生变化时，从表中的数据会发生什么样的变化，约束等级可以分为下面三类： Cascade（级联）方式：主动权在主表，如果主表被依赖的字段修改，那么从表上的外键也会跟着被修改；如果主表上被依赖的字段被删除了，那么从表上的外键字段也会被删除。 Set null方式：主动权在主表，要求从表上的外键字段不能有非空约束（即字段值可以为空），如果主表被依赖的字段被修改了，从表对应的外键字段值变为null；如果主表上被依赖的字段被删除了，那么从表上的外键字段值变为null。 No action和Restrict方式：主动权在从表，如果主表的被依赖字段的值被引用了，那么主表对该字段的修改和删除就被完全限制了。就不能修改和删除，必须先处理从表对应的值，然后才能修改和删除。 创建外键约束 建表时创建外键约束 create table student( id int(11) primary key auto_increment, mid int(11) not null default 101, yourname varchar(15), classroom varchar(20), foreign key(从表中的某字段) references 主表名（被参考字段）[on update 等级][on update 等级] ) character set utf8; 建表后创建外键约束 alter table student add foreign key(从表中的某字段) references 主表名（被参考字段）[on update 等级][on delete 等级] [on update 等级]：设置更新数据时的约束等级 [on delete 等级]：设置删除数据时的约束等级 练习： #创建主表 create table dept( did int, dname varchar(20) ) charset utf8; #创建从表 create table emp( eid int primary key, ename varchar(20), did int, foreign key(did) references dept(did) on update cascade on delete set null ); 删除外键约束 drop table student drop foreign key 约束名; create table emp( eid int primary key, ename varchar(20), did int, foreign key(did) references dept(did) on update cascade on delete set null ); 1.4.2.4 非空约束 非空约束特点 非空约束关键字：not null 一个表可以有多个非空约束 非空约束只针对某一个字段 非空约束意味着该字段不能存入null值 创建非空约束 建表时指定非空约束 create table student( id int(11) primary key , yourname varchar(15) not nul, classroom varchar(20) not null, gender char(2), ) character set utf8; 建表后指定非空约束 alter table student modify gender char(2) not null; 删除非空约束 alter table student modify gender char(2); 1.4.2.5 唯一约束 唯一约束特点 唯一约束关键词：unique key 一个数据表中可以有多个唯一约束 唯一键约束是针对字段来说的，如果该字段设置了唯一约束，那么该字段中的值必须唯一，不能重复 设置唯一键约束的字段值可以为null，null不受唯一键的约束 创建唯一键约束，也会在对应列上建立索引，而且删除唯一键约束的方式是通过删除对应索引来实现的。 唯一键约束分类 单列唯一键约束 复合唯一键约束 创建单列唯一键约束 建表时创建唯一键约束 create table student( id int(11) primary key , yourname varchar(15) not nul, yourphone varchar(11) unique key, classroom varchar(20) not null, ) character set utf8; 建表后指定唯一键约束 alter table student add unique key(yourphone); 创建复合唯一键约束 create table student( id int(11) primary key , yourname varchar(15) not null, yourphone varchar(11), youremail varchar(11), classroom varchar(20) not null, unique key(yourphone,youremail), ) character set utf8; 建表后指定唯一键约束 alter table student add unique key(yourphone,youremail); 删除唯一键约束 删除唯一键约束使用删除索引的方式来实现的 查看表中都是有哪些索引 show index from 表名 删除唯一键约束 alter table student droo index 索引名; 1.4.2.6 自增约束 自增约束特点 自增约束关键词：auto_increment 一个表中只能有一个自增约束 自增约束的列只能时整数列 自增约束的键一般为键列（主键、唯一键、外键），实际开发中一般设置主键为自增 创建自增约束 建表时创建自增约束 create table student( id int(11) primary key auto_increment , yourname varchar(15) not null, classroom varchar(20) not null, ) character set utf8; 建表后创建自增约束 alter table student mofify id int(11) auto_increment; 删除自增约束 alter table student mofify id int(11); 注意事项 对于自增列，在添加数据的时候自定义了自增列的值，那么就按自定义的值写入数据值，如果没有自定义值，就按自增写入数据 如果添加数据时，自增列指定的值为0或null，则还是按照自增的值来 1.4.2.7 默认值约束 默认值约束特点 默认值约束关键字：default 一个表中可以为多个字段设置默认值 默认值只是针对某一个字段来说的 一个字段设置了默认值，田间数据时如果该字段没有赋值，就会自动填充设置好的默认值进去 创建默认值约束 建表时创建默认约束 create table student( id int(11) primary key auto_increment , yourname varchar(15) not null, classroom varchar(20) not null, nowstatus int(1) not null default 1;#0表示已毕业，1表示在读 ) character set utf8; 建表后创建默认约束 alter table student mofify nowstatus int(1) default 1; 取消默认值约束 alter table student mofify nowstatus int(1) 使默认值生效 插入时直接使用默认值 insert into student values(1,\"小明\",\"2班\",default); 指定字段插入，不包含默认值 #id自增，nowstatus默认 insert into student (yourname,classroom) values (\"小华\",\"4班\") 1.4.3 MySQL函数 1.4.3 查询操作 1.4.3.1 多表查询 创建员工表并添加数据 #创建员工表 CREATE TABLE `employees` ( `emp_no` int(11) NOT NULL, `birth_date` date NOT NULL, `first_name` varchar(14) NOT NULL, `last_name` varchar(16) NOT NULL, `gender` char(1) NOT NULL, `hire_date` date NOT NULL, PRIMARY KEY (`emp_no`)); #添加四条数据 INSERT into employees values(10001,\"1956-02-24\",\"Zhang\",\"San\",'M',\"1978-06-04\"); INSERT into employees values(10002,\"1987-04-21\",\"Li\",\"Si\",'M',\"2005-12-24\"); INSERT into employees values(10003,\"1974-12-24\",\"Wang\",\"Wu\",'F',\"1999-08-04\"); INSERT into employees values(10004,\"1966-05-05\",\"Xiao\",\"Ming\",'M',\"1988-06-04\"); 建表结果 创建部门表并添加数据 #创建部门表 CREATE TABLE `dept_emp` ( `emp_no` int(11) NOT NULL, `dept_no` char(4) NOT NULL, `from_date` date NOT NULL, `to_date` date NOT NULL, PRIMARY KEY (`emp_no`,`dept_no`)); #添加两条数据 INSERT into dept_emp values(10001,'d001',\"1986-06-24\",\"9999-01-01\"); INSERT into dept_emp values(10002,'d002',\"1989-02-14\",\"9999-01-01\"); 建表结果 1.4.3.1.1 笛卡尔积 多表查询容易产生笛卡尔积的情况，dept_emp中有两条数据，employees中有四条数据，如果直接查询两表，结果会产生八条数据。 例如：A={1,2} B={a,b,c,d} 结果：C={(1,a),(1,b),(1,c),(1,d),(2,a),(2,b),(2,c),(2,d)} #直接查询两表 select * from employees,dept_emp 查询结果 这样查询容易导致查询结果重、混乱，所以需要用条件来筛选查询结果。 1.4.3.1.2 内连接 不区分主从表，与连接顺序无关，两张表均满足条件则出现结果，on后跟查询条件。 关键词：inner join on 示意图 #内连接，只查询出满足条件的数据 select * from employees as e INNER JOIN dept_emp as d on e.emp_no=d.emp_no 查询结果 1.4.3.1.3 左连接（左外连接） 区分主从表，与连接顺序有关，以左表（主表）为依据，从右表（匹配表）中依次查询，右表（匹配表）中找不到数据用null代替，on后跟查询条件。 关键词：left join on / left outer join on 示意图 select * from employees as e left join dept_emp as d on e.emp_no=d.emp_no 查询结果 1.4.3.1.3 右连接（右外连接） 区分主从表，与左连接相似，与连接顺序有关，以右表（主表）为依据，从左表（匹配表）中依次查询，左表（匹配表）中找不到数据用null代替，on后跟查询条件。 关键词：right join on / right outer join on 示意图 select * from employees as e RIGHT join dept_emp as d on e.emp_no=d.emp_no 查询结果 1.4.3.1.4 自然连接 寻找两表中字段名相同的，数据类型相同的字段进行连接，自动去重复列（如果有多个字段符合要求，那么他们会被作为自然连接的条件） select * from employees NATURAL join dept_emp 查询结果 1.4.3.1.5 自连接 同一个表中的数据进行关联 select e.emp_no,e1.first_name from employees as e ,employees as e1 where e.emp_no=e1.emp_no 查询结果 1.4.4 联合查询 创建学生表并添加数据 #创建学生表 create TABLE student( cid int(11) not NULL, classname varchar(20) not null, age int(2) not null, PRIMARY KEY(cid) ); #添加数据 insert into student VALUES(1,\"张三\",\"3班\",22); insert into student VALUES(2,\"李四\",\"2班\",18); insert into student VALUES(3,\"王五\",\"1班\",21); insert into student VALUES(4,\"小明\",\"2班\",18); insert into student VALUES(5,\"小王\",\"6班\",23); insert into student VALUES(6,\"赵四\",\"2班\",19); insert into student VALUES(7,\"二狗\",\"3班\",20); insert into student VALUES(8,\"铁蛋\",\"4班\",24); insert into student VALUES(9,\"轩辕麻子\",\"2班\",19); insert into student VALUES(10,\"小六\",\"1班\",18); 建表结果 1.5.2.1 UNION 并集，所有内容都查询，重复的只显示一次 #联合两个表，两个表中重复的内容只显示一次 select * from student where classname=\"2班\" union select * from student where age>20 查询结果 1.5.2.2 UNION ALL 并集，所有内容都查询，与UNION不同的是查询结果中重复的内容全部显示 #联合两个表，如果出现重复的内容，会全部显示出来 select * from student where classname=\"2班\" union all select * from student where age>20 查询结果 1.5.3 子查询 子查询一般与in / not in 关键字连用，也可以用>= select emp_no from employees where emp_no not in (select emp_no from dept_manager) select emp_no from employees where emp_no in (select emp_no from dept_manager) 1.6 索引 MySQL使用索引快速查找具有特定列值的行。如果没有索引，MySQL必须扫描整个表以找到相关的行。表越大，搜索速度越慢。 索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？ 如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。 1.6.1 B+Tree和B-Tree 实际的数据库系统几乎没有使用二叉树或其进化品种红黑树实现索引，大部分数据库系统及文件系统都采用B+Tree或其变种B+Tree作为索引结构。 参考链接：点我进入 1.6.2 Mysql索引具体实现 1.6.2.1 创建索引 未创建索引前 select * from employees where last_name=\"Facello\" 查询结果：查询时间为0.065s 创建索引 create index empno on employees(emp_no) 创建索引后 select * from employees where last_name=\"Facello\" 查询结果：查询时间为0.053s 分析查询 EXPLAIN select * from employees where last_name=\"Facello\" 1.6.2.2 删除索引 drop index index_name on table_name #如果索引在主键上 drop index 'primary' on table_name 1.6.2.3 显示索引 #新增索引 create index deptno on dept_emp(dept_no) #查看索引 show index from dept_emp 1.7 存储过程 存储过程和函数是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。第一次接触存储过程可能会将它与函数弄混肴，其实存储过程和函数是不一样的。 存储过程和函数的区别在于函数必须有返回值，而存储过程没有。 函数：是一个有返回值的过程 存储过程：是一个没有返回值的函数 1.7.1 创建存储过程 创建存储过程的语法格式： CREATE PROCEDURE sp_name(proc_parameter1,proc_parameter2,proc_parameter3) begin --sql语句 end; CREATE PROCEDUR创建存储过程的关键字 sp_name为存储过程名称 proc_parameter1为指定存储过程的参数列表，列表形式如下 IN / OUT /INOUT param_name type 其中，IN表示输入参数，OUT表示输出参数，INOUT表示输入输出函数，param_name表示参数名称，type表示参数的类型，可以是Mysql数据库中任意类型。 delimiter // CREATE PROCEDURE test() begin select 'Hello World'; end // delimiter ; DELINTER //语句的作用是将wysL的结束符设置为，因为Mysql默认的语句结束符号为分号。为了避免与存储过程中SQL语句结束符相冲突，需要使用delimiter改变存储过程的结束符，并以 END //结束存储过程。存储过程定义完毕之后再使用delimiter;恢复默认结束符。delimiter也可以指定其他符号作为结束符。当使用 delimiter命令时，应该避免使用反斜杠\\字符，因为反斜线是Mysql的转义字符。 1.7.2 创建存储函数 创建存储函数的语法格式： CREATE Function func_name(func_parameter1,func_parameter2,func_parameter3) return types begin --sql语句 end; CREATE Function创建存储函数的关键字 sp_name为存储函数名称 func_parameter1为指定存储函数被的参数列表，列表形式如下 IN / OUT /INOUT param_name type 其中，IN表示输入参数，OUT表示输出参数，INOUT表示输入输出函数，param_name表示参数名称，type表示参数的类型，可以是Mysql数据库中任意类型。 delimiter // CREATE Function test() return int; begin declare num int; select count(*) into num from mysql.user; return num; end // delimiter ; 如果在存储函数中的RETURN语句返回一个类型不同于函数的RETURNS子句中指定类型的值，返回值将被强制为恰当的类型。比如，如果一个函数返回一个ENUM或SET值，但是RETURN语句返回一个整数，对于SET成员集相应的ENUM成员，从函数返回的值是字符串。 指定参数为IN、OUT或INOUT只对PROCEDURE是合法的。（FUNCTION中总是默认为IN参数）。RETURNS子句只能对FUNCTION做指定，对函数而言这是强制的。它用来指定函数的返回类型，而且函数体必须包含一个RETURN value语句。 1.7.3 复杂存储过程 1.7.3.1 DECLARE 通过DECLARE可以定一个局部变量，该变量的作用范围只能在BEGIN_END delimiter // create procedure a() begin declare num int default 5; select num+100; end // delimiter; 1.7.3.2 set 对变量直接赋值使用SET，可以赋值常量或者表达式，具体语法如下。 delimiter // create procedure b() begin declare site varchar(20); set site=\"www.dingzijun.top\"; select site; end // delimiter; 1.7.3.3 if 条件判断 delimiter // create procedure pro_if_in(in height int) begin declare descrip varchar(50) default ''; if height >= 180 then set descrip = '身材高挑'; elseif height >= 170 and height 1.7.3.4 参数传递 "},"2-JavaWeb/2-JavaWeb.html":{"url":"2-JavaWeb/2-JavaWeb.html","title":"4. JavaWeb","keywords":"","body":"导言 这些笔记是JavaWeb基础知识必学部分，也是面试必问知识，学习了这些知识之后才能更好的学习基于此的框架（Spring、SpringBoot等） JavaWeb三大组件：Servlet、Filter、Listener 1. JDBC JDBC就是用Java语言操作关系型数据库的一套API 1.2 JDBC简介 基本概念： 全称：Java DataBase Connectivity，Java数据库连接 JDBC就是定义了一套能操作不同关系型数据库的接口，接口的实现类是由各个关系型数据库的公司实现的，这些实现类就是驱动。 思考：为什么需要驱动？ 以关系型数据库为例，每个公司所使用的开发技术、开发环境、操作要求等是不同的，如MySQL、Oracle、MangoDB，用户使用这些关系型数据库时，需要用不同的技术或方式操作这些数据库，这就会给用户带来非常大的负担。所以为了简化用户负担，各软件厂商一般会提供对应的驱动，方便用户能用一套相同的方法操作不同厂商开发的软件。如各软件厂商会实现JDBC接口，以便一套接口可以同时对MySQL、Oracle、MangoDB等不同厂商开发的数据库操作，使方法具有通用性。 JDBC本质： 官方(sun公司)定义的一套操作所有关系型数据库的规则，即接口 各个数据库厂商去实现这套接口，提供数据库驱动jar包 我们可以使用这套接口(JDBC)编程，真正执行的代码是驱动jar包中的实现类 JDBC好处 各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发 可随时替换底层数据库，访问数据库的Java代码基本不变 1.3 JDBC快速入门 创建工程，导入相应数据库的驱动Jar包（以Mysql为例） mysql-connector-java-5.1.48 新建lib文件夹，将jar包拷贝至项目中。 然后右键点击Add as Library将jar包添加至项目 然后选择添加方式，三种添加方式分别对应全局添加、项目添加、模块添加，这里选择模块添加即可。 注册驱动（采用了反射机制） //注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); 获取连接 //获取连接 String url=\"jdbc:mysql://127.0.0.1:3306/db2\"; String username=\"root\"; String password=\"123456\"; Connection conn = DriverManager.getConnection(url, username, password); 定义SQL语句 //定义SQL语句 String sql=\"update jdbc set price=2000 where id=2\"; 获取执行SQL对象 //获取执行sql的对象 Statement state = conn.createStatement(); 执行SQL //执行sql语句,返回影响的行数 int count = state.executeUpdate(sql); 处理返回结果 //处理结果 1 System.out.println(count); 释放资源 //释放资源 state.close(); conn.close(); 1.3 JDBC API详解 1.3.1 DriverManager DriverManager驱动管理类的作用： 注册驱动 获取数据库连接 功能一：注册驱动 //注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); Driver类源码： public class Driver extends NonRegisteringDriver implements java.sql.Driver { public Driver() throws SQLException { } static { try { DriverManager.registerDriver(new Driver()); } catch (SQLException var1) { throw new RuntimeException(\"Can't register driver!\"); } } } Driver类其实继承了NonRegisteringDriver类，类中实现了DriverManager注册驱动的静态代码块，即DriverManager.registerDriver(new Driver())部分代码。 我们每次使用Class.forName(\"\")注册驱动时，会通过反射机制加载到Driver类，因为源码中注册驱动那部分代码被static所修饰，所以反射加载到Driver类时会自动加载到该部分代码，实现驱动注册。 注意： MySQL5之后的驱动包，可以省略注册驱动的步骤 自动加载jar包中的META-INF/services/java.sql.Driver文件中的驱动类 功能二：获取数据库连接 Connection conn = DriverManager.getConnection(url, username, password); 参数说明： url：表示要连接的数据库地址 url=\"jdbc:mysql://数据库服务器地址/数据库名?参数1?参数2\" url=\"jdbc:mysql://127.0.0.1:3306/db2\"; 1. 如果连接的是本机的Mysql服务器，并且mysql默认端口是3306，则url可以简写为jdbc:mysql:///数据库名？键值对 2. 配置useSSL=false参数，禁用安全连接方式，解出警告提示 user：用户名 password：密码 String url=\"jdbc:mysql:///db2?useSSL=false\"; String username=\"root\"; String password=\"123456\"; Connection conn = DriverManager.getConnection(url, username, password); 1.3.2 Connection Connection（数据库连接对象）作用： 获取执行SQL的对象 管理事务 功能一：获取执行SQL的对象 普通执行SQL对象 Statement state = conn.createStatement(); 预编译SQL的执行SQL对象，防止SQL注入 PreparedStatement pre = conn.prepareStatement(sql); 执行存储过程的对象（不常用） CallableStatement call = conn.prepareCall(sql); 功能二：事务管理 MySQL事务管理 开启事务: BEGIN/START TRANSACTION 提交事务：COMMIT; 回滚事务：ROLLBACK; MySQL默认自动提交事务 JDBC事务管理：Connection中定义了三个对应的方法 开启事务：setAuto(boolean autoCommit)；值为true时自动提交事务，false时需手动提交 提交事务：commit（） 回滚事务：rollback（） 正常情况下手动提交事务 public class JdbcDemo { public static void main(String[] args) throws Exception { //注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //获取连接 String url = \"jdbc:mysql:///db2?useSSL=false\"; String username = \"root\"; String password = \"123456\"; Connection conn = DriverManager.getConnection(url, username, password); //定义SQL语句 String sql1 = \"update jdbc set price=4000 where id=1\"; String sql2 = \"update jdbc set price=7000 where id=2\"; //获取执行sql的对象 Statement state = conn.createStatement(); try { //开启事务 conn.setAutoCommit(false); //执行sql1 int count = state.executeUpdate(sql1); System.out.println(count); //执行sql2 int count1 = state.executeUpdate(sql2); System.out.println(count1); //如果没有出现问题，则提交事务 conn.commit(); }catch(Exception e){ //如果出现异常，则回滚事务 conn.rollback(); e.printStackTrace(); } //释放资源 state.close(); conn.close(); } } 执行过程中出现异常，进行事务回滚，如下代码中，我在事务执行过程中加了一个2/0的除0异常，执行到此处时会捕获到该异常，执行事务回滚，因此数据库中的两条都被回滚到事务开始执行之前的状态，即数据都没有改变。 public class JdbcDemo { public static void main(String[] args) throws Exception { //注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //获取连接 String url = \"jdbc:mysql:///db2?useSSL=false\"; String username = \"root\"; String password = \"123456\"; Connection conn = DriverManager.getConnection(url, username, password); //定义SQL语句 String sql1 = \"update jdbc set price=4000 where id=1\"; String sql2 = \"update jdbc set price=7000 where id=2\"; //获取执行sql的对象 Statement state = conn.createStatement(); try { //开启事务 conn.setAutoCommit(false); //执行sql1 int count = state.executeUpdate(sql1); System.out.println(count); //增加一个异常项，使事务回滚 int i=2/0; //执行sql2 int count1 = state.executeUpdate(sql2); System.out.println(count1); //如果没有出现问题，则提交事务 conn.commit(); }catch(Exception e){ //如果出现异常，则回滚事务 conn.rollback(); e.printStackTrace(); } //释放资源 state.close(); conn.close(); } } 如果没有设置手动提交事务，则默认自动提交事务，每执行一条SQL语句会提交一个事务，如果两条语句中间出现异常则被执行过的SQL语句不会回滚。 public class JdbcDemo { public static void main(String[] args) throws Exception { //注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //获取连接 String url = \"jdbc:mysql:///db2?useSSL=false\"; String username = \"root\"; String password = \"123456\"; Connection conn = DriverManager.getConnection(url, username, password); //定义SQL语句 String sql1 = \"update jdbc set price=3000 where id=1\"; String sql2 = \"update jdbc set price=7000 where id=2\"; //获取执行sql的对象 Statement state = conn.createStatement(); //执行sql1 int count = state.executeUpdate(sql1); System.out.println(count); //增加一个异常项 int i=2/0; //执行sql2 int count1 = state.executeUpdate(sql2); System.out.println(count1); //释放资源 state.close(); conn.close(); } } 1.3.3 Statement Statement作用： 执行SQL语句 执行SQL语句 executeUpdate DML语句：对数据的增删改操作 DDL语句：对数据表和数据库的增删改查操作 int count = state.executeUpdate(sql) 返回值：（1）DML语句影响的行数（2）DDL语句执行后，执行成功也可能返回0 executeQuery DQL语句：对数据的查询操作 ResultSet resultSet = state.executeQuery(sql2); 返回值：ResultSet结果数据集对象 public class JdbcDemo { public static void main(String[] args) throws Exception { //注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //获取连接 String url = \"jdbc:mysql:///db2?useSSL=false\"; String username = \"root\"; String password = \"123456\"; Connection conn = DriverManager.getConnection(url, username, password); //定义SQL语句 String sql1 = \"update jdbc set price=3000 where id=1\"; // DML语句 String sql2 = \"create database db3;\"; // DDL语句 //获取执行sql的对象 Statement state = conn.createStatement(); //执行DML语句，返回受影响的行数 int count = state.executeUpdate(sql1); System.out.println(count); // 执行DDL语句，执行成功返回的结果可能是0 int i = state.executeUpdate(sql2); //释放资源 state.close(); conn.close(); } } 1.3.4 ResultSet ResultSet作用： 封装DQL查询结果的语句 ResultSet resultSet = state.executeQuery(sql3); 获取查询结果： boolean next():（1）将光标从当前位置向前移动一行（2）判断当前行是否为有效行 返回值：true：有效行，当前行有数据；false：无效行，当前行无数据 xxx getXxx(参数)：获取数据 xxx：数据类型，如int getInt(参数)；String getString(参数) 参数：列的名称 使用步骤： 游标向下移动一行，并判断该行是否有数据：next（） 获取数据：getXxx（参数） // 循环判断游标是否是最后一行末尾 while(rs.next()){ //获取数据 rs.getXxx(参数); } public class JdbcDemo { public static void main(String[] args) throws Exception { //注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //获取连接 String url = \"jdbc:mysql:///db2?useSSL=false\"; String username = \"root\"; String password = \"123456\"; Connection conn = DriverManager.getConnection(url, username, password); //定义SQL语句 String sql3 = \"select * from jdbc\"; // DQL语句 //获取执行sql的对象 Statement state = conn.createStatement(); //执行DQL语句，返回结果是一个ResultSet结果集 ResultSet resultSet = state.executeQuery(sql3); //循环判断游标是否处于末尾 while (resultSet.next()){ // 获取数据 // 第一列 int id=resultSet.getInt(1); // 第二列 int price=resultSet.getInt(2); System.out.println(id); System.out.println(price); System.out.println(\"------------\"); } //释放资源 state.close(); conn.close(); } } ResultSet实例：查询Students表，将查询结果封装到Student对象中，最后保存到ArrayList数组中。 创建数据表： create table students( id int(10) primary key, name varchar(20) not null, class varchar(20) not null )charset utf8; insert into students values(1,\"张三\",\"软工1班\"),(2,\"李四\",\"软工2班\"),(3,\"南雨\",\"软工3班\"); 创建Student实体类 package com.study.nanyu.jdbc.pojo; public class Student { private int id; private String name; private String uclass; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getUclass() { return uclass; } public void setUclass(String uclass) { this.uclass = uclass; } @Override public String toString() { return \"Student{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", uclass='\" + uclass + '\\'' + '}'; } } 获取数据存入Student对象并存入数组。 public class JdbcDemo { public static void main(String[] args) throws Exception { //注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //获取连接 String url = \"jdbc:mysql:///db2?useSSL=false\"; String username = \"root\"; String password = \"123456\"; Connection conn = DriverManager.getConnection(url, username, password); //创建一个列表 List list=new ArrayList<>(); String sql = \"select * from students;\"; Statement state = conn.createStatement(); ResultSet resultSet = state.executeQuery(sql); //获取数据并存入对象，最终保存至list列表 while (resultSet.next()) { //创建Student对象 Student student = new Student(); int id = resultSet.getInt(1); String name = resultSet.getString(2); String uclass = resultSet.getString(3); student.setId(id); student.setName(name); student.setUclass(uclass); list.add(student); } System.out.println(list); //释放资源 resultSet.close(); state.close(); conn.close(); } } //运行结果：[Student{id=1, name='张三', uclass='软工1班'}, Student{id=2, name='李四', uclass='软工2班'}, Student{id=3, name='南雨', uclass='软工3班'}] 1.3.5 PreparedStatement PreparedStatement作用： 预编译SQL语句并执行，防止SQL注入问题 SQL注入 SQL注入是通过操作输入事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。 最简单的一个例子： 比如下面一个登录案例，通过下面SQL语句查询用户输入的用户名和密码是否正确 select * from admin where username='\"+name+\"' and password='\"password\"'; 使用一串简单的字符串就可以实现SQL注入。比如前端用户输入用户名和密码准备登录，这时后端会自动完成字符串的拼接 select * from admin where username=\"zhangsan\" and password=\"123456\"; 这条语句非常简单，只需要满足where后面的username=\"zhangsan\" and password=\"123456\";为true即可实现登录，此时为用户名和密码都正确的正常情况。 但还有一种异常情况，如果仅仅满足where后面的条件为true即可登录成功，那么能不能有其他办法让where后面的条件恒为true。当然有，且很简单，在登录时只需要在密码框那里输入这样一串字符：\"or \"1\"=\"1，这段字符串传到后端后，后端会进行如下处理： select * from admin where username=\"zhangsan\" and password=\"\"or \"1\"=\"1\"; 此时就会出现问题，仔细看where后面的条件语句where username=\"zhangsan\" and password=\"\"or \"1\"=\"1\";，变成了先判断用户名和密码，因为输入密码时传递了一个字符串，与原有的字符串进行了拼接，导致password等于空，最后又拼接了一个or \"1\"=\"1\";使得前面的用户名和密码无论输入的是否正确都会恒为true，最终都能成功登录。这就是SQL注入的原理。 其实出现这样的问题原因就在于字符串拼接，容易被别入非法修改，那么既然知道了问题所在，有没有解决办法呢？ 使用PrepareStatement对象解决SQL注入 这种方法不再使用字符串拼接来，而是使用？作为占位符，后面再为此占位符赋值的操作 获取PrepareStatement对象 //SQL语句中的参数值，通过？占位符来代替 String sql = \"select * from students where name=? and class=?;\"; //通过Connection对象获取，并传入对应的sql语句 PreparedStatement preparedStatement = conn.prepareStatement(sql); 设置参数 PreapreStatement对象：setXxx(参数1，参数2)：给？赋值 Xxx：数据类型，如setInt(参数1，参数2) 参数： 参数1：？的位置编号，从1开始 参数2：？的值 执行SQL executeUpdate();executeQuery();不需要传递SQL public class JdbcDemo { public static void main(String[] args) throws Exception { //注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //获取连接 String url = \"jdbc:mysql:///db2?useSSL=false\"; String username = \"root\"; String password = \"123456\"; Connection conn = DriverManager.getConnection(url, username, password); //模拟用户输入的用户名和密码 String name=\"南雨\"; String uclass=\"软工1班\"; //创建sql，使用？作为参数的占位符 String sql = \"select * from students where name= ? and class= ?\"; //创建PreparedStatement对象，并执行SQl语句 PreparedStatement preparedStatement = conn.prepareStatement(sql); //为SQL中的占位符赋值,第一个参数表示为第几个占位符赋值，第二个参数表示为该占位符赋什么值 preparedStatement.setString(1,name); preparedStatement.setString(2,uclass); //执行SQL语句，不需要再传递SQL ResultSet resultSet = preparedStatement.executeQuery(); if(resultSet.next()){ System.out.println(\"成功！\"); }else { System.out.println(\"失败！\"); } //释放资源 resultSet.close(); preparedStatement.close(); conn.close(); } } PrepareStatement防止SQL注入其实是将敏感字符进行转义，比如'将会被转义为\\'。这样就避免了通过字符串拼接改变原有SQL语句的风险 PrepareStatement原理： 在获取PrepareStatement对象时，先将sql语句发送给mysql服务器，先进行检查和编译（这些步骤很耗时），此时不执行 后面在为sql语句中的占位符赋值或执行sql语句时，就不用再进行这些步骤了，会使速度更快 如果sql模板一样，则只需进行一次检查和编译，会大大提高性能 1.3.6 MySQL日志配置 打开MySQL安装位置，打开该路径：\\ProgramData\\MySQL Server 5.7，找到该路径下MySQL核心配置文件my.ini，不同版本可能位置不一样。 打开该配置文件，将下面的配置粘贴到最后一行即可，下面配置里面的路径可自定义，输入之后保存即可。 # Mysql日志配置 log-output=FILE general-log=1 general_log_file=\"D:\\Appinstall\\Mysql_log\\mysql.log\" slow-query-log=1 slow_query_log_file=\"D:\\Appinstall\\Mysql_log\\mysql_slow.log\" long_query_time=2 使用快捷键Win+R，输入cmd打开命令行，输入services.msc，找到MySQL，选中，点鼠标右键重启 重启之后到上面配置日志的路径下面查看是否有这两个日志文件生成 配置完成之后，每次执行SQL语句之后就会生成对应的日志，方便开发者查看和排错。 1.4 数据库连接池 1.4.1 数据库连接池简介 数据库连接池是个容器，负责分配、管理数据库的连接（Connection） 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个 可以避免因为没有释放数据库连接而引起的数据库连接遗漏。 好处： 资源重用，使用完先不关闭连接，可以被反复使用 提升系统响应速度，提前申请连接，使用完了也不关闭，减少开销 避免数据库连接遗漏，会自动对占着但不使用的连接重新分配 使用数据库连接池与不使用的两种情况： 不使用数据库连接池 这种情况下当一个用户访问数据时会建立一个Connection连接，连接结束之后会释放该连接；如果此时又来一个用户则又需要建立一个连接，然后再释放；如果一直又新用户访问数据库则需要不停重复的创建数据库连接，然后关闭。这样做有很多缺点，首先是复用性太差，第二是资源消耗过大，数据库连接的创建与释放都会消耗资源。 使用数据库连接池 在系统启动之前，会初始化一个容器（集合），在该容器中提前申请多个创建好的数据库连接，当有用户请求数据库连接时，会先从连接池中取出一个数据库连接分配个该用户，当用户执行完毕之后，该连接不会释放掉，而是会放回连接池中，供下一个用户使用。如果用户请求的连接数量大于连接池中的连接数量，则为了避免连接被遗漏，连接池还会检查已分配出去的连接，判断是否有用户占着资源而不使用，发现之后便会取消该连接，分配给其他请求。 总结来说，数据库连接池的作用就是实现对数据库连接的分配与管理，即能解决对连接的分配，又能解决对用户连接的管理。 1.4.2 数据库连接池实现 标准接口：DataSource 官方（SUN公司）提供的数据库连接池标准接口，由第三方组织实现此接口 功能：获取连接Connection getConnection 常见的数据库连接池： DBCP C3P0 Druid Druid（德鲁伊）： Druid连接池是阿里巴巴开源的数据库连接池项目 功能强大，性能优秀，是java语言最好的数据库连接池之一 1.4.3 Druid使用步骤 导入jar包，druid-1.1.10.jar 定义配置文件 加载配置文件 获取数据库连接池对象 获取连接 package com.study.nanyu.jdbc; import com.alibaba.druid.pool.DruidDataSource; import com.alibaba.druid.pool.DruidDataSourceFactory; import com.study.nanyu.jdbc.pojo.Student; import javax.sql.DataSource; import java.io.FileInputStream; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.util.Properties; /** * Druid数据库连接池 */ public class DruidDemo { public static void main(String[] args) throws Exception { Integer id = 2; Student student = new Student(); //1. 导入jar包 //2. 定义配置文件 //3. 加载配置文件 Properties prop = new Properties(); prop.load(new FileInputStream(\"D:/Appinstall/Idea/Project/Project01/src/druid.properties\")); //4. 创建DataSource对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(prop); //5. 获取连接 Connection conn = dataSource.getConnection(); // 定义SQL String sql = \"select * from students where id= ?\"; // 创建sql对象 PreparedStatement preparedStatement = conn.prepareStatement(sql); preparedStatement.setInt(1, id); // 执行SQL ResultSet resultSet = preparedStatement.executeQuery(); while (resultSet.next()) { int id1 = resultSet.getInt(\"id\"); String uname = resultSet.getString(\"uname\"); String uclass = resultSet.getString(\"uclass\"); student.setId(id1); student.setName(uname); student.setUclass(uclass); } System.out.println(student); } } 2. Mybatis Mybatis是一款优秀的持久层框架，用于简化JDBC开发，它的官网非常的友好，讲解也很详细：Mybatis官网 持久层： 负责将数据保存到数据库的那一层代码 JavaEE三层架构：表现层、业务层、持久层 框架： 框架是一个半成品的软件，是一套可重用的、通用的、软件基础代码模型 在框架基础上构建软件编写更加高效、规范、通用、可扩展 为什么会有Mybatis？ JDBC有以下缺点： 硬编码：注册驱动、获取连接、SQL语句都要写死 操作繁琐：需要手动设置参数，手动封装结果集 使用Mybatis有以下优点： 使用配置文件的方式编写驱动注册、获取连接等操作 Mybatis可以自动实现对查询结果集的封装、参数的设置Mybatis也会自动完成。 Mybatis免除了几乎所有的JDBC代码，以及设置参数和获取结果的工作。 2.1 Mybatis快速入门 查询Student表中的数据为例，实现步骤如下： 创建Student表，添加数据 创建模块，导入坐标（即pom文件） 编写Mybatis核心配置文件，替换连接信息，解决硬编码问题 编写SQL映射文件，统一管理SQL语句，解决硬编码问题 编码 定义POJO类 加载核心配置文件，获取SqlSessionFactory对象 获取SqlSession对象，执行SQL语句 释放资源 案例实操： 在pom.xml中引入基本的依赖 引入基本的Mybatis和Mysql驱动的依赖即可。 org.mybatis mybatis-spring 2.0.6 mysql mysql-connector-java 5.1.49 创建实体类 该实体类与数据库中的students表相对应。 package com.nanyu.pojo; public class Student { private int id; private String uname; private String uclass; //省去了Get、Set以及toString方法 } 创建Mybatis配置文件 该文件中配置了数据库的连接信息，以及各实体类对应的Mapper映射文件的路径 创建StudentMapper.xml配置文件 该文件用于映射对students表操作的SQL语句。 namespace为命名空间，类似包名，即指定SQL语句属于哪一个命名空间下，用于辨别其他Mapper中的可能存在的相同SQL语句。 每一条SQL语句需要放在对应的标签中，主要标签有select、insert、update、delete等，每一条SQL语句存在一个唯一的id，用于辨别不同的SQL语句。 select * from students; 创建测试类 获取到sqlSession对象后，只需要使用sqlSession执行对应的方法即可，方法中传入命名空间和SQL的id。 package com.nanyu; import com.nanyu.pojo.Student; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; import java.util.List; /** * Mybatis快速入门 */ public class MybatisDemo { public static void main(String[] args) throws IOException { // 加载Mybatis核心配置文件，获取SqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //获取SqlSession对象，执行SQL SqlSession sqlSession = sqlSessionFactory.openSession(); //执行Sql，传入SQL 的id List students = sqlSession.selectList(\"test.selectALL\"); System.out.println(students); //释放资源 sqlSession.close(); } } 不过在上面的编码中仍然存在硬编码问题，比如在执行SQL时，需要传入命名空间和ID。因此，Mybatis推荐我们使用Mapper代理开发解决这一问题。 2.2 Mapper代理开发 目的： 解决原生方式中的硬编码问题 简化后期执行SQL 代理开发步骤： 定义与SQL映射文件同名的Mapper接口，并将Mapper接口和SQL映射文件放置在同一目录下 设置SQL映射文件的namespace属性的值为Mapper接口的全限定名（即包名+接口名） 在Mapper接口中定义方法，方法名就是SQL映射文件中SQL语句的id，并保持参数类型和返回类型一致 编码 通过SqlSession的getMapper方法获取Mapper接口的代理对象 通过调用对应方法完成执行SQL 如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载，如下只需要写包名即可，会自动扫描该目录下的同名xml文件。 小细节：正常情况下我们希望配置文件统一存放在resource中，经过编译之后resource目录中的配置文件会自动整合到项目的根目录，如果想让Mapper接口文件与其对应的mapper配置文件存在于同一文件下，只需要在resource中创建与Mapper的同名目录即可，这样编译之后就会自动整合。 如上图，编译之后会自动将resource中com.nanyu.mapper中的xml配置文件与接口文件整合到同一目录下。 案例实操： 项目结构如下图 创建User实体类 package com.nanyu.pojo; public class User { private int id; private String name; //省略get、set、toString方法 } 创建UserMapper接口 package com.nanyu.mapper; import com.nanyu.pojo.User; import java.util.List; public interface UserMapper { User selectById(int id); List selectAll(); } 创建UserMapper.xml配置文件 select * from users; select * from users where id = #{id}; Mybatis核心配置文件 加载映射文件的两种方式 第一种：,这种方法可以加载任意目录下的映射文件，但缺点就是如果映射文件有很多，需要写很多行。 第二种：,包扫描法，这种方法可以加载该包下所有映射文件，但前提是所有映射文件都在该包下。 --> 编写测试类 package com.nanyu; import com.nanyu.mapper.UserMapper; import com.nanyu.pojo.Student; import com.nanyu.pojo.User; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; import java.util.List; /** * Mybatis快速入门 */ public class MybatisDemo { public static void main(String[] args) throws IOException { // 加载Mybatis核心配置文件，获取SqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //获取SqlSession对象，执行SQL SqlSession sqlSession = sqlSessionFactory.openSession(); //获取接口对象 UserMapper mapper = sqlSession.getMapper(UserMapper.class); //调用方法，执行sql List users = mapper.selectAll(); User user = mapper.selectById(0); System.out.println(users); System.out.println(user); //释放资源 sqlSession.close(); } } /** 执行结果 [User{id=0, name='你好'}, User{id=1, name='南雨'}] User{id=0, name='你好'} **/ 2.3 Mybatis核心配置文件 详细配置可见官网：Mybatis核心配置文件 environments：配置数据库连接环境信息，可以配置多个environment，通过default属性切换不同的environment，与Spring整合后，会被Spring所接管。 datasource：数据库连接池的配置，mybatis默认的数据库连接池为POOLED，将来也会被Spring所接管。 typeAliases：别名，可以用来指定实体类的名称，此处制定了实体类的包名，在映射文件中指定resultType时，只需要指定实体类名称即可，且不区分大小写。可以起到简化代码冗余的作用。 Mybatis核心配置文件中各配置的结构顺序必须如下： 2.4 结果映射 Mybatis操作的统一步骤： 编写接口方法：Mapper接口 参数传递 返回结果 在SQL映射文件中编写SQL语句 执行方法，测试 先看一个查询全部数据的小案例。 定义了一个Brand的实体类，如下： package com.nanyu.pojo; public class Brand { private int id; private String brandTitle; private String brandType; private int price; } 数据库中brand表如下： 对比发现，在Java中的字段使用驼峰命名法，而数据库中的某些字段使用下划线命名，这就导致了数据库中的一些字段与实体类中的某些字段的命名不一致，从而无法将数据库中查询出的数据与实体类中的属性对应上，实体类对象不能完成封装数据，就会出现如下的情况： [Brand{id=1, brandTitle='null', brandType='null', price=2}, Brand{id=2, brandTitle='null', brandType='null', price=25}, Brand{id=3, brandTitle='null', brandType='null', price=12000}] 对应不上的地方就会变为null。 在实际开发中也经常遇到这种情况，在Mybatis中提供了解决这一问题的方法，主要有以下两种方法: 编写SQL语句时起别名，如下： select id,brand_title as brandTitle,brand_name as brandName,price from brand; Mybatis还支持sql片段的形式编写sql语句 id ,brand_title as BrandTitle,brand_type as BrandType,price select from brand; 问题1： 上面这种方法有一定的缺陷，在数据表的属性过多时，使用这种方法会变的比较麻烦，而且代码可读性不强。 问题解决： 使用ResultMap进行结果映射 ResultMap结果映射： select * from brand; resultMap：负责结果集的映射，对不统一的字段进行结果映射，相当于一张映射表，ResultMap中包含result和id。 属性介绍： id：resultMap的唯一标识 type：需要映射的类型，填写对应的实体类即可，此处我在Mybatis核心配置文件中配置了包名，所以只需要写一个类名，如果没配置则需要写包名+类名 id：专门负责id的映射，column表示数据库中的字段名称，property表示实体类中的名称 result：负责除id外的其他字段的映射，column表示数据库中的字段名称，property表示实体类中的名称 使用ResultMap结果集时只需要使用resultMap属性并将其属性值设为resultMap的id值即可，如下： select * from brand; 另外，还需要补充一点知识： 参数占位符: { }：执行SQL时，会将占位符替换为？，将来自动设置参数值 ${ }：拼SQL，会存在SQL注入问题 使用时机： 参数传递，都使用#{ } 如果要对表名、列名进行动态设置，只能使用${ }进行sql拼接。 SQL语句中特殊字符处理：转义字符、 2.5 条件查询 在Mybatis中进行条件查询时SQL语句会做一些转换，如通过id查询用户映射文件中的SQl代码如下 select * from users where id = #{id}; 上面代码中有一个id参数，在进行参数传递时，SQL语句会转换成如下形式： select * from users where id= ?; 在真正的SQL语句中，参数会使用占位符？来代替，参数传递过来时，会替换占位符。 问题思考： Mybatis中如何接收多个参数？当只有一个参数时，可以直接进行传递，Mybatis就会自动把参数传递到SQL语句中的占位符中，但是如果有多个参数呢？ 问题解决： Mybatis中实现多参数传递的方式有三种：散装参数、实体类封装参数、map集合 方法一：使用@Param注解可以指定需要传递的参数，如下所示 //实体类中定义方法 List selectByTitleAndType(@Param(\"brandTitle\") String title, @Param(\"brandType\") String type, @Param(\"price\") int price); 在BrandMapper.xml映射文件中编写SQL语句 select * from brand where brand_title like #{brandTitle} and brand_type like #{brandType} and price = #{price}; 可以看到使用@Param注解可以将指定的参数传递到对应的占位符上 方法二：使用对象作为参数传递，需要在特定情况下使用，比如需要的参数就是一个对象中的所有字段，这时就可以将对象作为参数传递过去。 List selectByBrand(Brand brand); 在编写SQL时，未知参数不能随意起名，需要有一定的规范，要与Brand对象中的字段名相对应，Mybatis会自动匹配上这些参数。 select * from brand where brand_title like #{brandTitle} and brand_type like #{brandType} and price = #{price}; 方法三：使用Map集合传递参数，原理和对象一样，将参数封装为Map集合，Map集合的键为参数名，值为参数值。 /* Map map = new HashMap(); map.put(\"brandTitle\", \"铅笔\"); map.put(\"brandType\", \"教育\"); map.put(\"price\", 2); */ List selectByMap(Map map); 编写SQL时，未知值处的参数名要和Map集合中的键保持一致，Mybatis会自动匹配上这些参数。 select * from brand where brand_title like #{brandTitle} and brand_type like #{brandType} and price = #{price}; 2.6 动态条件查询 本章需记住以下几个标签：、、 SQL语句会随着用户输入或外部条件的变化而变化，称为动态SQL。 问题1： 用户在进行多条件查询时，可能不会输入全部的条件，如根据商品名、商品类型、商品价格查询商品信息时，用户可能只会输入前两个条件，这样就会造成查询失败。 问题解决： 使用动态SQL技术，即Java中所说的if-else判断。 Mybatis对动态SQL提供了以下的技术支持： if choose（when、otherwise） trim（where、set） foreach 如果不限制用户输入的条件个数可以用如下方式书写SQL，其中标签为判断语句，和Java中的if标签作用相同，if标签的text属性值填写判断语句，两个标签中为判断为真后的执行语句。 select * from brand where brand_title like #{brandTitle} and brand_title like #{brandType} and price = #{price}; 问题2： 上面的方式仍然会出现问题，第一个判断语句不需要连接词and/or，比如用户输入后两个参数而不输入第一个参数时，SQL语句就会变成如下所示。这样的SQL语句会出现❌，不能执行，因为where后面直接跟了and从而出现语法错误。 select * from brand where and brand_title like ? and price = ?; 这是普通方法不可避免的错误，解决这一错误有两种方法： 问题解决： 恒等式 在where后面紧跟一个1=1的恒等式，然后每个判断语句中都加入and，这样就不会出错，但是这种方法比较笨。 select * from brand where 1=1 and brand_title like #{brandTitle} and brand_title like #{brandType} and price = #{price}; 替换where Mybatisy也提供了解决这种错误的方法。就是将where换成标签，是Mybatis提供的专门用来解决在映射文件中写SQL出现部分语法错误的标签。 select * from brand and brand_title like #{brandTitle} and brand_title like #{brandType} and price = #{price}; 标签提供了自动处理上面问题的能力，使用该标签后的SQL语句如下： select * from brand where brand_title like ? and price = ?; 问题3： 如果用户想要从多个条件中选择一个条件该怎么办？ 问题解决： 这里就要用到Mybatis提供的choose（when otherwise）标签，此标签类似Java中的switch-case语句。 select * from brand where brand_title like #{brandTitle} brand_type like #{brandType} price = #{price}; 1=1 也可以使用如下方法省去otherwise标签 select * from brand brand_title like #{brandTitle} brand_type like #{brandType} price = #{price}; 标签类似Java中的switch 标签类似Java中的case 标签类似Java中的default 2.7 添加数据 添加数据相对比较简单，主要分为两种，一种是普通的添加数据，第二种是添加数据之后返回主键id，两种都有各自的使用场景。 第一种 insert into brand (brand_title, brand_type, price) values (#{brandTitle}, #{brandType}, #{price}) 第二种 insert into brand (brand_title, brand_type, price) values (#{brandTitle}, #{brandType}, #{price}) 参数说明： useGeneratedKeys：表示是否要开启主键返回 keyProperty：表示需要返回的键值在实体类中的属性名 2.8 动态修改数据 修改数据的SQL（在映射文件中）如下所示： update brand set brand_title=#{brandTitle}, brand_type=#{brandType}, price=#{price} where id = #{id} 问题1： 这种方法也存在一定的缺陷，即把SQL语句写死了，必须修改全部的数据，比如用户想修改资料，并且只想修改其中一个数据比如price，那么上面这种方法就没办法实现了。 问题解决： 使用动态SQL技术，同样使用if-else判断语句原理，与动态条件查询一样。如下，加入了判断，这样即使用户只想修改其中的某一个或两个属性值，也不会引起其他值被动修改。 update brand set brand_title=#{brandTitle}, brand_type=#{brandType}, price=#{price} where id = #{id} 问题2： 上面的问题同样会出现问题，因为SQL语句中进行修改时最后一个属性后面不需要加逗号，所以如果最后一个条件不存在（即本例中的price为null），则SQL语句会变成如下形式： update brand set brand_title= ?,brand_type= ?, where id = ?; 此时由于where后面多了个逗号，所以会报错。 问题解决： Mybatis也考虑到了这一点，所以Mybatis提供了一种方法，即把set替换为，做法和处理where条件查询时的做法一样，会自动处理这种语法问题，我们无需再费心解决。 update brand brand_title=#{brandTitle}, brand_type=#{brandType}, price=#{price} where id = #{id} 2.9 删除数据 删除数据有两种形式，一种是单个删除，一种是批量删除： 2.9.1 单个删除 单个删除很简单，就是通过传入一个ID，然后通过该ID删除对应的数据 delete from brand where id = #{id}; 但实际场景中经常涉及到批量删除的操作，比如商品后台，多选某些商品，然后批量删除操作。 2.9.2 批量删除 批量删除其实就是传递过来一个装有id的数组，然后在写映射文件时通过for循环遍历，依次删除对应id的数据 delete from brand where id in #{id} 属性介绍： collection：要遍历的数组名称，如果在接口中没有用@Param指定参数名，则默认此处写array item：遍历的每一项 separator：每一项之间用什么分割 open：拼接开始字符串 close：拼接结束字符串 上面批量删除转化为SQL语句如下： # ?为占位符,()是拼接而成的 delete from brand where id in (?,?,?,?......); 2.10 参数传递原理 具体原理可以查看Mybatis提供的ParamNameResolver类 2.10.1 多个参数 下面一行代码是Mapper接口中定义的方法 List selectByTitleAndType(String title,String type); 在Mybatis中进行参数传递时会将这两个参数封装为map集合，其中arg0、agr1、param1、param2是Mybatis默认起的名字。 map.put(\"arg0\",参数值1); map.put(\"param1\",参数值1); map.put(\"param2\",参数值2); map.put(\"arg1\",参数值2); 我们完全可以按照下面的形式传递参数 select * from brand where brand_title like #{arg0} and brand_type like #{arg1}; select * from brand where brand_title like #{param1} and brand_type like #{param2}; --> select * from brand where brand_title like #{arg0} and brand_type like #{param2}; --> 此时如果使用@Param注解来指定参数名，则@Param中的参数名会替换默认的arg键名，如下使用@Param指定参数名： List selectByTitleAndType(@Param(\"brandTitile\")String title,@Param(\"brandType\") String type); 指定后map集合会发生如下变化，所有位置的arg都会被@Param中指定的参数代替 map.put(\"brandTitile\",参数值1); map.put(\"param1\",参数值1); map.put(\"param2\",参数值2); map.put(\"brandType\",参数值2); 这样我们编写SQL语句时就可以直接使用我们指定的参数名来作为参数占位符 select * from brand where brand_title like #{brandTitile} and brand_type like #{brandType}; select * from brand where brand_title like #{param1} and brand_type like #{param2}; --> 此时就不能再使用arg作为参数占位符了，因为再map集合中找不到对应的键名。 2.10.2 单个参数 POJO类型：直接使用，属性名和参数占位符名一致 Map集合：直接使用，键名和参数占位符名保持一致 Collection：封装为Map集合，可以使用@Param注解替换Map集合中默认的arg名 map.put(\"arg0\",collection集合) map.put(\"collection\",collection集合) List：封装为Map集合，可以使用@Param注解替换Map集合中默认的arg名 map.put(\"arg0\",List集合) map.put(\"collection\",List集合) map.put(\"list\",List集合) Array：封装为Map集合，可以使用@Param注解替换Map集合中默认的arg名 map.put(\"arg0\",数组) map.put(\"array\",数组) 其他类型：直接使用，比如单个参数，无需使用@Param注解即可直接使用 建议：将来都使用@Param注解来修改Map集合中默认的键名，并使用修改后的名称来获取值，这样可读性更高。 2.11 注解开发 使用注解开发会比映射文件开发更方便 @Select：查询注解 @Insert：添加注解 @Update：更新注解 @Delete：删除注解 注解开发的简单演示 @Select(\"select * from brand where id=#{id}\") Brand selectById(int id); @Delete(\"delete from brand where id=#{id}\") void deleteById(int id); 这里引用Mybatis官方一句话 使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java注解不仅力不从心，还会让你本就复杂的SQL语句更加混乱不堪。因此，如果需要做一些很复杂的操作，最好用XML来映射语句。 选择何种方式来配置映射，以及认为是否应该要统一映射语句定义的形式，完全取决于你和你的团队。换句话说，永远不要拘泥于一种方式你可以很轻松的在基于注解和XML的语句映射方式间自由移植和切换。 简单总结一句话：注解完成简单功能，xml配置文件完成复杂功能 3. JavaScript JavaScript是一门跨平台、面向对象的脚本语言，来控制网页行为的，它能使网页可交互。此处省略了JavaScript基础语法部分，直接学习JavaScript的BOM和DOM两个对象。 记住一句话：遇到的所有东西先往对象上想，想想它是不是对象，这一章节重点是对象 3.1 BOM对象 BOM：Brower Object Model，浏览器对象模型，JavaScript将浏览器的各个组成部分封装为对象 组成： Window：浏览器窗口对象（一个浏览器窗口或者叫标签页就是一个对象） Navigator：浏览器对象，整个浏览器是一个对象 Screen：屏幕对象，整个屏幕就是一个对象 History：历史记录对象，浏览器历史记录也是一个对象 Location：地址栏对象，浏览器中的地址栏也是一个对象 此处Navigator、Screen因为用处不多，所以此处暂不介绍，后续会补上。 3.1.1 Window对象 Window：浏览器窗口对象 获取：直接使用window，其中window可以省略 属性：获取其他BOM对象，使用window可以获取到History、Navigator、Screen、Location对象 方法：window在调用方法时，window可以省略 方法名 说明 alert() 显示带有一段消息和一个确认按钮的警告框 confirm() 显示带有一段消息和取消按钮和确认按钮的警告框 setInterval() 按照指定的周期调用函数和计算表达式 setTimeOut() 在指定的毫秒后调用函数和计算表达式 alert()方法： // alert，弹出提示框，带确认按钮 window.alert(\"hello\") alert(\"hello~\") confirm()方法： confirm带有返回值，返回的结果为true和false，当点击”确定“时返回true，当点击“取消”时返回false，可根据用户点击的行为来确定执行哪一个分支。 //confirm，弹出提示框，带确认和取消按钮 window.confirm(\"你好\") var b = confirm(\"你好~\") if (b) { alert(\"你点了确定\") } else { alert(\"你点了取消\") } setTimeout(方法,毫秒值) 在一定时间间隔后执行一个方法，只执行一次 // setTimeout setTimeout(function() { alert(\"hello\") }, 3000) setInterval(方法,毫秒值) 在一定时间间隔后执行一个方法，循环执行 // setInterval setInterval(function() { alert(\"hello\") }, 3000) 3.1.2 Screen对象 后续补充 3.1.3 Navigator对象 后续补充 3.1.4 History对象 History：历史记录 获取：使用window.history获取，其中window可以省略 方法： 方法 说明 back() 加载history列表中的前一个url forward() 加载history列表中的下一个url // 前一个url window.history.back() // 后一个url window.history.forward() 3.1.5 Location对象 Location：地址栏对象 获取：使用window.location获取，其中window.可以省略 方法： 方法 说明 href 设置或返回完整的URL var flag = window.confirm(\"是否要跳转？\") if (flag) { window.location.href = \"https://www.dingzijun.top\" } else { alert(\"取消跳转\") } 小案例，3秒之后跳转链接 window.document.write(\"3秒之后跳转到个人博客！\") setTimeout(function go() { location.href = \"https://www.dingzijun.top\" }, 3000); 3.2 DOM对象 DOM：Document Object Model，文档对象模型，JavaScript将标记语言的各个组成部分封装为对象 Document：整个文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment注释对象 3.2.1 获取Element对象 Element：元素对象 获取：使用Document对象的方法来获取 getElementById：根据Id属性值来获取，返回一个Element对象 getElementsByTagName：根据标签名来获取，返回一个Element对象数组 getElementsByName：根据name属性值来获取，返回一个Element对象数组 getElementsByClassName：根据class属性值来获取，返回一个Element对象数组 Document 测试0 测试1 跑步 篮球 足球 // 通过id名获取元素对象 var img = document.getElementById(\"light\") alert(img) // 通过标签名获取元素对象 var divs = document.getElementsByTagName(\"div\") for (let i = 0; i 3.2.2 常见Html Element对象的使用 具体见：元素对象文档 所谓获取元素对象就是使用上面的方法，获取到指定的元素，此时获取出的元素是一个元素对象，比如document.getElementById(\"light\")获取到img对象，img标签中的src、alt相当于img类中的属性值，img对象提供了修改这些属性值的方法（见文档）。 有些属性属于元素对象的私有属性，有些属性属于公共属性，比如下面四个例子 下面img的src属性就是用来修改img标签值的私有属性。 // 通过id名获取元素对象 var img = document.getElementById(\"light\") // 使用img对象调用方法修改src的属性值 img.src=\"https://www.dingzijun.top\" 下面修改input内复选框的checked属性是input的私有属性 Document 跑步 篮球 足球 var inputs = document.getElementsByName(\"sport\") for (let i = 0; i 下面修改字体颜色的style属性就是公共属性，所有元素对象都可以调用该属性 // 获取div数组对象 var divs = document.getElementsByTagName(\"div\") // 修改第一个div对象内字体的颜色 divs[0].style.color = \"red\" 下面修改div内部字体的innerHTML属性也是公共属性 Document 测试0 测试1 var divs = document.getElementsByTagName(\"div\") divs[0].style.color = \"red\" divs[1].innerHTML = \"啦啦\" 这些记忆起来很麻烦，只需要记住最常用的几个即可，其他的需要的时候查阅文档即可。 3.3 事件监听 事件：HTML事件是发生在HTML元素上的事情，比如： 按钮被点击 鼠标移动到元素之上 按下键盘按键 事件监听：JavaScript可以在事件被侦测到时执行代码 3.3.1 事件绑定 事件绑定的两种方式： 方式一：通过HTML标签中的事件属性绑定 function on() { alert(\"我被点击了！\") } 这种方法是通过input标签内部的onclick属性绑定一个方法，每次input标签被点击时就会触发该方法。 方式二：通过DOM元素属性绑定（推荐） document.getElementById(\"click\").onclick = function() { alert(\"我被点击了！\") } 这种方法是先获取到对应的元素对象，然后再使用该元素对象的onclick属性绑定函数 3.3.2 常见事件 事件名 说明 onclick 鼠标点击事件 onblur 元素失去焦点 onfocus 元素获得焦点 onload 某个页面或图像被完成加载 onsubmit 当表单提交时出发 onkeydown 某个键盘的键按下 onmouseover 鼠标移到某元素之上 onmouseout 鼠标从某个元素上移开 4. HTTP协议 了解HTTP协议之前先来了解一下浏览器（客户端）与服务器（服务端）交互流程，用一张图简单表示。 浏览器即我们的客户端，会根据一个URL向指定服务器发送一个请求（request），服务器接收到请求之后需要对请求进行处理，请求处理完毕后会将结果返回给浏览器，这个过程叫响应（response）。 HTTP协议：超文本传输协议Hypertext Trabsfer Protocol HTTP协议是一个客户端请求和响应的标准协议，这个协议详细规定了浏览器和万维网服务器之间相互通信的规则。通俗的讲，就是在客户端和服务器通信上加一个标准（通信规则），这个标准规定了客户端发送请求时应该怎样发送，服务器端收到请求时该怎么回应。 就像是两个说着不同方言的人交流，两个人说各自的方言谁都听不懂，所以这时就需要有一个标准来使双方在交流的过程中都能明白双方传达的什么意思，HTTP协议就是这个标准，就是双方的通信规则。 通信规则规定了客户端发送给服务器的内容格式，也规定了服务器发送给客户端的内容格式。客户端发送给服务器的格式叫“请求协议”，服务器发送给客户端的格式叫“响应协议”。 4.1 浏览器中的书写格式 服务端资源需要通过浏览器进行，此时由浏览器将我们黑出的请求解析为满足HTTP协议的格式并发出。我们发出的请求格式需要按照浏览器规定的格式来书写，在浏览器中书写格式如下： 当浏览器获取到信息以后，按照特定格式解析并发送即可。接收到服务器端给出的响应时，也按照HTTP协议进行解析获取到各个数据，最后按照特定格式展示给用户。 4.2 HTTP协议的特点 支持客户/服务器模式。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP 允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。 无连接：无连接是表示每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 HTTP1.1版本后支持可持续连接。通过这种连接，就有可能在建立一个TCP连接后，发送请求并得到回应，然后发送更多的请求并得到更多的回应。通过把建立和释放TCP连接的开销分摊到多个请求上，则对于每个请求而言，由于TCP而造成的相对开销被大大地降低了。而且，还可以发送流水线请求,也就是说在发送请求1之后的回应到来之前就可以发送请求⒉.也可以认为，一次连接发送多个请求，由客户机确认是否关闭连接，而服务器会认为这些请求分别来自不同的客户端。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 4.3 URL格式 日常我们在浏览器冲浪时，经常在浏览器地址栏中输入一个链接，敲个回车就能跳转到想去的页面，这个链接就是URL，中文名叫统一资源定位符，比如下面访问我博客的地址： http://www.dingzijun.top 实际上，HTTP URL的格式如下： http://host[:port]/[path] http://IP:端口/访问的资源路径 http：表示要通过HTTP来定位网络资源 host：表示合法的主机域名或IP地址 port：指定一个端口号，为空则默认80（80称为缺省端口） path：指定请求资源的路径 4.4 HTTP请求 HTTP请求由三部分组成，分别是：请求行、请求头、请求体。 4.4.1 Get请求 Get请求不包含请求体，如果需要传递参数，则其参数直接跟到请求路径后，比如使用百度搜索时： https://www.baidu.com/s?wd=你好 https://www.baidu.com/s?wd=你好&你不好 上面路径中www.baidu.com表示要访问的主机对应的域名，s表示要请求的资源路径，需要传递参数时用？隔开，wd=你好表示需要传递的键值对形式的参数，当需要传递多个参数时，只需要用&隔开即可。 4.4.2 POST请求 Post请求会向后端服务器传递一组数据，最常见的使用场景是登录、注册功能时使用。 4.5 HTTP响应 在接收和解释请求消息后，服务器返回一个HTTP响应消息。HTTP响应也是由三个部分组成，分别是：响应行、响应头、响应体。 响应行：响应数据的第一行，其中HTTP/1.1表示协议版本，200表示响应状态码，OK表示状态码描述 响应头：第二行开始，格式为key：value形式 响应体：最后一部分数据，存放响应数据。 5. Tomcat Web服务器是一个应用程序（软件)，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。主要功能是“提供网上信息浏览服务” 概念: Tomcat是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet/JSP少量JavaEE规范。 心 JavaEE: Java Enterprise Edition，Java企业版。指Java企业级开发的技术规范总和。包含13项技术规范:JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAF Web服务器的作用： 封装HTTP协议操作，简化开发 可以将Web项目部署到服务器中，对外提供网上浏览服务 Tomcat是一个轻量级的Web服务器，支持Servlet/JSP少量JavaEE规范，也称为Web容器，Servlet容器。 5.1 下载与安装 Tomcat下载页：下载页 选择对应的版本下载即可。 我这里选择8版本 找到bin目录 根据你电脑的位数选择对应的压缩包下载，zip结尾是Windows系统的，gz结尾是Linux系统的。根据自己系统和位数下载即可。（也可以下载.exe文件） Tomcat的安装比较简单，如果你下载的是zip压缩包形式，直接解压，解压目录不要有中文，然后配置环境变量即可（可选） 各文件夹简介 5.2 基本使用 找到bin目录，点击startup.bat启动Tomcat，shutdown.bat关闭Tomcat 启动后会出现乱码，需要修改一下编码： 找到conf下的logging.properties 用记事本打开，修改日志输出的编码为GBK 修改完成之后就不会出现乱码 在server.xml中可以配置Tomcat的启动端口号和其他配置 Tomcat默认端口号为8080 webapps目录是Tomcat存放项目文件的目录，里面存放了几个Tomcat的默认项目，在浏览器输入URL后默认启动的是ROOT项目。如果要部署自己的项目，只需要将自己的项目文件放在webapps目录下即可，如图中myproject就是我自己的项目。 输入URL后即可访问到项目 访问自己的项目时需要加上对应路径。 Java项目打包一般会被打包成war包，Tomcat可以自动识别并解压war包，只需要将war包放到webapps目录下，无需解压，Tomcat启动时会自动解压war包。 5.3 创建Maven Web项目 在IDEA中创建Maven Web项目的方式有两种，一种是使用骨架的方式创建，一种是不使用骨架的方式创建。 骨架方式创建Web项目 在创建Maven项目时选中Create from archetype，然后在下面选中：maven-archetype-webapp，点击next 修改项目名称以及项目信息，然后点next 下面是项目信息，直接点finash即可 项目创建完成，项目结构如下： 但是这个项目中还缺少了两个目录，即用来写java代码和存放资源的的java和resource目录，选中main，右键创建这两个目录即可。 为了简化项目，把pom.xml中多余的依赖和插件全部删掉，只保留部分重要配置，保留如下配置 此时便是一个纯净的Maven Web项目。 pom.xml中的配置尤为重要，因为是Web项目，所以需要打包为war包，如果不加这个配置，则默认会打成jar包。 不使用骨架 创建mave项目，直接点击next 修改项目名称及基本信息 项目目录 在pom.xml文件中添加war 项目中缺少webapp目录，可以手动创建即可 5.4 IDEA集成本地Tomcat 第一种部署方式 点击右上角Add COnfiguration 点击+号，下拉找到Tomcat选择Local（本地，remote表示远程） 可以修改Tomcat名称，同时需要配置Application Server 然后部署项目到Tomcat，点击Deployment，然后点击左下角+，选择需要添加的项目即可。 然后点击Apply，最后点击OK，部署完成。 第二种部署方式： 第二种部署方式更为简单，只需要在pom.xml中引入Tomcat插件即可。 org.apache.tomcat.maven tomcat-maven-plugin 2.2 6. Servlet Servlet是Java提供的一门动态web资源开发技术，狭义的Servlet指Java语言实现的一个接口，宏观的Servlet指所有实现了这个接口的类。 静态资源：所有用户访问时页面都一样，由Html、Css、Javascript打造而成的网页 动态资源：根据用户的不同会产生不同的页面，最简单的比如美团外卖会根据用户所在城市的不同，返回不同城市的外卖信息。 Servlet就是专门开发动态资源的一门技术，Servlet是JavaEE规范之一，其实就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由Web服务器运行Servlet 下面是Servlet接口，我们自定义的Servlet类要实现这一接口： package javax.servlet; import java.io.IOException; public interface Servlet { void init(ServletConfig var1) throws ServletException; ServletConfig getServletConfig(); void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException; String getServletInfo(); void destroy(); } 6.1 快速入门 创建web项目，导入Servlet依赖 javax.servlet javax.servlet-api 3.1.0 provided 创建：定义一个类，实现Servlet接口，并重写接口中所有方法，并在service方法中输入一句话 package com.nanyu; import javax.servlet.*; import java.io.IOException; public class ServletDemo implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { } @Override public String getServletInfo() { return null; } @Override public void destroy() { } } 配置：在类上使用@WebServlet注解，配置该Servlet的访问路径 @WebServlet(\"/demo1\") public class ServletDemo implements Servlet { 访问：启动Tomact，在浏览器输入URL，访问该Servlet service方法会被自动执行，输出到控制台上 6.2 Servlet生命周期 Servlet由谁创建？Servlet方法由谁调用？ Servlet由web服务器（Tomcat，）创建，同时也由web服务器（Tomcat）调用 Tomcat服务器怎么知道我们自定义的Servlet中一定有service方法 因为我们要自定义Servlet就必须实现Servlet接口，实现该接口就必须复写Servlet接口中的所有方法，必须复写service方法。所以Tomcat知道我们自定义的Servlet中一定有service方法。 Servlet生命周期 对象的生命周期指一个对象从被创建到被销毁的整个过程 Servlet运行在Servlet容器（Web服务器）中，其生命周期由容器管理，分为4个阶段 加载和实例化：默认情况下，当Servlet第一次被访问时，由容器创建对象 初始化：在Servlet实例化之后，容器将调用Servlet的init()方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作，该方法只调用一次。 请求处理：每次请求Servlet方法时，Servlet都会调用service()这个方法对请求进行处理。 服务终止：当需要释放内存时，Servlet容器都会调用Servlet实例的destory()方法完成资源释放。在destory()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收。 loadOnStartup： 在访问Servlet之前，Tomcat会先将我们自定义的Servlet创建为Servlet对象，生成对象的时机有两种 第一种：在Tomcat启动时就会自动创建对象 第二种：第一次访问Servlet时被创建对象 @WebServlet(value = \"/demo1\",loadOnStartup = 1) public class ServletDemo implements Servlet { 如果loadOnStartup值为负整数，则第一次访问时创建Servlet；当其值为0或正整数时，Tomcat服务器启动时创建Servlet对象，数字越小优先级越高。 6.3 Servlet方法介绍 自定义的Servlet需要实现Servlet接口，并复写接口中的方法，，共有五个方法，下面简单介绍init()、service()、destory()这三个方法 init()方法 初始化方法：Servlet第一次被访问时会创建实例化对象（Tomcat完成），创建对象后就会执行该初始化方法，且该方法只执行一次 /** * 初始化方法 * 调用时机：默认情况下，Servlet第一次被访问时会创建ServletDemo对象，该对象一创建就会调用init()方法 * 调用次数：一次 * @param servletConfig * @throws ServletException */ @Override public void init(ServletConfig servletConfig) throws ServletException { } service()方法 service是提供服务的方法，每访问一次Servlet就会调用一次该方法，比如在页面上刷新一次就会调用一次该方法。 service方法重要用来做业务处理，比如前端传来的请求信息，会在service方法中被解析然后封装到request对象中。还会设置服务器的响应数据，将其封装为response对象返回给前端。 /** * 提供服务 * 调用时机：每访问一次SDervlet就会调用一次 * 调用次数：多次 * @param servletRequest * @param servletResponse * @throws ServletException * @throws IOException */ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { // 该方法会自动被执行 System.out.println(\"service会被自动执行\"); } destory()方法 内存释放或服务器关闭时，Serclet对象会被销毁，此时调用该方法销毁Servlet对象 /** * Servlet销毁方法 * 调用时机：内存释放或服务器关闭时，Serclet对象会被销毁，此时调用该方法 * 调用次数：一次 */ @Override public void destroy() { System.out.println(\"我只在Servlet销毁时被调用一次！\"); } getServletInfo()方法 用来获取信息，这些信息一般没什么用，所以一般返回null或空字符串 /** * 获取信息 * @return */ @Override public String getServletInfo() { return null; } getServletConfig()方法 获取ServletConfig对象 /** * 获取ServletConfig对象 * @return */ @Override public ServletConfig getServletConfig() { return null; } 最常用的方法是service()，其他四个方法都不常用，但因为实现了Servlet接口，所以还不得不将这四个方法复写一遍，因此Java又使用HttpServlet对Servlet的实现类进行集成，简化了Servlet操作。 6.4 Servlet体系结构 下面就是Servlet的体系结构（具体见源码）： Servlet：根接口，提供五个方法 GenericServlet：Servlet的实现类，该类为抽象类，只有方法，没有方法体 HttpServlet：对Http协议封装的Servlet的实现类，继承自GenericServlet。 我们将来开发B/S架构的web项目，都是针对Http协议，因此我们自定义的Servlet会继承HttpServlet package com.nanyu; import javax.servlet.http.HttpServlet; public class HttpServletDemo extends HttpServlet { } HttpServlet有什么作用？ HttpServlet继承自GenericServlet，而GenericServlet又是实现Servlet接口的抽象类，所以GenericServlet中包含Servlet的五个方法，又因为HttpServlet继承自GenericServlet，所以HttpServlet自然也继承了这五个方法。 HttpServlet最重要的作用是对Http协议进行处理，我们都知道service是专门处理业务逻辑的方法，在HttpServlet类中，service方法主要用来解析从前端传来的请求，将请求解析后封装为request对象，供我们调用，另外一个作用是设置response数据，封装为response对象返回给前端。 Http协议中有多种请求方式，不同的请求方法需要执行操作不同，在HttpServlet中会判断请求过程中的请求方式，根据请求方式的不同执行不同的操作，比如请求有Get和Post请求两种（当然不止这两种，用这两种作为演示），首先会在service中判断请求方法是Get请求还是Post请求，如果是Get请求则执行doGet()方法，如果是Post请求，执行doPost()方法。 下面的几个doGet、doPost、doPut等方法都是来自HttpServlet类中，他们分别代表了不同的请求方式执行对应的方法。这里的HttpServletDemo只不过继承了HttpServlet类，对该类中的方法进行了复写。 package com.nanyu; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/demo2\") public class HttpServletDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"前端的请求方式为Get，下面执行Get请求对应的操作\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"前端的请求方式为Post，下面执行Post请求对应的操作\"); } @Override protected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"前端的请求方式为Delete，下面执行Delete请求对应的操作\"); } @Override protected void doHead(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"前端的请求方式为Put，下面执行Put请求对应的操作\"); } } 如下，直接访问该路由（默认Get方式） 后台会执行doGet方法 HttpServletyu原理： 其实原理很简单，但为了为了更加了解Servlet体系，我们可以自定义HttpServlet。如下，其中定义两个方法doGet()、doPost()，service中对请求方式进行判断，如果是Getqing请求方式，执行doGet()，如果是Post请求方式，执行doPost()。 HttpServlet中就是这原理，只不过比这略微复杂。 package com.nanyu; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import java.io.IOException; public class MyHttpServlet implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest req, ServletResponse servletResponse) throws ServletException, IOException { HttpServletRequest request=(HttpServletRequest) req; String method = request.getMethod(); if (\"GET\".equals(method)){ doGet(); }else if(\"POST\".equals(method)){ doPost(); } } private void doPost() { System.out.println(\"如果是Post请求方式，执行该方法\"); } private void doGet() { System.out.println(\"如果是Get请求方式，执行该方法\"); } @Override public String getServletInfo() { return null; } @Override public void destroy() { } } 6.5 Request Request：获取请求数据，Tomcat会解析从前端获得的请求，解析完成之后将解析出的数据封装到Request对象中。 进行项目开发时我们可以从request对象中获取数据。比如我们要做登录案例，用户输入用户名和密码后浏览器会将这些信息统一转换为请求字符串发送至后端，Tomcat会解析请求并封装为request对象，我们只需要从request获取到用户名和密码再进行判断即可实现业务。 6.5.1 Request继承体系 Request的继承体系如下（即Request对象怎么来的）： ServletRequest：Java提供的请求对象根接口 HttpServletRequest：Java提供的对Http协议封装的请求对象接口，该接口继承自ServletRequest，该接口仅用于处理Http协议的Request对象 RequestFacade：实现类，该类由Tomcat实现 为什么实现类由Tomcat实现而不是Java实现？ 因为Tomcat要解析Http请求，封装为Request对象，同时创建的request对象要传递到service中（Response也是如此） 6.5.2 获取请求数据 请求行：GET /servletdemo1_war/demo2?name=1 HTTP/1.1 方法 说明 举例 String getMethod() 获取请求方式 GET/POST String getContextPath() 获取虚拟目录 /servletdemo1_war StringBuffer getRequestURL() 获取URL http://localhost:8080/servletdemo1_war/demo2?name=1 String getRequestURI() 获取URI /servletdemo1_war/demo2 String getQueryString() 获取请求参数 name=1 package com.nanyu; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/demo2\") public class HttpServletDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 请求方法 String method = req.getMethod(); System.out.println(method); // 虚拟目录 String contextPath = req.getContextPath(); System.out.println(contextPath); // 获取URL StringBuffer requestURL = req.getRequestURL(); System.out.println(requestURL.toString()); // 获取请求地址 String requestURI = req.getRequestURI(); System.out.println(requestURI); // 获取请求参数 String queryString = req.getQueryString(); System.out.println(queryString); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } /** 输出结果： GET /servletdemo1_war http://localhost:8080/servletdemo1_war/demo2 /servletdemo1_war/demo2 null **/ 请求头 方法 说明 String getHeader(String name) 根据请求头名称获取值 package com.nanyu; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/demo2\") public class HttpServletDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 获取请求头 String header = req.getHeader(\"user-agent\"); System.out.println(header); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } /** Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Edg/96.0.1054.62 **/ 请求体（只有Post请求有请求体） 方法 说明 ServletInputStream getInputStream() 获取字节输入流 BufferedReader getReader() 获取字符输入流 字节输入流是以字节为单位读取数据，数据可以是图片、音频、视频、文件等。字符输入流是以单个字符为单位读取数据，读取的数据就是一个一个的字符串。 package com.nanyu; import javax.servlet.ServletException; import javax.servlet.ServletInputStream; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.IOException; @WebServlet(\"/demo2\") public class HttpServletDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 获取请求体 BufferedReader reader = req.getReader(); String line = reader.readLine(); System.out.println(line); } } 对于Post请求获取请求参数的方式是使用getInputStream()和getReader()两种方法。而对于Get请求，获取其参数是通过getQueryString()方法。 6.5.3 请求参数获取 请求参数的获取： Get方式：getQueryString() Post方式：getReader() 思考： GET请求和POST请求的区别主要在于请求参数的位置不一样，因此需要用不同的方法获取请求参数，是否可以提供一种统一的获取请求参数的方式，从而统一doGet和doPost方法内的代码？ 其实就是做一个判断，判断是Get请求还是Post请求，如果是Get请求就执行getQueryString()来获取请求参数，如果是POST请求，就执行getReader()获取请求参数，下面是伪代码： String method = req.getMethod(); if(\"GET\".equals(method)){ String param = req.getQueryString(); }else if(\"POST\".equals(method)){ BufferedReader reader = req.getReader(); String param = reader.readLine(); } 统一获取请求参数的这一问题其实Request已经为我们解决掉了，同时Request还做了以下处理： 获取到的请求参数是一长串的字符串，Request先使用’&‘对字符串进行分割； 再使用‘=’再对字符串分割； 将分割后的数据存入Map集合，用的时候直接调用该Map集合即可 因为一个键值可能不止对应一个参数值，所以用数组包含所有参数值 Request对象提供了以下通用方法获取Get方式和Post方式的请求参数： Map getParameterMap()：获取所有参数的Map集合 String[] getParameterValues(String name)：根据名称获取参数值（数组） String getParameter(String name)：根据名称获取参数值（单个值，明知参数值是单个值的前提下） @WebServlet(\"/demo2\") public class HttpServletDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // getParameterMap，获取存储所有参数的Map集合 Map parameterMap = req.getParameterMap(); for (String key:parameterMap.keySet()){ System.out.println(key+\":\"); String [] values=parameterMap.get(key); for (String value:values){ System.out.println(value+\" \"); } System.out.println(); } // getParameterValues，获取指定键值的参数值，sport为input多选框，所以用数组 String[] sports = req.getParameterValues(\"sport\"); // getParameter，获取指定键值对应的参数值（单个值），只有一个值 String username = req.getParameter(\"username\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } 总结：我们不需要再关注如何实现Get请求和Post请求的请求参数获取，这些Request已经帮我们实现了，同时Request还将获取到的请求参数进行了解析，将解析出的数据存放在Map集合中，同时还向我们提供方法以便我们获取这些参数值。 6.5.4 请求参数中文乱码 只在Tomcat7及以下版本出现，Tomcat8以及更改了字符集的编码 使用getParameter、getParameterValues方式获取参数时如果有中文，则获取到的中文会乱码，要解决这种问题需要分Get请求和Post请求 Post请求 Post请求比较简单，上面介绍Request统一读取请求数据的原理时讲到，Request底层做了判断，如果是GET请求，就执行getQueryString读取数据，如果是Post请求，就执行getReader来读取数据。 因为Post请求获取数据的方式是getReader()方法，使用流（字符流，另一个是字节流）的方式获取数据。而在Tomcat7及以前的版本获取流时默认采用编码格式是ISO-8859-1，因此会出现乱码，解决很简单，只需要设置流的读取方式为UTF-8即可。 只需要加入下面一行代码即可： req.setCharacterEncoding(\"UTF-8\"); 对于GET请求，则不能用这种方式更改编码方式 GET请求 如果请求方式为GET，则执行getQueryString读取请求数据，因为getQueryString()方法并不是采用流的方式获取请求数据，所以设置流的编码方式来解决中文乱码是行不通的 要想解决GET请求中文乱码问题，需要对GET请求的请求参数传递过程进行分析 在表单中输入”张三“后浏览器并不认识这些字符，浏览器会使用UTF-8将这些字符进行编码，将编码后的数据传递给服务器，服务器端进行解码 浏览器端操作如下： 使用UTF-8对中文参数进行编码，一个中文需要用三个字符表示，所以“张三”这两个中文汉字需要有6个字符表示 计算机中需要将字符转换为计算机所能识别的二进制01组成的数字，一个字符占8为，所以六个字符共占48位 转换为二进制之后的“张三”表示如下： 再将这些二进制转为16进制，上面转为16进制后如下：E5 BC A0 E4 B8 89 浏览器又在每两个十六进制数之间用%隔开，就转换为了：%E5%BC%A0%E4%B8%89 最后将%E5%BC%A0%E4%B8%89作为请求参数传递给服务器 现在的Chrome、Edge、FireFox等浏览器都已经支持在地址栏中将请求参数中文显示了，一些老的浏览器比如IE浏览器还是会将参数转换为上面的形式传递，如下 服务器端操作如下： 使用getQueryString()或getReader()获取请求参数%E5%BC%A0%E4%B8%89 对%E5%BC%A0%E4%B8%89进行解码操作 使用ISO-8859-1对请求参数进行解码 通过对比我们不难发现，在浏览器端进行编码时采用的是UTF-8格式，而在服务端对请求参数进行解码时使用的是ISO-8859-1，解码和编码方式不统一，所以会造成乱码。 那么如何解决编码问题？ 浏览器端对请求参数的编码我们无法改变，所以我们只能在服务端进行修改 下面是编码与解码的一个小案例： package com.nanyu; import java.io.UnsupportedEncodingException; import java.net.URLDecoder; import java.net.URLEncoder; public class UrlDemo { public static void main(String[] args) throws UnsupportedEncodingException { String username=\"张三\"; // URL编码 String encode = URLEncoder.encode(username, \"UTF-8\"); System.out.println(encode); //%E5%BC%A0%E4%B8%89 //URL解码 String decode = URLDecoder.decode(encode, \"UTF-8\"); System.out.println(decode);// 张三 } } 应用该原理到解GET请求参数乱码上面如下： @WebServlet(\"/demo2\") public class HttpServletDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // GET请求参数乱码问题解决 // 此时获取到的值是经过ISO-8859-1解码过的值 乱码数据 String username = req.getParameter(\"username\"); // 先使用ISO-8859-1对ISO-8859-1解码过的值进行编码 %E5%BC%A0%E4%B8%89 String encode = URLEncoder.encode(username, \"ISO-8859-1\"); // 再使用UTF-8对上面使用ISO-8859-1编码过的值进行解码 张三 String decode = URLDecoder.decode(encode, \"UTF-8\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // POST请求参数乱码问题解决 req.setCharacterEncoding(\"UTF-8\"); } } 或者用下面的方式，效果其实都一样： package com.nanyu; import javax.servlet.ServletException; import javax.servlet.ServletInputStream; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.IOException; import java.net.URLDecoder; import java.net.URLEncoder; import java.nio.charset.StandardCharsets; import java.util.Enumeration; import java.util.Map; @WebServlet(\"/demo2\") public class HttpServletDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 此时获取到的值是经过ISO-8859-1解码过的值 乱码数据 String username = req.getParameter(\"username\"); // 先使用ISO-8859-1对ISO-8859-1解码过的值进行编码 转换为字节数组 byte[] bytes = username.getBytes(StandardCharsets.ISO_8859_1); // 使用UTF-8对字节数组进行解码 username = new String(bytes, StandardCharsets.UTF_8); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"UTF-8\"); this.doGet(req,resp); } } 6.5.5 Request请求转发 请求转发（forward）：一种在服务器内部资源跳转的方式。 简单来说，就是进行路由间的跳转，在一个路由内没有完成的工作交给下一个路由来做，类似流水线。如下：资源A处理了一部分数据，另外一部分数据的处理交给资源B，因此请求转发还涉及到数据共享。 实现方式： req.getRequestDispatcher(\"资源路径\").forward(req,resp); // req.getRequestDispatcher(\"/demo2\").forward(req,resp); /** * 请求转发 */ @WebServlet(\"/demo1\") public class HttpServletDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"demo1......\"); // 请求转发 req.getRequestDispatcher(\"/demo2\").forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 因为涉及两个路由之间的数据传递，因此需要数据共享，Request对象提供了数据共享的方法。 void setAttribute(String name,Object o)：存储数据到trquest域中 Object getAttribute(String name)：根据key，获取值 void removeAttribute(String name)：根据key，删除该键值对 使用方法如下： /** * 请求转发 */ @WebServlet(\"/demo1\") public class HttpServletDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"demo1......\"); // 请求转发 req.setAttribute(\"msg\",\"hello\"); req.getRequestDispatcher(\"/demo2\").forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } @WebServlet(\"/demo2\") public class HttpServletDemo2 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"demo2......\"); Object msg = req.getAttribute(\"msg\"); System.out.println(msg); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 请求转发的特点： 浏览器地址栏路径不发生变化 只能转发到当前服务器的内部资源，即只能跳转到该服务器（Tomcat）内的路由 一次请求，可以在转发的资源间使用request共享数据。 6.6 Response Response：设置响应数据，我们可以在Servlet的service方法中设置响应数据，封装到Response对象中。Tomcat在传递响应数据之前会从Response对象中取出我们设置的对象，拼接成字符串从而构成响应数据返回给浏览器。 6.6.1 Response继承体系 Response对象继承体系如下（与Request对象几乎一样）： 此处和Request原理什么的都相同，不做过多介绍 6.6.2 Response设置响应数据 Response响应数据有三部分： 相应行：HTTP/1.1 200 OK 方法 说明 举例 void setStatus(int sc) 设置响应状态码 200 响应头：Content-Type：text/html 方法 说明 void setHeader(String name,String value) 设置响应头键值对 响应体：... 方法 说明 PrintWriter getWriter() 获取字符输出流 ServletOutputStream getOutputStream() 获取字节输出流（图片、文件） 6.6.3 Response完成重定向 重定向(Redirect)：一种资源跳转方式 语言描述资源重定向的过程即是：浏览器先请求资源A，资源A无法满足浏览器请求，并响应给浏览器说资源B可以满足浏览器请求，并将资源B的访问路径一并响应浏览器，浏览器根据响应过来的数据，重新访问资源B，这个过程就叫资源重定向。 重定向的实现方式一： resp.setStatus(302) resp.setHeader(\"location\",\"资源B的路径\") 重定向实现方式二： resp.sendRedirect(\"/servletdemo1_war/resp2\"); 第一种实现方式比较麻烦，第二种实现方式更加简介，而且第二种是第一种的进一步封装，调用sendRedirect方法后底层自动封装好响应状态为302。 案例实操： 定义一个资源A，用于重定向 @WebServlet(\"/resp1\") public class HttpServletDemo3 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 第一种写法-麻烦 // resp.setStatus(302); // resp.setHeader(\"location\",\"/servletdemo1_war/resp2\"); // 第二种方式 resp.sendRedirect(\"/servletdemo1_war/resp2\"); // 重定向到服务器外部资源 // resp.sendRedirect(\"https://www.dingzijun.top\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 定义一个资源B，用于重定向到此处 ![76](javawebimg/76.png)@WebServlet(\"/resp2\") public class HttpServletDemo4 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"resp2......\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 当在浏览器中输入http://localhost:8080/servletdemo1_war/resp1时，会自动跳转到http://localhost:8080/servletdemo1_war/resp2，响应数据如下 重定向特点： 浏览器地址栏路径发生变化 可以重定向到任意位置的资源（服务器内部、服务器外部） 两次请求，两个request域，不能在多个资源使用request共享数据 与请求转发的特点进行对比可以发现，重定向的每一条特点刚好与请求转发的相反 6.6.4 路径问题 对比请求转发和重定向的代码： // 请求转发 req.getRequestDispatcher(\"/demo2\").forward(req,resp); // 重定向 resp.sendRedirect(\"/servletdemo1_war/resp2\"); 上面的代码对比我们可以看到路径上的不同，重定向的代码路径中比请求转发多了虚拟目录servletdemo1_war，对于何时加虚拟目录何时不加，要明确下面一个问题 路径给谁使用？ 浏览器使用：需要加上虚拟目录 服务器使用：不需要加虚拟目录 请求转发是将请求转发至下一个资源，是服务器做的工作，所以他提供的路径是给服务器用，只需要给服务器一个请求路径，就能自动识别出。 而对于重定向，是浏览器从第一次请求的响应数据中获取到目标重定向的路径，再拼接路径发起第二次请求，发起请求的过程是浏览器做的，如果不提供虚拟目录，浏览器无法大访问到项目。 为了能动态获取到虚拟目录，往往使用下面的方法： // 动态获取虚拟目录 String contextPath = req.getContextPath(); resp.sendRedirect(contextPath+\"/resp2\"); 6.6.5 Response响应字符数据 通过response对象设置响应数据 @WebServlet(\"/resp3\") public class HttpServletDemo5 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 获取字符输入流 PrintWriter writer = resp.getWriter(); writer.write(\"aaa\"); writer.write(\"hello\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 但是仅仅这样写到响应体中的数据是纯文本，如下图，返回的Html标签会被当做纯文本解析 可以通过下面的方法设置响应体中数据的格式，这行代码指明，响应体中的数据是Html格式，浏览器接收到数据之后要使用Html对数据进行解析。 // 设置响应头中的content-type resp.setHeader(\"content-type\",\"text/html\"); 但是上面这种方式无法解决中文乱码问题(中文乱码的原因在于PrintWriter writer输出流编码格式为ISO-8859-1)，所以我们一般不用这个方法，用另外一种更相近的方法。 resp.setContentType(\"text/html;charset=utf-8\"); 上面这种方法，可以设置PrintWriter writer输出流的字符编码格式，从而避免中文乱码，具体使用见下： @WebServlet(\"/resp3\") public class HttpServletDemo5 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // resp.setHeader(\"content-type\",\"text/html\"); // 设置输出流编码格式以及响应数据格式 resp.setContentType(\"text/html;charset=utf-8\"); // 获取字符输出流 PrintWriter writer = resp.getWriter(); writer.write(\"aaa\"); writer.write(\"你好\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 虽然页面解析出了Html标签，但是再response的响应数据中仍然是原数据，因为那里面的数据就是我们后端输出的最原始的数据，浏览器从里面获取数据，然后调用Html解析器进行解析。 细节： 设置响应数据时开辟了一个输出流，如下代码： // 获取字符输出流 PrintWriter writer = resp.getWriter(); 这个输出流不需要我们手动关闭，因为该流是response对象创建出来的，当Servlet销毁或者服务器关闭时，response自动销毁，这个流也会自动关闭。 6.6.6 Response响应字节数据 一般在传输文件、图片、音频等资源时会先将这些资源转换为字节，然后再进行传输，上面讲了如何响应字符数据，下面我们讲如何响应字节数据。 案例：服务端有一张图片，需要作为响应数据响应到浏览器。 流程： 读取图片，获取到输入流 获取response输出流 将图片输入流copy至response输出流上 @WebServlet(\"/resp4\") public class HttpServletDemo6 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 1. 读取文件，获取输入流 FileInputStream fis=new FileInputStream(\"d://1.png\"); // 2，获取response字节输出流 ServletOutputStream fos = resp.getOutputStream(); // 3. 完成流的copy，将输入流拷贝至输出流 byte[] buff=new byte[1024]; int len=0; while((len=fis.read(buff))!=-1){ fos.write(buff,0,len); } fis.close(); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 细节： 关于流的copy，可以使用一个工具类实现： 在pom.xml中引入工具类的依赖： commons-io commons-io 2.6 具体使用时，使用IOUtils即可。 @WebServlet(\"/resp4\") public class HttpServletDemo6 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 1. 读取文件，获取输入流 FileInputStream fis = new FileInputStream(\"d://1.png\"); // 2，获取response字节输出流 ServletOutputStream fos = resp.getOutputStream(); // 3. 完成流的copy，将输入流拷贝至输出流 IOUtils.copy(fis, fos); fis.close(); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 6.7 Servlet案例 下面实现一个Servlet登录与注册的案例： 技术栈：Mybatis+MySQL+Servlet 环境准备： 数据库 数据库中建立users表，表中添加两行数据 create table users( id int primary key auto_increment, username varchar(20) unique, password varchar(32) )charset utf8; insert into users(username,password) values (\"南雨\",\"123456\"),(\"张三\",\"654321\"); 对应User实体类 package com.nanyu.pojo; public class User { private int id; private String userName; private String passWord; //get和set、toString方法已省略 } Mybatis mybatis-config: 项目结构： 创建SqlSessionFactory工具类 package com.nanyu.utils; public class SqlSessionUtils { private static SqlSessionFactory sqlSessionFactory; static { try { String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } public SqlSessionFactory getSqlSessionFactory(){ return sqlSessionFactory; } } 创建Mybatis代理开发的接口文件：UserMapper package com.nanyu.mapper; public interface UserMapper { User selectUser(@Param(\"userName\") String username, @Param(\"passWord\") String password); User selectUserByName(String username); void addUser(User user); } 创建UserMapper映射文件：UserMapper.xml select * from users where username = #{userName} and password = #{passWord}; select * from users where username = #{userName}; insert into users (username, password) values (#{userName}, #{passWord}) 创建Service层接口文件：UserService package com.nanyu.service; import com.nanyu.pojo.User; public interface UserService { User getUser(String username, String password); User getUserByName(String username); void addUser(User user); } 创建Service层接口文件的实现类：UserServiceImpl package com.nanyu.service.impl; public class UserServiceImpl implements UserService { SqlSessionUtils sqlSessionUtils=new SqlSessionUtils(); SqlSessionFactory sqlSessionFactory = sqlSessionUtils.getSqlSessionFactory(); @Override public User getUser(String username, String password) { SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.selectUser(username, password); sqlSession.close(); return user; } @Override public User getUserByName(String username) { SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.selectUserByName(username); sqlSession.close(); return user; } @Override public void addUser(User user) { SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); try{ mapper.addUser(user); sqlSession.commit(); }catch (Exception e){ e.printStackTrace(); sqlSession.rollback(); } sqlSession.close(); } } 创建LoginServlet package com.nanyu.controller; @WebServlet(\"/login\") public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { HttpSession session=req.getSession(); req.setCharacterEncoding(\"UTF-8\"); UserServiceImpl userService = new UserServiceImpl(); String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); User userByName = userService.getUserByName(username); if(username==null||\"\".equals(username.trim())){ System.out.println(\"用户名为空！\"); req.setAttribute(\"msg\",\"用户名不能为空\"); req.getRequestDispatcher(\"/login1.html\").forward(req,resp); } if(password==null||\"\".equals(password.trim())){ System.out.println(\"密码为空！\"); req.setAttribute(\"msg\",\"密码不能为空\"); req.getRequestDispatcher(\"/login1.html\").forward(req,resp); } if (userByName == null) { System.out.println(\"用户不存在！\"); req.setAttribute(\"msg\",\"用户不存在\"); req.getRequestDispatcher(\"/login1.html\").forward(req,resp); } User user = userService.getUser(username, password); System.out.println(user); if(user==null){ System.out.println(\"用户或密码错误！\"); req.setAttribute(\"msg\",\"用户名或密码错误\"); req.getRequestDispatcher(\"/login1.html\").forward(req,resp); }else { session.setAttribute(\"username\",username); resp.sendRedirect(\"/study/mine.html\"); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } RegisterServlet package com.nanyu.controller; @WebServlet(\"/register\") public class RegisterLogin extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"UTF-8\"); UserServiceImpl userService = new UserServiceImpl(); User user = new User(); String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); User userByName = userService.getUserByName(username); if (username == null || \"\".equals(username.trim())) { req.setAttribute(\"msg\", \"输入的用户名不太受欢迎！\"); req.getRequestDispatcher(\"/register1.html\").forward(req, resp); } if (password == null || \"\".equals(password.trim())) { req.setAttribute(\"msg\", \"输入的密码不太受欢迎！\"); req.getRequestDispatcher(\"/register1.html\").forward(req, resp); } if (userByName != null) { req.setAttribute(\"msg\", \"输入的用户名已存在\"); req.getRequestDispatcher(\"/register1.html\").forward(req, resp); } else { user.setUserName(username); user.setPassWord(password); userService.addUser(user); req.setAttribute(\"msg\", \"注册成功\"); req.getRequestDispatcher(\"/login1.html\").forward(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 以上项目中还存在一些问题，虽然实现了简单的登录注册功能，但我们不难发现，在没有登录的情况下，仍然可以访问登录后才能访问的内容，这是因为我们没有对请求进行筛选，导致一些没有权限的请求也能执行成功。下面我们将要学习Filter过滤器，实现对没有权限的请求进行拦截。 7. Filter过滤器 Filter与Servlet一样，是JavaWeb的三大组件之一，狭义的Filter指Java语言实现的一个接口，宏观的Filter指所有实现了这个接口的类。 7.1 Filter简介 Filter即为过滤，用于在Servlet之外对Request或者Response进行修改，它主要用于对用户请求进行预处理，也可以对HttpServletResponse进行后处理，Filter是JavaWeb三大组件（Servlet、Filter、Listener）之一。 Filter的完整使用流程：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。在一个Web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个Filter链（即多层过滤）。 如下：如果是多个过滤器，则先配置的先执行（请求时执行的顺序），响应时以相反的顺序执行 在HttpServletRequest到达Servlet之前，拦截客户的HttpServletRequest。根据需求检查HttpServletReuqest，也可以修改HttpServletRequest头和数据（比如修改字符编码）。 在HttpServletResponse到达客户端之前，拦截HttpServletResponse。根据需求检查HttpServletResponse，也可以修改HttpServletResponse头和数据（用的不多） 7.2 Filter生命周期 Filter源接口文件 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package javax.servlet; import java.io.IOException; public interface Filter { void init(FilterConfig var1) throws ServletException; void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3) throws IOException, ServletException; void destroy(); } 我们要想实现Filter需要实现这个接口 package com.nanyu.filter; import javax.servlet.*; import java.io.IOException; public class Filter01 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { } @Override public void destroy() { } } 上面三个方法意思都很明确，分别是初始化、执行服务（具体的过滤操作）、销毁，Filter生命周期如下： init()方法：该方法只执行一次，当Filter第一次被使用时（服务器启动时），就会创建Filter对象，对象一旦被创建就会执行该方法，传入一个FilterConfig配置对象，进行初始化操作，方法中可以进行一些Filter初始化的操作。 doFilter()方法：执行具体的过滤操作，客户端发送的request请求会进入到该方法中，在此方法中执行对应的过滤操作。服务器的响应也会先进入该方法经过过滤后在发送至客户端。 destory()方法：销毁操作，仅在Filter被销毁或服务器关闭时执行一次。 7.3 Filter实现 7.3.1 单个过滤器 下面是Filter的简单实现 定义一个Filter01类并实现Filter接口 在每个方法中写入部分输出语句，方便观察方法的执行情况 @WebFilter(\"/login\")：配置被拦截的路径 package com.nanyu.filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter(\"/login\") public class Filter01 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\"Filter01------init.......\"); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"login请求已被Filter01拦截.......\"); filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { System.out.println(\"Filter01------destory.....\"); } } 拦截成功后一定要使用filterChain.doFilter(servletRequest,servletResponse);进行放行，否则服务端或客户端将无法收到请求或响应。 控制台输出信息如下，可以看到Filter01中的init()方法只在服务器启动时执行一次，destory()方法只在服务器正常关闭后执行一次，而每次执行login请求都会执行doFilter()，即只要该请求在Filter01的拦截范围内，没执行一次该请求，doFilter()方法都会执行。 7.3.2 过滤器链 下面配置了三个过滤器 Filter01 拦截login请求 package com.nanyu.filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter(\"/login\") public class Filter01 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\"Filter01------init.......\"); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"login请求已被Filter01拦截.......\"); filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { System.out.println(\"Filter01------destory.....\"); } } Filter02 拦截全部请求 package com.nanyu.filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter(\"/*\") public class Filter02 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\"Filter02----init.........\"); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"login请求已被Filter02拦截.......\"); filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { System.out.println(\"Filter02------destory.....\"); } } AFilter03 拦截login请求 package com.nanyu.filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter(\"/login\") public class AFilter03 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\"Filter03----init.........\"); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"login请求已被Filter03拦截.......\"); filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { System.out.println(\"Filter03------destory.....\"); } } 初始化时的顺序： 执行doFilter时的顺序 销毁时的顺序 通过控制台的输出情况我们可以发现，服务器执行Filter链的顺序是AFilter03、Filter02、Filter01，之所以按照这个顺序执行是因为先配置哪一个Filter就会先执行哪一个，简单来说就是将过滤器的名字按照英文字母排序，哪一个Filter在前边就先执行哪一个。由于我的项目中Filter的顺序如下 所以会按照顺序依次执行：AFilter03、Filter02、Filter01 7.3.3 过滤器处理响应 过滤器中的filterChain.doFilter(servletRequest,servletResponse);就像一条分割线，该行代码上面的部分执行拦截请求的数据，该行代码下面的部分拦截服务器响应的数据 Filter01中的doFilter方法 @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"login请求已被Filter01拦截.......\"); filterChain.doFilter(servletRequest,servletResponse); System.out.println(\"Filter01拦截响应.......\"); } Filter02中的doFilter方法 @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"login请求已被Filter02拦截.......\"); filterChain.doFilter(servletRequest,servletResponse); System.out.println(\"Filter02拦截响应.......\"); } Filter03中的doFilter方法 @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"login请求已被Filter03拦截.......\"); filterChain.doFilter(servletRequest,servletResponse); System.out.println(\"Filter03拦截响应.......\"); } 控制台输出如下： 我们发现拦截request时的Filter执行顺序与拦截response时的执行Filter的顺序完全相反。 7.3.4 总结 @WebFilter(\"/*\")：配置拦截的资源路径 doFilter()：方法中设置放行，否则请求无法到达资源，响应无法到达客户端filterChain.doFilter(servletRequest,servletResponse); 如果是过滤链，则先配置的先执行（首字母在前的先执行），响应是时，执行顺序反过来。 在实际开发中往往拦截全部，有殊请求单独放行即可。 7.4 Filter实例 7.4.1 请求乱码实例 适用于Tomcat8以下的版本。 定义一个拦截器：AEncodingFilter 其中doFilter()中代码如下： 对于Post请求，直接使用request.setCharacterEncoding(\"UTF-8\");即可（Post请求的设置不会影响到Get请求） 对于Get请求，需要先进行判断，因为Get请求的设置会影响到Post请求，因此需要先进行判断是否为Get请求 如果为Get请求则通过request.getServletContext().getServerInfo();获取服务器版本信息，判断服务器版本是否小于8，只有小于8的Tomcat服务器才会出现Get请求乱码。 如果Tomcat版本小于8，则执行自定义的内部类MyWapper，该类本质上还是request对象，不过重写了getParameter方法，在该方法实现了对乱码数据的处理。 @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; // 1. 处理Post请求乱码 request.setCharacterEncoding(\"UTF-8\"); // 2. 处理Get请求乱码 String method = request.getMethod(); // 2.1 判断是否为GET请求,equalsIgnoreCase忽略大小写 if (\"GET\".equalsIgnoreCase(method)) { // 2.2 获取服务器信息，从而提取版本号（Tomcat8以下的版本才会出现乱码，8及以上的版本不会） String serverInfo = request.getServletContext().getServerInfo(); System.out.println(serverInfo);//Apache Tomcat/8.5.68 // 2.3 获得服务器版本号 String substring = serverInfo.substring(serverInfo.indexOf(\"/\") + 1, serverInfo.indexOf(\".\")); Integer version = Integer.parseInt(substring); System.out.println(version);//8 // 2.4 判断版本号 if (version 内部类的代码如下： HttpServletRequestWrapper的体系结构如下，由此可知HttpServletRequestWrapper继承了ServletRequestWrapper而ServletRequestWrapper又实现了HttpServletRequest接口，所以本质上HttpServletRequestWrapper还是Request对象。 public class HttpServletRequestWrapper extends ServletRequestWrapper implements HttpServletRequest 该内部类的作用是重写HttpServletRequest中的getParameter方法，在重写的方法中对乱码数据进行重新编码。 最后创建该类的对象，实例化出一个自定义的Request对象，调用getParameter获取参数的时候，会调用重写的这个方法（继承之就近原则），调用其他方法时，则仍调用MyWapper的父类中的方法。 class MyWapper extends HttpServletRequestWrapper { private HttpServletRequest request; public MyWapper(HttpServletRequest request) { super(request); this.request = request; } /** * 4. 重写getParameter方法，在这里进行Get请求乱码的处理,调用getParameter获取参数的时候，会调用重写的这个方法 * * @param name * @return */ @Override public String getParameter(String name) { String value = request.getParameter(name); if (value != null && \"\".equals(value.trim())) { // 5. 将编码为UTF-8 value = new String(value.getBytes(StandardCharsets.UTF_8)); } return value; } } 完整代码如下： package com.nanyu.filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletRequestWrapper; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.net.URLDecoder; import java.net.URLEncoder; import java.nio.charset.StandardCharsets; @WebFilter(\"/*\") public class AEncodingFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\"init.........\"); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; // 1. 处理Post请求乱码 request.setCharacterEncoding(\"UTF-8\"); // 2. 处理Get请求乱码 String method = request.getMethod(); // 2.1 判断是否为GET请求,equalsIgnoreCase忽略大小写 if (\"GET\".equalsIgnoreCase(method)) { // 2.2 获取服务器信息，从而提取版本号（Tomcat8以下的版本才会出现乱码，8及以上的版本不会） String serverInfo = request.getServletContext().getServerInfo(); System.out.println(serverInfo);//Apache Tomcat/8.5.68 // 2.3 获得服务器版本号 String substring = serverInfo.substring(serverInfo.indexOf(\"/\") + 1, serverInfo.indexOf(\".\")); Integer version = Integer.parseInt(substring); System.out.println(version);//8 // 2.4 判断版本号 if (version 7.4.2 非法访问拦截实例 应用场景：防止用户未登录即可访问登录后的页面。 8. Listener监听器 8.1 介绍 Web监听器是Servlet中一种特殊的类，能帮助开发者监听Web中的特定事件，比如ServletContext、HttpSession、ServletRequest的创建和销毁；变量的创建、销毁和修改等操作。可以在某些动作前后增加处理，实现监控。例如可以用来统计在线人数等。 8.2 实现 监听器有三类8种（八个接口）： 监听生命周期 ServletRequestListener HttpSessionListener ServletContextListener 监听值的变化 ServletRequestAttributeListener HttpSessionAttributeListener ServletContextAttributeListener 针对session中的对象 监听session中的Java对象（JavaBean），是JavaBean直接实现监听器的接口 8.3 实例 创建一个监听类，集成HttpSessionListener接口并实现其中的方法 package com.nanyu.listener; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; public class Listener1 implements HttpSessionListener { // session对象被创建时执行该方法 @Override public void sessionCreated(HttpSessionEvent httpSessionEvent) { System.out.println(\"session对象被创建了\"); } // session对象被销毁时执行该方法 @Override public void sessionDestroyed(HttpSessionEvent httpSessionEvent) { System.out.println(\"session对象被销毁了\"); } } 9. JSP 9.1 基础语法 9.1.1 简介 JSP：Java Server Page，由SUN公司提供的动态网页编程技术，是Java Web服务端的动态资源。 相比Html，Html只能为用户提供静态数据，无法做数据渲染（后端的数据无法提供给前端使用），而Jsp技术，允许在页面中嵌套Java代码，将后端的数据可以传送给前端页面，为用户提供动态数据。 相比Servlet，Servlet很难对数据进行排版，而Jsp除了可以用Java代码生产动态数据的同时，也很容易对数据进行排版。 不管是JSP还是Servlet，虽然都可以用于开发动态web资源，但由于这2门技术各自的特点，在长期的软件实践中，人们逐渐把servlet作为web应用中的控制器组件来使用，而把JSP技术作为数据显示模板来使用。 其实JSP就是一个Servlet，当我们第一次访问JSP文件的时候，JSP引擎都会将这个JSP翻译成一个Servlet，这个文件存放在tomcat（源码目录）中的work目录中。 9.1.2 准备工作 修改编码格式 修改页面模板信息，在此修改之后再创建新的JSP文件时，就会携带这些信息 创建一个jsp文件 Title 9.1.3 注释 在JSP中注释有多种，根据能否在前端页面显示可以大致上分为两类 显示注释：能在客户端查看源码看到的注释，该注释继承自Html风格的注释 Title 显示注释: 隐式注释：查看源码也看不出来注释 继承自Java风格的注释 JSP自己的注释风格 Title 隐式注释 1. JSP自己的注释风格 2. 继承自Java的集成风格 9.1.4 Scriptlet Scriptlet（脚本小程序）是JSP中最重要的一部分，用于嵌入在HTML中的Java程序 在JSP中一共有三种方式写Java代码：都必须用Scriptlet标记出来 第一种：:Java脚本段，可以定义局部变量、编写语句 第二种：:生命，可以定义全局变量、方法、类 第三种：:表达式，一个变量或具体内容 实战演练 Title 浏览器输出结果：10 你好 你好 上面我们说过，JSP本质上还是Servlet，文件被JSP引擎解析后会转换为.java的servlet文件，当这个jsp文件被解析为Servlet之后，Scriptlet脚本程序中的java代码会进行整合，具体整合规则如下： 1. :Java脚本段，可以定义局部变量、编写语句 被整合到serlet中的service方法中 2. :生命，可以定义全局变量、方法、类 被整合到servlet的类体中 3. :表达式，一个变量或具体内容 被整合到servlet的service方法中 9.2 指令标签 在进行页面开发时我们经常会将整个页面划分为几个大部分，比如头部、尾部、侧边导航、中间内容等，很多时候我们需要在多个页面中重复的写这些东西，比如每个页面都会有头部，每个页面都会有底部用来编写版权信息。一个完整的项目中可能包含十几个静态页面，如果每个页面都将这些重新写一遍，代码会非常冗余且没有必要。 JSP中提供了包含操作，将重复的代码单独提取出来作为公共部分（类似一个成员方法），需要时包含进来使用即可,现在有两种方法可以实现上述功能： 方法一：在每个JSP页面(HTML)都包含工具栏、头部信息、尾部信息、具体内容 方法二：将工具栏、头部信息、尾部信息都分成各个独立的文件，使用的时候直接导入 很明显，第二种方法比第一种更好，第一种会存在很多重复的代码，并且修改很不方便，在JSP中如果要想实现包含的操作，有两种做法︰静态包含、动态包含，静态包含使用include 指令即可，动态包含则需要使用include动作标签。 9.2.1 include静态包含 标签格式： 实例操作 Title 中间内容 其实所谓的静态包含就是替换，从servlet中角度出发，servlet引擎将这些jsp解析转换时，发生了这些事情：header.jsp、footer.jsp、jsp.jsp被servlet引擎解析整合到了一起，只生成了一个servlet，因此上面的header.jsp、footer.jsp、jsp.jsp中不能拥有相同名的变量。 缺点：耦合度高，不够灵活 9.2.2 动态包含 动态包含在代码的编译阶段，包含和被包含部分是两个独立的部分，只有当运行时，才会动态包含进来，类似方法的调用。 动态包含格式： 动态包含特点： 动态包含相当于方法调用 动态包含会生成多个源码文件 可以定义同名变量 效率高，耦合度低 注意：使用动态包含，标签中间不能加任何东西，包括空格，除非确认要使用参数，否则报错，比如下面就会报错 报错1： 换行 报错2： 空格 报错3： 任意东西 动态包含在各个页面之间传递参数 name表示传递的参数名，value表示传递的参数值 \"/> 注意：传递参数时，name标签不支持写表达式，value属性支持该表达式 获取参数时，通过request.getParameter(\"\");方法获得。 程序实例 header.jsp文件 头部 头部 jsp.jsp文件 Title 中间内容 \"/> footer.jsp文件 尾部 尾部，这是从jsp.jsp文件传来的变量num=和msg= 9.3 JSP四大域对象 JSP中有九大内置对象：request、response、session、application、out、pageContext、config、page、exception，这些对象是JSP内置的对象，可以直接使用，按照功能划分可以将这几个内置对象划分为下面4大类。 输出输入对象：request对象、response对象、out对象； 通信控制对象：pageContext对象、session对象、application对象； Servlet对象：page对象、config对象； 错误处理对象：exception对象。 9.3.1 四种属性范围 在JSP中提供了四种属性的保存范围：page、request、session、application，所谓的属性保存范围，指的是设置的一个对象，可以在多少个页面中保存并可以继续使用。 其实这些属性范围就是一些存储对象、变量的容器，可以想象成一个个作用范围不等的盒子容器，先往这些盒子里面塞数据（对象、变量等），然后再用的时候从盒子里面取数据。 page：pageContext内置对象 特点：只在一个页面内中保存属性，跳转页面后失效（保存在page中的数据只在指定页面有效，页面跳转之后就会失效） request：request内置对象 特点：只在一次请求中保存（比如请求转发），在新的请求总获取不到数据（保存在request中的数据只在一次请求中有效，在新的请求中，比如发生了重定向就会无效） session：session内置对象 特点：在一次会话中有效（存储在session中的数据，在本次会话中都会有效，一次会话包括多个请求，关闭浏览器之后会话关闭，数据失效），对于服务器而言，每一个连接到它的客户端都是一个session，如果想要让属性设置一次之后，不管是否是新的浏览器打开都能取得则可以使用application。 application：application内置对象 特点：在整个服务器上保存数据（保存在application中的数据只要服务器不关闭，就不会失效，在任何页面中都可以使用），所有的application属性直接保存在服务器上，所有的用户(每一个session)都可以直接访问取得，只要是通过application设置的属性，则所有的session都可以取得，表示公共的内容，但是如果此时服务器重启了，则无法取得了，因为关闭服务器后，所有的属性都消失了，所以需要重新设置。 四个范围的使用准则： **在合理的范围内尽可能小（注：Page用的一般不是很多，最多的是request和session），设置的范围越大，服务器资源消耗越严重。** 上面四种属性范围都有共同的方法添加数据、获取数据、删除数据 方法 类型 描述 public void setAttribute(String name,Object obj) 普通 设置属性的名称及内容 public Object getAttribute(String name) 普通 根据属性名获取属性值 public void removeAttribute(String name,Object obj) 普通 删除指定属性 程序实例： 定义jsp1.jsp页面用来向四个域对象中添加数据 该页面内会进行服务器跳转，即请求转发 JSP四大域对象 跳转到jsp--%> 定义jsp.jsp用来获取数据 JSP四大域对象 效果如下： 因为进行了页面跳转，所以page中的数据失效， 又因为该跳转属于请求转发，本质上还是在一个请求内，所以一个request中的数据仍然可以得到， 如果使用标签的形式进行页面跳转则page和request都会失效，因为即发生了页面跳转又发生了新的请求 9.4 EL表达式 注意由于版本问题，servlet2.4版本才支持EL表达式，其他版本支持EL表达式，因此如果遇到EL表达式失效的情况可能是版本问题，用下面这种方法可以解决问题 在所有需要使用EL表达式的页面引入这段指令即可。 9.4.1 EL表达式语法 EL（Exception Language）表达式是为了使JSP写起来更加简单。表达式语言的灵感来自ECMAScript和Xpath表达式语言，它提供了在JSP中简化表达式的方法，让JSP的代码更加简化。 语法格式如下： ${expression} 不使用EL表达式获取域对象中的数据操作如下： 使用EL表达式获取域对象中的数据操作如下： ${msg} 两种方法都能获取到request对象种的数据，但是使用EL表达式明显比第一种使用Scriptlet的方式简洁 **EL表达式一般操作的是域对象种的数据，操作不了局部变量** JSP四大域对象 获取域对象种的数据：${msg} 获取局部变量：${str} 对于${msg}，代码运行时会从四个域对象中依次（小范围到大范围）查找是否有该值，先从page范围中查找是否包含msg。包含则直接取值，不包含继续在request中查找，仍不包含继续查找session，最后查找applicaiton，最终四个域对象中都不包含msg的话，直接返回空字符串（不是null）。 对于上面案例中的局部变量str，使用EL表达式获取其值时，会到四个域对象中寻找，如果在四个域对象中都找不到其值则就会返回空字符串（不是null） 使用EL表达式可以查找指定域对象中的数据，需要借助四个域对象对应的空间对象，分别是： pageScope、requestScope、sessionScope、applicationScope（Scope表示空间的意思） 使用方法如下： JSP四大域对象 获取page中的数据：${pageScope.msg} 获取request中的数据：${requestScope.msg} 获取session中的数据：${sessionScope.msg} 获取application中的数据：${applicationScope.msg} 9.4.2 EL表达式的使用 设置域对象数据 获取域对象数据 ${msg} 获取指定域对象的值 获取page中的数据：${pageScope.msg} 获取request中的数据：${requestScope.msg} 获取session中的数据：${sessionScope.msg} 获取application中的数据：${applicationScope.msg} 获取list集合 对集合、数组、对象等的操作其实和操作正常的Java操作一样，都是调用其该有的属性。 list=new ArrayList(); list.add(\"1\"); list.add(\"2\"); request.setAttribute(\"list\", list); %> 根据下标获取集合中的数据：${list[1]} 根据下标获取集合中的数据：${requestScope.list[2]} 获取集合的长度：${requestScope.list.size()} 获取集合的长度：${list.size()} 获取map集合 map=new HashMap(); map.put(\"key1\",\"value1\"); map.put(\"key2\",\"value2\"); map.put(\"key3\",\"value3\"); request.setAttribute(\"map\",map); %> 根据key获取集合中的数据：${map[\"key1\"]} 根据下标获取集合中的数据：${requestScope.map.key1} 获取集合的长度：${requestScope.map.size()} 获取集合的长度：${map.size()} 获取JavaBean对象 JavaBean中必须提供get和set方法 package com.nanyu.pojo; public class User { private Integer id; private String username; private String password; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } } 获取对象：${user} 获取对象中的属性：${user.username} 9.4.3 empty非空判断 empty是用来判断集合、数组、变量是否为空，使用格式如下： ${empty user} ${empty list} ${empty map} ${empty str} list=new ArrayList<>(); Map map=new HashMap<>(); request.setAttribute(\"user\",user); request.setAttribute(\"str\",\"\"); request.setAttribute(\"list\",list); request.setAttribute(\"map\",map); %> 不为空返回false，list为空或为null返回true，map为空或为null返回true，空字符串返回true，字符串为null返回true，JavaBean对象为null返回true，空JavaBean对象返回false ${empty user} ${empty str} ${empty list} ${empty map} 9.4.4 EL运算 EL运算即简单的算术运算、逻辑比较、等值比较等 ${a==b} ${a eq b} ${c==\"cc\"} ${c==d} ------------- ${a+b} ${a/b} ${a div b} ${a*b} ${a-b} ----------------- ${a > b} ${a 9.5 JSTL 8.5.1 JSTL的使用 JSTL：Java Server Pages Standard Tag Libray，JSP标准标签库，是一个定制标签类库的集合，用于解决一些常见的问题，例如迭代一个映射或者集合、条件测试、XML处理、甚至进行数据库操作等。 这里我们只学习JSTL中几个重要的标签（迭代集合以及格式化数字和日期） 核心标签库：http://java.sun.com/jsp/jstl/core 包含web应用的常见工作，比如：循环、表达式赋值、基本输入输出等 格式化标签库：http://java.sun.com/jsp/jstl/fmt 用来格式化显示数据的工作，比如：对不同区域的日期进行格式化等。 使用JSTL之前还需要做一些准备，这里我将其分为三个步骤。 下载Jar包 使用jstl还需要导入两个jar包（分别是jstl.jar和standard.jar，如果是Maven构建的项目，直接在pom.xml中引入jstl依赖即可），这两个jar包需要在Apache标准标签库中下载：点我进入 找到下面的zip包，点击即可下载： 下载之后解压下载的压缩包，解压后文件中有一个lib文件夹，该文件夹下有两个jar包jstl.jar和standard.jar 集成Jar包至项目 将这两个jar包粘贴到项目的指定位置（我的是web项目，所以放到了webapps/WEB-INF/lib中） 添加完毕之后将jar包集成到项目中，左上角File-Project Structure打开项目结构 找到Moudule，点击Dependencies，再点击左下角的”+“ 点击JARs or Directiores后会弹出选择路径框，选择刚解压出的jstl.jar和standard.jar这两个jar包，点击OK 最后点击Apply和OK 以上，JSTL jar包的引入就完成了。 实例操作 下面使用JSTL做一个实例，想要在JSP页面中使用JSTL类库，必须以下列格式使用taglib指令： prefix表示前缀，可以是任意内容，但应该简单明了 先引入JSTL标准核心库 由于指定了 prefix=\"n\"，相当于起了个别名就叫n，下面使用指令标签时都需要带上这个别名，具体操作见下面代码，以一个条件判断语句为例，test=\"\"属性中写入条件判断表达式 你好，JSTL 完整代码如下： JSTL 你好，JSTL 9.5.2 条件动作标签 条件动作标签其实就是条件表达式，在Java中我们会使用if、if else、switch来做条件判断，在JSTL中同样也有对应的标签完成条件判断。 在JSTL中通过这四个标签可以完成条件动作指令：if、choose、when、otherwise if标签 将其想象成Java中的if即可。对某个条件表达式进行判断，如果该条件运算结果为true，则处理主体内容，测试结果保存在Boolean对象中，并创建一个域变量来引用Boolean对象。可以利用var属性设置限域变量名，利用scope属性来指定其作用范围。 语法格式： if标签的属性介绍 属性 说明 必要 默认值 test 条件表达式，要用EL表达式的形式${} 是 无 var 存储条件结果的变量（将条件表达式的结果存于一个域对象中） 否 无 scope var属性的作用域，即将条件表达式的结果存入哪个域对象取值范围：page\\ request\\ session\\ application 否 page 程序实例： 8}\" var=\"flag\" scope=\"request\"> num=${num} flag=${flag} 输出结果： num=10 flag=true 注意： if标签操作的一般是域对象，普通的变量没有效果 if标签中没有else，如果想要else的效果需要设置两个完全相反的表达式 choose、when、otherwise标签 choose和when标签的作用与Java中的switch和case，用于在众多选项中做出选择。switch语句中的case对应choose标签中的when，switch语句中的default对应choose标签中的otherwise。 语法格式： 属性介绍： choose标签没有属性 when标签只有test属性 otherwise没有属性 程序实例： num小于5 num小于10 num大于10 输出结果： num大于10 注意： choose标签中必须至少有一个when标签，可以没有otherwise标签 otherwise必须放在最后一个when标签之后 choose标签中只能设置when标签与otherwise标签，不能有其他标签（比如if标签） when标签和otherwise标签中可以嵌套其他标签（比如if标签） otherwise标签在所有标签都不执行时才会执行 9.5.3 forEach迭代标签 所谓迭代标签可理解为Java中的循环，forEach是将一个主体内容迭代多次，或者迭代一个对象集合。与java中的for循环相似，forEach可以迭代所有java.util.Collection和java.util.Map接口的实现，以及对象或者基本类型的数组。 语法格式 \" begin=\"\" end=\"\" step=\"\" var=\"\" varStatus=\"\" > 属性介绍 属性 描述 是否必要 默认值 items 被循环的数据 否 无 begin 开始的元素（0=第一个元素，1=第二个元素） 否 0 end 最后一个元素（0=第一个元素，1=第二个元素） 否 最后一个元素 step 迭代的步长 否 1 var 当前条目的变量名称 否 无 varStatus 代表循环状态的变量名称 否 无 varStatus属性： index：当前这次迭代从0开始的迭代索引 count：当前这次迭代从1开始的迭代计数 first：用来表明当前这轮迭代是否为第一次迭代的标志 last：用来表明当前这轮迭代是否为最后一次迭代的标志 程序实例 打印数字 ${i} 相当于java中的for循环 for(int i=0;i 遍历数组 ${item} 相当于Java中的增强for循环 for(String str:strs){ System.out.print(str) } 遍历List集合 list=new ArrayList<>(); list.add(1); list.add(2); list.add(3); request.setAttribute(\"list\", list); %> ${item} 遍历Map集合 map = new HashMap<>(); map.put(\"key1\", 1); map.put(\"key2\", 2); map.put(\"key3\", 3); request.setAttribute(\"map\", map); %> ${item.key} ${item.value} 遍历对象集合（增强版） list = new ArrayList<>(); list.add(user1); list.add(user2); list.add(user3); request.setAttribute(\"list\", list); %> ${item.id} ${item.username} ${item.password} varStatus用法 list=new ArrayList<>(); list.add(1); list.add(2); list.add(3); request.setAttribute(\"list\", list); %> 当前成员下标：${itemp.index} 当前是第几次循环：${itemp.count} 当前是否是第一次循环：${itemp.first} 当前是否是最后一次循环：${itemp.last} 9.5.4 格式化标签 JSTL提供了格式化和解析数字及日期的标签: formatNumber、formatDate、parseNumber、parseDate。 使用之前也必须要引入对应的 格式化库 formatNumber标签 formatNumber标签用于格式化数字、百分比、货币。该标签用指定的格式或精度来格式化数字。(将数值型数据转换成指定格式的字符串类型。) 语法格式： \" type=\"\" var=\"\" scope=\"\" > 属性介绍： 属性 说明 是否必要 默认值 value 要显示的数字 是 无 type 需要转换的类型NUMBER、CURRENCY、PRECENT（数字、货币、百分比） 否 NUMBER var 存储格式化之后的数字的变量 否 print to page scope var属性的作用域，取值范围page\\ request\\ session\\ application 否 page 程序实例： ${num} 20 2,000% ￥20.00 $20.00 注意： var属性可写可不写，如果不写var属性则默认将转换后的结果直接输出到页面上，如果写了则默认会存到page域对象中（可通过scope属性指定域对象），需要通过EL表达式来获取 通过setLocale可以设置时区，默认是中国时区，所以将数字格式化成货币之后出现了￥，转换为美国时区之后就会变为$ 如果不写type，则默认为转换为number formatDate标签 formatDate标签用于使用不同的方式格式化日期（将Date型数据转换为指定格式的字符串类型） 语法格式： \" type=\"\" dateStyle=\"\" timeStyle=\"\" pattern=\"\" timeZone=\"\" var=\"\" scope=\"\" /> 属性介绍： 属性 说明 是否必要 默认值 value 要显示的日期 是 无 type date：年月日，time：时分秒，both：年月日时分秒 否 date dateStyle FULL\\ LONG\\ MEDIUM\\ SHORT\\ DEFAULT 否 default timStyle FULL\\ LONG\\ MEDIUM\\ SHORT\\ DEFAULT 否 default pattern 自定义格式日期的模式，比如yyyy-MM-dd 否 无 timeZone 显示日期的时区 否 默认时区 var 存储格式化之后的数字的变量 否 print to page scope var属性的作用域，取值范围page\\ request\\ session\\ application 否 page 自定义日期格式说明 格式 描述 实例 y 不包含纪元的年份，如果不包含纪元的年份小于10，则显示不具有前导零的年份 2022 M 月份数字，一位数的月份没有前导零，MM=09,M=9 April&04 d 月中的某一天，dd=05，d=5 20 H 24小时制的小时，H=2，HH=23 23 h 12小时制的小时，h=1，hh=11 11 m 分钟，mm=35，m=8，mm=09，m=56 48 s 秒，s=12，s=9，ss=09 19 程序实例： ${requestScope.mydate} 2022-2-9 2022-2-9 16:47:41 2022-2-9 2022-2-9 16:47:41 2022年2月9日 星期三 2022-2-9 2022-02-09 parseNumber标签 parseNumber标签用来解析数字，百分数，货币。(parseNumber标签可以将数字、货币或百分比类型的字符串转换成数值型。) 语法格式： 属性说明： 属性 说明 是否必要 默认值 value 要解析的数字 否 body type value的类型，number、currency、percent 否 number var 存储待解析数字的变量 否 print to page scope var属性的作用域 否 page 程序实例： 100 1 100 100 注意： parseNumber转换的最终结果只能是number类型 type属性不是指定要转换为什么类型的，而是告诉引擎value中的值是什么类型的 parseDate标签 parseDate与parseNumber相似，这里不多做介绍，看下面的实例 Wed Jun 22 00:00:00 CST 2022 Wed Jun 22 00:00:00 CST 2022 注意： pattern属性可指定value中的日期格式，使其与value中的日期格式相照应 type=\"date\"指定value的值必须为标准格式即：yyyy-MM-dd（2022-06-22） 10. MVC与三层架构 10.1 MVC 设计模式：典型二十三种设计模式（工厂模式、单例模式、观察者模式、代理模式、筑造者模式等等） MVC模式不属于设计模式，MVC由三个单词组成，分别代表不同的意思： Model：模型层，用JavaBean是实现，包括实体类、DAO层、Service层，用到的技术有JDBC/Mybatis/Mybatis-Plus等 entity层：实体类层（也可以写为Pojo），这一层编写的是与数据库中的表一一对应的Java类 dao层：database access object，dao层就是负责数据增删改查的接口 service层：负责调用dao层，实现具体的业务逻辑，如登录逻辑、修改数据的逻辑、删除数据的逻辑 View：视图层，显示数据给用户看的，用到的技术有Html/JS/CSS/JSP/Ajax等前端技术 Controller：控制层，现阶段的Servlet就是控制器，学了SpringMVC之后，Controller就叫控制器，职责就是负责接收请求，调用Model层获取用户想要请求的数据，然后将数据经过处理后返回给View层。 补充： JavaBeans : 是Java中一种特殊的类（换言之：JavaBean就是一个Java类)，一个Java类 ，满足以下要求，则可称为一个JavaBean a. public修饰的类，提供public 无参构造方法 b. 所有属性 都是private c. 提供getter和setter方法 从使用层面来看，JavaBean分为2大类： a. 封装业务逻辑的JavaBean （eg:LoginDao.java 封装了登录逻辑） b. 封装数据的JavaBean （实体类：eg：Student.java Vedio.java 。往往对应于数据库中的一张表，即数据库中有个Student表，项目中就有个Student.java类） JavaBean 是一个可以重复使用的组件，通过编写一个组件来实现某种通用功能，“一次编写、任何地方执行、任何地方重用”。 10.2 三层架构 表现层：Web层，包含了前端界面显示的View和后端的请求控制Controller 业务逻辑层：Service层，进行业务逻辑的处理，比如登录逻辑、注册逻辑、增删改查的逻辑等。 持久层：数据访问层（Dao层），对数据进行持久化，将数据从存入数据库，将数据从数据库取出，对数据进行修改等操作 实体类：该层其实也是属于三层架构中的内容 持久层与表现层都需要先创建接口，然后再创建对应的实体类来实现接口。持久层处于最底层，是负责与数据打交道的一层，在持久层中需要编写对应的方法来获取数据、修改数据或删除数据等操作。 持久层向上（业务逻辑层）提供持久层的接口，业务逻辑层先创建对应的接口，在创建的接口中创建登录、注册、增删改查的接口，通过调用具体的持久层中的方法并且实现业务逻辑层的接口来完成具体的登录、注册、删除、增加等业务逻辑。 业务逻辑层会向上（表现层），表现层包括控制层（Controller）和前端显示层（UI），控制层调用业务逻辑层完成前端用户的请求，对底层穿过来的数据进行加工（存入数组、列表、清洗等），然后将数据传递给前端显示层（UI），渲染给用户使用 10.3 对比 三层架构其实是对MVC模式的更细的划分，三层架构是将MVC的Model层划分为持久层、业务逻辑层 "},"4-Spring/1-Spring.html":{"url":"4-Spring/1-Spring.html","title":"5. Spring","keywords":"","body":"1. Spring简介 1.1 Spring是什么 Spring是分层的JavaSE/EE应用full-satck（全栈）轻量级开源框架，以IOC（Inverse Of Control：反转控制）和AOP（Aspect Oriented Programming：面向切面编程）为内核。 Spring提供了展现层SpringMVC和持久层Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库（如Mybatis），逐渐称为使用最多的JavaEE企业应用开源框架。 full-satck：此处的全栈与我们通常理解的全栈不同，此处的全栈是指Spring对各层都有对应的解决方案，如Web层有SpringMCV，Dao层有JdbcTemplate等。 轻量框架：框架比较小巧，API比较简单、学习成本比较低，则一般认为这个框架是轻量的 1.2 Spring发展历程 2017年9月份发布了Spring的最新版本Spring5.0通用版（GA） 1.3 Spring的优势 方便解耦，简化开发 通过Spring提供的IOC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度耦合。用户也不必再为单例模式类、属性文件解析等浙西很底层的需求编写代码，可以更专注于上层的应用。 简单来说就是把对象的创建权交由Spring来操作，不再通过new来创建对象，降低耦合性。 AOP编码的支持 通过Spring的AOP功能，方便进行面向切面编程，许多不容易用传统OOP（面向对象编程）实现的功能可以通过AOP轻松实现。 生命式事务的支持 可以将我们从单调的事务管理代码中解脱出来，通过声明的方式灵活的进行事务管理，提高开发效率和质量 方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。 其实就是项目中集成Junit，进行单元测试，测试起来更加方便 方便集成各种优秀的框架 Spring支持很多优秀框架的集成，比如：Struts、Hibemate、Mybatis、Mybatis-plus 降低JavaEE API的使用难度 Spring对JavaEE API（如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。 简单来说，就是对繁琐的操作进行封装，对外提供一个丰富的工具类，比如JDBC使用时要进行注册驱动、获取连接、事务管理、获取Sql执行对象、遍历结果集等一系列操作，比较繁琐，Spring对JDBC的操作进行了封装，提供给用户更方便以用的JDBCTemplate（其实就是JDBC的工具类） Java源码经典学习典范 Spring源码设计非常精妙、结构清晰、匠心独用、处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无疑是Java技术的最佳实践范例 1.4 Spring体系结构 Spring体系结构如下 Test层：最后一层Test表示Spring整个框架都可以进行测试 Core Container：核心容器（可以理解为IOC）是重点部分，前两层的运行都要借助核心容器，核心容器中有Beans、Core、Context、SpEL，对应着四个Jar包 Beans：主要用来产生Bean，即产生对象 Core：表示核心 Context：Spring的上下文 SpEL：Spring表达式语言，与JSP中EL（表达式语言）类似 上面图中的关系是层层递进的 2. Spring快速入门 提示：Spring是轻代码而重配置的框架（出了名的配置怪） 2.1 Spring程序开发步骤 需求：在com.nanyu.service.UserServiceImpl中需要调用 com.nanyu.dao.UserDaoImpl中save()和update()两个方法。 普通方法思路： 在UserServiceImpl类的内部new一个UserDaoImpl对象，通过对象调用类中的两个方法 public class UserServiceImpl implents UserService { UserDao userDao=new UserDaoImpl(); userDao.save(); userDao.update(); } 缺点： 上面的实现思路导致两个类之间耦合度太高，比如UserDaoImpl的包名路径需要更改时，UserServiceImpl中引用的包名路径也要更改，当遇到更为复杂的情况时就会导致牵一发而动全身。 Spring提供的解耦思路： 一切皆以配置的形式产生，Spring提供一个核心配置文件，在此核心配置文件中可以配置很多信息 文字描述： 导入Spring开发的基本包坐标（依赖） 编写Dao接口和实现类 创建Spring核心配置文件 在Spring配置文件中配置UserDaoImpl 使用Spring的API获得Bean实例。 2.2 Spring入门程序 接下来将会按照上面Spring的入门步骤编写一个Spring入门程序。 导入Spring开发的基本坐标 org.springframework spring-context 5.3.12 创建Dao接口和实现类 package com.nanyu.dao; public interface UserDao { void save(); } package com.nanyu.dao.impl; import com.nanyu.dao.UserDao; public class UserDaoImpl implements UserDao { @Override public void save() { System.out.println(\"save is running!\"); } } 创建Spring核心配置文件 在Spring配置文件中配置UserDaoImpl 属性解释： bean：用于配置对象，配置完之后外界可以获取到 id：该对象的唯一标识，通过该Id获取该bean封装的对象 class：需要配置的对象全限定名，即需要将哪个类配置为对象 通过Spring的API获取Bean实例 package com.nanyu.Test; import com.nanyu.dao.UserDao; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Test { public static void main(String[] args) { //创建容器 ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 从容器中通过配置的bean的id来获取到UserDaoImpl对象 UserDao userDao = (UserDao) app.getBean(\"userDao\"); userDao.save(); } } 代码解释： ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 根据核心配置文件，创建容器（可以理解为IOC容器），可以将容器比作一个用来装东西的大盒子。之前已经配置好的Bean对象就存在于这个容器中。 UserDao userDao = (UserDao) app.getBean(\"userDao\"); 如何获取到容器（盒子）中的对象？通过bean标签的唯一标识id即可获取到UserDao对象。这种方法不同于使用new关键字创建的对象，实现了解耦操作，当需要变更文件时只需要更改核心配置文件即可。 3. Spring配置文件 3.1 Bean标签的基本配置 Bean标签用于配置对象交由Spring来创建（即Spring用于配置对象的标签），基本原理是反射，通过class配置全限定包名，通过反射机制获取到该类的对象，对外提供唯一的对象id，通过该id调取容器中的对象，因为是基于反射，所以默认情况下它调用的是类中的无参构造器，如果该类中没有无参构造器则不能创建成功。 基本属性： id：Bean实例在Spring容器中的唯一标识 class：Bean的全限定名 scope：对象的作用范围，取值如下： 取值范围 说明 singleton 默认的，单例的 prototype 多例的 request Web项目中，Spring创建一个Bean对象，将对象存入到request域中 session Web项目中，Spring创建一个Bean对象，将对象存入到session域中 golbal session Web项目中，应用在Portlet环境，如果没有Portlet环境那么golbal session相当于session scope最重要的两个属性值singleton、prototype，默认值为singleton，下面介绍这两个属性值的不同。 下面代码用于测试scope的两个属性创建对象的数量以及不同属性值下对象创建的时机。由于Spring对象的创建基于反射，反射又基于无参构造，所以为了更好的表现出对象创建的时机，对UserDaoImpl的无参构造器做了以下修改。 package com.nanyu.dao.impl; import com.nanyu.dao.UserDao; public class UserDaoImpl implements UserDao { public UserDaoImpl(){ System.out.println(\"无参构造被执行了，说明对象被创建了\"); } @Override public void save() { System.out.println(\"save is running!\"); } } singleton：只在容器中创建一个对象，无论调用几次调用的都是最开始创建的那一个对象。 创建对象的时机：在容器刚创建时（new ClassPathXmlApplicationContext(\"applicationContext.xml\");），就通过Bean标签生成了对象，代码如下： package com.nanyu.Test; import com.nanyu.dao.UserDao; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Test { public static void main(String[] args) { //创建容器 ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); System.out.println(\"------分割线------\"); // 从容器中通过配置的bean的id来获取到UserDaoImpl对象 UserDao userDao1 = (UserDao) app.getBean(\"userDao\"); UserDao userDao2 = (UserDao) app.getBean(\"userDao\"); // 根据对象的地址判断userDao1与userDao2是不是一个对象 System.out.println(userDao1); System.out.println(userDao2); } } /* 输出结果 无参构造被执行了，说明对象被创建了 ------分割线------ com.nanyu.dao.impl.UserDaoImpl@490ab905 com.nanyu.dao.impl.UserDaoImpl@490ab905 */ 输出结果显示两次的对象地址相同，说明这是一个对象，由此说明设定了scope='singleton'之后，调用同一个id的Bean时容器中只会生成一个Bean对象。 同时根据UserDaoImpl中无参构造器执行的次序可以了解到当执行了new ClassPathXmlApplicationContext(\"applicationContext.xml\");这句话时就创建了对象。 prototype：当使用getBean()获取对象时，如果传入的是同一id，每调用一次方法，就会创建一个对象。 创建对象的时机：执行getBean()时创建对象 package com.nanyu.Test; import com.nanyu.dao.UserDao; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Test { public static void main(String[] args) { //创建容器 ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); System.out.println(\"------分割线------\"); // 从容器中通过配置的bean的id来获取到UserDaoImpl对象 UserDao userDao1 = (UserDao) app.getBean(\"userDao\"); UserDao userDao2 = (UserDao) app.getBean(\"userDao\"); // 根据对象的地址判断userDao1与userDao2是不是一个对象 System.out.println(userDao1); System.out.println(userDao2); } } /* 输出结果 ------分割线------ 无参构造被执行了，说明对象被创建了 无参构造被执行了，说明对象被创建了 com.nanyu.dao.impl.UserDaoImpl@1ce92674 com.nanyu.dao.impl.UserDaoImpl@5700d6b1 */ 输出结果显示两次对象地址不同，表明这不是一个对象，由此说明了设定了scope='prototype'之后，每执行一次getBean()都会生成一个对象。 根据无参构造器执行的次序可以了解到new ClassPathXmlApplicationContext(\"applicationContext.xml\");时并没有创建对象，而是当调用getBean()方法时才创建了对象 总结： 1）当scope的取值为singleton时 Bean的实例化个数：1个 Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例 Bean的声明周期： 对象创建：当应用加载，创建容器时，对象就被创建了 对象运行：只要容器在，对象就一致活着 对象销毁：当应用卸载时，销毁容器时，对象就被销毁 2）当scope取值为prototype Bean的实例化个数：多个 Bean的实例化时机：当调用getBean()方法时实例化Bean 对象创建：当使用对象时，创建新的对象实例 对象运行：只要对象在使用中，就一直活着 对象销毁：当对象长时间不用，会被Java的垃圾回收器回收 3.2 Bean声明周期配置 init-method：指定类中的初始化方法名称 destroy-method：指定类中的销毁方法 在核心配置文件的Bean标签中可以配置Bean的声明周期， 即对象的初始化时执行的方法和对象的销毁时执行的方法，在Bean标签上配置之前需要先在Bean标签对应的实体类中声明两个方法，一个作为初始化方法一个作为销毁时执行的方法 package com.nanyu.dao.impl; import com.nanyu.dao.UserDao; public class UserDaoImpl implements UserDao { public UserDaoImpl(){ System.out.println(\"无参构造被执行了，说明对象被创建了\"); } public void init(){ System.out.println(\"init方法.....\"); } public void destroy(){ System.out.println(\"destroy方法......\"); } @Override public void save() { System.out.println(\"save is running!\"); } } 配置Bean对象的声明周期需要用到两个属性： init-method：标记初始化方法的标签（指定UserDaoImpl中的初始化方法） destroy-method：标记销毁方法的标签（指定UserDaoImpl中的销毁方法） package com.nanyu.Test; import com.nanyu.dao.UserDao; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Test { public static void main(String[] args) { //创建容器 ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // ClassPathXmlApplicationContext app1 = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDao userDao = (UserDao) app.getBean(\"userDao\"); System.out.println(userDao); // 关闭容器 ((ClassPathXmlApplicationContext)app).close(); } } /** * 结果输出 * * 无参构造被执行了，说明对象被创建了 * init方法..... * com.nanyu.dao.impl.UserDaoImpl@72d818d1 * destroy方法...... **/ 根据输出结果可知： 先执行无参构造器创建对象，对象创建完毕之后，创建好的对象根据xml中的配置调用init()方法，执行初始化方法。当销毁容器时，即app关闭对象会根据xml配置调用destroy()方法，执行销毁方法 3.3 Bean实例化三种方式 无参构造方法实例化（重点） 工厂静态方法实例化（非重点） 工厂实例方法实例化（非重点） 无参构造方法实例化 上面使用的方法均是采用无参构造方法进行实例化，所以不再进行演示 工厂静态方法实例化 这种方法不再是根据无参构造器来创建对象，而是根据工厂来获取对象 创建一个工厂 package com.nanyu.factory; import com.nanyu.dao.UserDao; import com.nanyu.dao.impl.UserDaoImpl; public class StaticFactory { public static UserDao getUserDao(){ return new UserDaoImpl(); } } 配置配置文件，使用静态工厂的话需要在class属性中填入工厂的全限定名，除此之外增加一个factory-method属性用于指定工厂中的某个静态方法来获取对象。 在调用getUserDao方法时不需要创建工厂的对象，而是直接StaticFactory.getUserDao，因为getUserDao方法是静态的。 之后便可以进行测试 package com.nanyu.Test; import com.nanyu.dao.UserDao; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Test { public static void main(String[] args) { //创建容器 ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // ClassPathXmlApplicationContext app1 = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDao userDao = (UserDao) app.getBean(\"userDao\"); System.out.println(userDao); } } /* 无参构造被执行了，说明对象被创建了 com.nanyu.dao.impl.UserDaoImpl@4bec1f0c */ 工厂实例方法实例化 创建一个班工厂 package com.nanyu.factory; import com.nanyu.dao.UserDao; import com.nanyu.dao.impl.UserDaoImpl; public class DynamicFactory { public UserDao getUserDao(){ return new UserDaoImpl(); } } 这个工厂与上面的工厂不同之处在于获取UserDaoImpl的方法不是静态的，因此调用这个方法时需要先创建DynamicFactory的对象，在通过该对象调getUserDao方法来获取返回的对象。 核心配置文件中需要进行以下配置 属性介绍： factory-bean：工厂对象，填入工厂Bean的id factory-method：工厂中获取UserDaoImpl对象的方法 测试代码 package com.nanyu.Test; import com.nanyu.dao.UserDao; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Test { public static void main(String[] args) { //创建容器 ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // ClassPathXmlApplicationContext app1 = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDao userDao = (UserDao) app.getBean(\"userDao\"); System.out.println(userDao); } } /* 无参构造被执行了，说明对象被创建了 com.nanyu.dao.impl.UserDaoImpl@4bec1f0c */ 3.4 依赖注入 3.4.1 引言 下面是根据MVC模式构建的项目 Dao层 package com.nanyu.dao.impl; import com.nanyu.dao.UserDao; public class UserDaoImpl implements UserDao { public UserDaoImpl(){ System.out.println(\"无参构造被执行了，说明对象被创建了\"); } public void init(){ System.out.println(\"init方法.....\"); } public void destroy(){ System.out.println(\"destroy方法......\"); } @Override public void save() { System.out.println(\"save is running!\"); } } Service层 package com.nanyu.service.impl; import com.nanyu.dao.UserDao; import com.nanyu.service.UserService; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class UserServiceImpl implements UserService { @Override public void save() { ApplicationContext app=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDao userDao = (UserDao)app.getBean(\"userDao\"); userDao.save(); } } Controller层 package com.nanyu.controller; import com.nanyu.service.UserService; import com.nanyu.service.impl.UserServiceImpl; public class UserController { public static void main(String[] args) { UserService userService=new UserServiceImpl(); userService.save(); } } 观察Service层的代码可以知道，UserService对象的获取还是通过new关键字的形式获得的，那么能不能让UserService对象也通过配置文件让Spring帮忙创建的形式获得呢？当然是可以的，在核心配置文件中再加入一个bean标签，该标签配置userService对象即可。 改进后的Controller层 package com.nanyu.controller; import com.nanyu.service.UserService; import com.nanyu.service.impl.UserServiceImpl; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class UserController { public static void main(String[] args) { ApplicationContext app=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserServiceImpl userService = (UserServiceImpl)app.getBean(\"userService\"); userService.save(); } } 注意：但是这种使用方法存在一定的问题 问题描述： 目前UserService对象和UserDao对象都存在于Spring容器中，当前的做法是在容器外部获得UserService对象和UserDao对象，然后在Spring容器外部，手动把获取到的UserDao对象塞到UserService对象中（参考上面的例子），用下面的图来描述 UserService对象的内部还需要调用UserDao对象来完成一定的操作，而Controller层最终需要的只有一个UserService对象，对于UserDao对象，Controller层不需要（不直接需要），所以它不管UserDao对象怎么来的，通过什么样的方法让UserService对象获取到。 既然Controller层不在乎UserService是通过什么方法获取到UserDao的，所以能不能给出一种解决方法使得在Spring容器内部就能使UserService获取到UserDao对象。 因为UserService和UserDao都在Spring容器中，而最终程序直接使用的是UserService，所以可以在Spring容器中将UserDao设置到UserService内部 为了实现上面的思路，我们可以将UserDao设为UserService的一个属性，然后通过set方法或有参构造器的方法为该属性赋值。 3.4.2 依赖注入 依赖注入：（Dependency Injection）Spring框架核心IOC的具体体现。 在编写程序时，通过控制反转，将对象的创建交给了Spring，但是代码中不可能出现没有依赖的情况，IOC解耦知识降低了他们的依赖关系，但不会消除。列如：业务层仍会调用持久层的方法。 这种业务层和持久层的依赖关系，在使用Spring之后就交由Spring来维护了，简单的说就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。 依赖注入的方式： 有参构造 set方法 3.4.2.1 set方法依赖注入 先将UserDao作为UserServiceImpl的属性设置进去，然后设置get和set方法设置和获取UserDao，UserServiceImpl代码如下 package com.nanyu.service.impl; import com.nanyu.dao.UserDao; import com.nanyu.service.UserService; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class UserServiceImpl implements UserService { private UserDao userDao; public UserDao getUserDao() { return userDao; } public void setUserDao(UserDao userDao) { this.userDao = userDao; } @Override public void save() { userDao.save(); } } 但是这样设置之后Spring并不知道我们做了这些操作，所以我们还需要通过配置文件告诉Spring我们要把UserDao注入到UserServiceImpl中 property：标识属性的意思，指为该bean对象（这里指UserServiceImpl对象）中的对应的属性设置值。 name：表示为该Bean对象（这里指UserServiceImpl对象）中的哪个属性设置值，这里是为UserServiceImpl中的userDao属性设置值 ref：表示为该属性设置什么值，ref表示对象引用，只能用来设置一个对象，这里是把UserDao（这个UserDao对象是SPring容器中，通过Bean标签配置出来的对象）设置给该属性。这里设置的时候传递的是上面获取UserDao的Bean对象的id Controller中测试如下 package com.nanyu.controller; import com.nanyu.service.UserService; import com.nanyu.service.impl.UserServiceImpl; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class UserController { public static void main(String[] args) { ApplicationContext app=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserServiceImpl userService = (UserServiceImpl)app.getBean(\"userService\"); userService.save(); } } /* 输出结果 save is running! */ 上面这种方法能够运行成功，说明通过Spring配置成功地将UserDao对象注入到了UserServiceImpl内部，不用再使用new关键字在Spring外部手动创建对象。 如果使用new关键字创建UserServiceImpl对象会发生什么情况 package com.nanyu.controller; import com.nanyu.service.UserService; import com.nanyu.service.impl.UserServiceImpl; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class UserController { public static void main(String[] args) { UserService userService=new UserServiceImpl(); userService.save(); } } /* 输出结果 Exception in thread \"main\" java.lang.NullPointerException at com.nanyu.service.impl.UserServiceImpl.save(UserServiceImpl.java:21) at com.nanyu.controller.UserController.main(UserController.java:14) */ 从上面输出结果可知，发生了空指针异常，原因如下： (UserServiceImpl)app.getBean(\"userService\");获取到的UserServiceImpl对象是Spring容器内部的对象，把UserDao注入到UserServiceImpl的对象也是这个对象，这里的UserDao和UserServiceImpl对象都是Spring容器内部的对象，依赖注入也是在Spring容器内部发生的。通过new关键字创建出来的UserServiceImpl对象，属于Spring容器外部，与Spring容器内部的哪个UserServiceImpl对象是两个完全不同的对象，并且这个外部对象没有进行依赖注入，因此用new关键字创建出来的这个对象内部虽然具有userDao对象属性，但是没有赋值，所以调用的时候会发生空指针异常 3.4.2.2 P命名空间注入 P命名空间注入本质也是set注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下： 使用之前需要先引入P命名空间 xmlns:p=\"http://www.springframework.org/schema/p\" 然后修改注入方式，也就是修改配置文件 完整代码如下： --> --> --> --> 上面两种方法都属于set注入，只不过写的方法不同而已，最终效果都能够实现依赖注入。 一般来说还是用子标签的形式编写配置，因为读起来更简洁、更易懂 3.4.2.3 有参构造依赖注入 有参构造即通过有参构造器实现依赖注入，这种方法需要被注入的一方内部提供一个有参构造器，该构造器的作用之一是为了给需要注入的属性赋值 UserDaoImpl中的代码保持不变 package com.nanyu.dao.impl; import com.nanyu.dao.UserDao; public class UserDaoImpl implements UserDao { @Override public void save() { System.out.println(\"save is running!\"); } } 在UserServiceImpl中增加一个有参构造，此时便不需要get和set方法了，代码如下： package com.nanyu.service.impl; import com.nanyu.dao.UserDao; import com.nanyu.service.UserService; public class UserServiceImpl implements UserService { private UserDao userDao; public UserServiceImpl(UserDao userDao){ this.userDao=userDao; } public UserServiceImpl(){} @Override public void save() { userDao.save(); } } 代码完成了，但是我们如果不告诉Spring容器，Spring容器不会知道我们要干什么，所以我们还要告诉Spring容器我要通过有参构造的形式将UserDao对象注入到UserServiceImpl中 注意：这种注入还是在Spring内部完成的，操作的也是Spring容器中的Userdao Bean对象和UserServiceImpl对象，如果通过new关键字创建出来的UserServiceImpl不属于Spring容器内部，没有进行依赖注入 要告知Spring容器我们要通过有参构造的形式完成依赖注入还是需要通过核心配置文件的形式 属性介绍： constructor-arg：表示构造器参数，这是一个为构造器赋值的属性 name：该属性指定要为有参构造的哪个参数赋值，userDao表示的是构造器的参数名 ref：表示对象引用，表示为上面表示参数名的name赋什么值，即为userDao属性赋值 下面执行Controller测试： package com.nanyu.controller; import com.nanyu.service.UserService; import com.nanyu.service.impl.UserServiceImpl; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class UserController { public static void main(String[] args) { ApplicationContext app=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserServiceImpl userService = (UserServiceImpl)app.getBean(\"userService\"); userService.save(); } } /* 输出结果： save is running! */ 3.4.3 Bean依赖注入的数据类型 上面的操作注入的都是引用Bean（即将一个Bean对象注入到另一个中），除了对象的引用可以注入，普通数据类型、集合等都可以在容器中进行注入。 注入的数据类型主要有下面三种： 普通数据类型 引用数据类型 集合数据类型 3.4.3.1 普通数据类型注入 在UserDaoImpl中新增两个普通数据类型属性（注String是引用数据类型，但可以直接为其赋值） package com.nanyu.dao.impl; import com.nanyu.dao.UserDao; public class UserDaoImpl implements UserDao { private String str; private int num; public UserDaoImpl(String str, int num) { this.str = str; this.num = num; } public UserDaoImpl(){} @Override public void save() { System.out.println(\"save is running!\"); System.out.println(str); System.out.println(num); System.out.println(\"属性注入成功！\"); } } 编写Spring核心配置文件 测试 package com.nanyu.controller; import com.nanyu.dao.UserDao; import com.nanyu.dao.impl.UserDaoImpl; import com.nanyu.service.UserService; import com.nanyu.service.impl.UserServiceImpl; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class UserController { public static void main(String[] args) { ApplicationContext app=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDao userDao = (UserDaoImpl)app.getBean(\"userDao\"); userDao.save(); } } /* 输出结果： save is running! 你好 1 属性注入成功！ */ 通过set方法注入的配置如下，其他不再演示 3.4.3.2 集合数据类型注入 先在UserDaoImpl中增加List、Map、properties属性，同时设置get、set、toString方法。 [ ] Properties：也是一种集合，类似Map集合，只不过这种集合键值都是String类型 package com.nanyu.dao.impl; import com.nanyu.dao.UserDao; import com.nanyu.pojo.User; import java.util.List; import java.util.Map; import java.util.Properties; public class UserDaoImpl implements UserDao { private List list; private Map map; private Properties properties; public List getList() { return list; } public void setList(List list) { this.list = list; } public Map getMap() { return map; } public void setMap(Map map) { this.map = map; } public Properties getProperties() { return properties; } public void setProperties(Properties properties) { this.properties = properties; } public UserDaoImpl(){} @Override public String toString() { return \"UserDaoImpl{\" + \"list=\" + list + \", map=\" + map + \", properties=\" + properties + '}'; } @Override public void save() { System.out.println(\"save is running\"); System.out.println(list); System.out.println(map); System.out.println(properties); System.out.println(\"集合已被注入。。。\"); } } 创建一个实体类User，用于上面Map集合中的对象引用（省去了get和set方法，以及toString也省去了） package com.nanyu.pojo; public class User { private String username; private String password; } 编写配置信息 1 2 aaa key1 key2 key3 从外到内属性介绍： property：为属性赋值 name：指定为com.nanyu.dao.impl.UserDaoImpl类中的哪个属性赋值 list：需要赋值的属性的数据类型，表示需要赋值的属性是List集合数据类型。value：为该属性的值，即向该List集合中添加值，如果是String类型或普通数据类型，直接使用value赋值即可，如果是引用数据类型用ref map：需要赋值的属性的数据类型，表示需要赋值的属性是Map集合数据类型 entry：为Map的键值对赋值，key表示键值对的key，如果是引用数据类型就用key-ref，value表示键值对的值，如果是引用数据类型就用value-ref props：需要赋值的属性的数据类型，表示需要赋值的属性是Properties数据类型 prop：为properties赋值的键值对，key表示键值对的键，键值对的值直接写在双标签中。 测试代码： package com.nanyu.Test; import com.nanyu.dao.UserDao; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Test { public static void main(String[] args) { //创建容器 ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // ClassPathXmlApplicationContext app1 = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDao userDao = (UserDao) app.getBean(\"userDao\"); System.out.println(userDao); } } /* 输出结果： UserDaoImpl{list=[1, 2, aaa], map={user1=User{username='zhangsan', password='1111111'}, user2=User{username='zhangsan', password='1111111'}}, properties={key3=key3, key2=key2, key1=key1}} */ 3.5 小结 这一小节的配置文件如下： --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> 1 2 aaa key1 key2 key3 我们不难发现一个问题，就是如果在一个完整的项目中我们可能会写更多的配置文件，到时候配置文件全都写在一个文件中会使得可读性非常的差并且维护起来也非常不容易，所以有了分模块开发的策略，即将一个大的模块划分为若干小的模块，每个模块编写对应的xml配置文件，当需要修改时只需要修改对应模块的配置文件即可，最后通过import，将这些分模块导入到一个核心的模块中进行加载。 如下：有一个user模块的xml配置applicationContext-user.xml，还有一个admin模块的xml配置applicationContext-admin.xml，另外还有一个Spring加载的核心配置文件applicationContext.xml先需要将user、admin两个分模块的配置文件加载到一个核心配置文件中 Spring重点配置 标签 说明 属性 bean 在容器中实例化对象 id：对象在Spring容器中的唯一标识class：要实例化的Bean的全限定名scope：控制Bean的作用范围、对象创建个数、创建时机（singleton、prototype） property set形式属性注入 name：属性名称value：属性值 list 为List集合注入内容 value标签：向List中注入的值 map 为Map集合注入内容 entry标签：向Map中注入数据，key/key-ref：要注入的键，value/value-ref：要注入的值 properties 为properties注入内容 props标签：prop父标签，prop标签：要注入的数据 constructor-arg 构造器形式注入数据 name：被注入的属性的名称value/ref：注入的值，可以是普通数据类型，也可以是引用数据类型 import 导入分模块 resource：其他模块的配置文件名称 4. Spring相关API 相关API着重分析，下面代码中的接口 ApplicationContext app=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserService userService = (UserServiceImpl)app.getBean(\"userService\"); UserDao userDao = (UserDaoImpl)app.getBean(\"userDao\"); 分析以下下面这句话： ApplicationContext app=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 这句话的含义是创建应用上下文对象，同时创建Spring容器，这句话是通过多态的形式实现的。 ApplicationContext：是应用上下文接口，可以通过它的实例获取到Spring容器中的Bean对象 ClassPathXmlApplicationContext：是该接口的实现类 4.1 ApplicationContext实现类 既然ApplicaitonContext是接口，那么他就应该有实现类，上面已经提到了ClassPathXmlApplicationContext就是他的一个实现类。但其实它还有很多实现类，不过比较重要的，目前我们需要用到的就下面三个，根据下面三个可以创建ApplicationContext的实例，通过该实例获取Spring容器中的Bean对象 ClassPathXmlApplicationContext：从根路径下加载配置文件（推荐使用这种） ApplicationContext app=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); FileSystemXmlApplicationContext：从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置（用的不多） ApplicationContext app=new FileSystemXmlApplicationContext(\"D:\\\\Appinstall\\\\Idea\\\\Project\\\\SpringStudy\\\\src\\\\main\\\\resources\\\\applicationContext.xml\"); AnnotationConfigApplicationContext：当使用注解配置容器对象时，需要使用此类来创建Spring容器（它需要的参数是一个实体配置类），它用来读取注解。注解开发的时候需要，暂时不需要这个 4.2 getBean()方法 getBean()源码如下： public Object getBean(String name) throws BeansException { this.assertBeanFactoryActive(); return this.getBeanFactory().getBean(name); } public T getBean(String name, Class requiredType) throws BeansException { this.assertBeanFactoryActive(); return this.getBeanFactory().getBean(name, requiredType); } 从源码文件中可以看到getBean()方法有以上两种（其实不止两种），两种getBean()需要的参数不同， 第一种需要的一个字符串，该字符串表示的是Bean对象在Spring容器中的唯一标识id。 ClassPathXmlApplicationContext app=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDao userDao = (UserDaoImpl)app.getBean(\"userDao\"); System.out.println(userDao); 第二种需要的是字节码文件，传入一个字节码文件，Spring会在容器中寻找与该文件类型相同的Bean对象，找到后返回。 ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // UserDao userDao = (UserDao) app.getBean(\"userDao\"); UserDaoImpl bean = app.getBean(UserDaoImpl.class); System.out.println(bean); 注意： 第一种方法使用没有限制，任何情况下都可以从Spring容器中通过Bean对象的唯一标识获取到该Bean对象 第二种只适用于Spring容器中只存在一个该类型的Bean对象，因为它的原理是进行类型一对一匹配，所以Spring容器中只能有一个与字节码文件相同类型的对象，否则会报错，比如UserDaoImpl这个对象在Spring容器中只能有一个（要想使用字节码形式获取Bean，创建对象不能使用scope='prrototype'，否则将会创建多个对象） 当某一类型的Bean在Spring中存在多个，只能用id的形式获取；当某一个类型的Bean在Spring中只有一个，可以用id也可以用字节码文件的形式获取。 5. Spring配置数据源 数据源：数据库连接池，以下数据源可理解为数据库连接池或连接池 5.1 连接池的作用 数据源（连接池）是提高程序性能出现的 事先实例化数据源（连接池），初始化部分连接资源 使用连接资源时从数据源（连接池）中获取 使用完毕后将连接资源还给连接池 常见的数据源：DBCP、C3P0、BoneCP、Druid等 这些数据源的作用都是一样的，但每个数据源的底层实现可能不一样，每个数据源的性能也不一样，我们最常用的数据库连接池是C3P0、Druid 5.2 连接池使用步骤 导入数据库连接池的坐标和数据库驱动坐标 创建连接池对象 设置连接池的基本连接数据 使用连接池获取连接资源和归还连接资源 开发实战： 导入数据库连接池坐标以及数据库驱动坐标 c3p0 c3p0 0.9.1.2 com.alibaba druid 1.1.24 junit junit 4.13 创建连接池对象 设置连接池基本连接数据 使用连接池获取连接资源和归还连接资源 package com.nanyu.Test; import com.mchange.v2.c3p0.ComboPooledDataSource; import org.junit.Test; import java.beans.PropertyVetoException; import java.sql.Connection; public class DataSourceTest { @Test // 测试手动创建c3p0数据源 public void test() throws Exception { // 获取连接池对象 ComboPooledDataSource dataSource=new ComboPooledDataSource(); // 设置数据库驱动 dataSource.setDriverClass(\"com.mysql.jdbc.Driver\"); // 设置数据库地址 dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/test\"); // 设置数据库访问名 dataSource.setUser(\"root\"); // 设置数据库访问密码 dataSource.setPassword(\"123456\"); // 获取数据库连接 Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); } @Test // 手动创建Druid数据库连接池 public void test1() throws Exception{ // 获取Druid连接池对象 DruidDataSource dataSource=new DruidDataSource(); // 设置连接池对象数据 dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/test\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"123456\"); DruidPooledConnection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); } } /* 输出结果： com.mchange.v2.c3p0.impl.NewProxyConnection@79698539（c3p0） com.mysql.jdbc.JDBC4Connection@3cb5cdba（druid） */ 5.3 JDBC配置文件抽取 上面的代码我们可以分析出一些弊端，即代码耦合性太强，如下面代码，数据库的信息都是直接写道字符串里，都是写死的，后期要更换数据库，可能要把数据库驱动、数据库连接地址、数据库密码、数据库用户名全部改掉，到时候还要找原源码，如果项目已经编译打包上线了，这样会更麻烦，所以这样写代码耦合性太强，有很多弊端。 dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/test\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"123456\"); 既然上面代码耦合性太强，那么我们如何解耦？ 其实我们完全可以仿照Spring的思路，使用配置文件的形式将数据库配置信息进行解耦，具体思路如下： 将数据库配置信息抽取到一个properties配置文件中，当项目编译打包后这个配置文件并不会受到影响，我们可以通过修改该配置文件来实现对数据库连接信息的修改 在resources下面创建一个jdbc.properties配置文件，用于配置数据库信息，.properties中都是字符串形式的，里面的字符串不用引号 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/test jdbc.username=root jdbc.password=123456 测试如下： @Test // 手动创建C3P0连接池 public void test2() throws Exception{ // 加载jdbc.properties配置文件 ResourceBundle rb=ResourceBundle.getBundle(\"jdbc\"); // 获取配置文件中的信息 String driver=rb.getString(\"jdbc.driver\"); String url=rb.getString(\"jdbc.url\"); String username=rb.getString(\"jdbc.username\"); String password=rb.getString(\"jdbc.password\"); ComboPooledDataSource dataSource=new ComboPooledDataSource(); // 设置数据库驱动 dataSource.setDriverClass(driver); // 设置数据库地址 dataSource.setJdbcUrl(url); // 设置数据库访问名 dataSource.setUser(username); // 设置数据库访问密码 dataSource.setPassword(password); // 获取数据库连接 Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); } /* 输出结果： com.mchange.v2.c3p0.impl.NewProxyConnection@73f792cf */ 5.4 Spring配置连接池 上面是我们手动配置的数据库连接池信息，不管是我们创建.properties配置文件还是其他，其实都是我们手动配置的数据库连接池，那么Spring能不能接管连接池的配置呢？答案是可以的。 从上面的章节我们学习到了Spring创建一个Bean对象最简单的方式是通过无参构造（反射）。 回顾1：Spring环境搭建的步骤： 导入Spring-context坐标 创建需要放入Spring容器中的实体类（即上述例子中的UserDaoImpl、UserServiceImpl等） 在resource下创建Spring核心配置文件（名称任意，通常取applicationContext.xml） 编写配置，创建bean标签，创建Bean对象 通过Spring的API，getBean()获取对象 回顾2：Spring三种创建Beab对象的方法： 无参构造方法 工厂静态方法 工厂实例方法 回顾3：Spring依赖注入的两种方法： set方法依赖注入 有参构造方法依赖注入 创建Bean对象最简单的方法还是无参构造，也是用的最多的方法，如果要为Bean对象种的属性赋值，set方法和有参构造均可。那么现在抛出一个问题 如何让Spring创建连接池的Bean对象，如何把DataSource的创建权交由Spring？又如何为该连接池对象种的属性赋值？ 观察下面代码，为数据库连接池赋值时，都是通过setXXX为对应参数赋值的，说明连接池对象中存在get、set方法来为这些属性赋值，通过这点刚好满足Spring创建Bean对象并且通过set方法为属性赋值的条件。 dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/test\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"123456\"); 所以如果将dataSource的创建权交由Spring创建，那么代码形式是下面的形式 IDEA中获取外部包全限定名的方式： 选中类名（如DruidDataSource）->鼠标右键->Copy/Paste Special->Copy Reference 5.5 Spring加载properties文件 上面的代码虽然实现了把dataSource对象的创建权交给了Spring处理，但是从Spring配置文件中我们不难发现，property标签的value的值依然是字符串，相当于还是写死的，那么上面我们抽取的jdbc.properties相当于没什么用了。那么如何解决这种问题呢？有下面一种思路： 将jdbc.properties加载到Spring容器中，使用SpEL表达式的方式获取properties文件中的内容 如何将.properties加载进Spring核心配置文件呢？分为下面两步： 引入context命名空间 xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation= \"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/context/spring-context.xsd \"> 加载配置文件 通过以上两个步骤就能将properties配置文件加载到Spring，加载到Spring容器之后，properties文件中的所有键值对相当于存在于Spring容器中，通过SpEL（Spring表达式语言，相当于JSP中的JSTL），直接从Spring容器中获取到properties的键值。 完整配置文件如下： Juit测试如下： @Test // 通过Spring获取Druid的dataSource对象并配置连接池信息 public void test3() throws Exception{ ApplicationContext app=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); DruidDataSource dataSource = app.getBean(DruidDataSource.class); DruidPooledConnection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); } /* 结果输出： com.mysql.jdbc.JDBC4Connection@44821a96 */ 6. Spring注解开发 以上均属于配置文件的形式开发项目，下面介绍注解形式开发项目 相比于配置开发，注解开发好在哪？ Spring是轻代码重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以大大简化配置，提高开发效率。 目前不止Spring，基本所有框架都存在两套配置，一套是xml配置，一套是注解配置。 Spring注解分为原始注解与新注解：原始注解与新注解的区分是按照注解出现的顺序，有部分注解出现的比较早就叫原始注解，有部分注解出现的比较晚就叫新注解 6.1 Spring原始注解 Spring原始注解主要用来代替的配置 注解 说明 @Component 可使用在任何类上，用于实例化Bean（实例被标注的类为Bean对象） @Controller 使用在web层类上用于实例化Bean（分层架构中用于将Web层的类实例为Bean对象） @Service 使用在service层类上用于实例化Bean（分层架构中用于将Service层的类实例化为Bean对象） @Repository 使用在dao层类上用于实例化Bean（分层架构中用于将Dao层的类实例化为Bean对象） @Autowire 使用在字段上，用于根据类型依赖注入（用于注入引用数据类型的属性） @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入（用于注入引用数据类型的属性） @Resource 相当于@Autowired+@Qualifier，按照名称进行注入（用于注入引用数据类型的属性） @Value 注入普通属性，包括String类型 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestory 使用在方法上标注该方法是Bean的销毁方法 注解的使用： 下面将用注解的形式实现下面配置文件的配置 6.1.1 @Component注解 下面的@Component(\"userDao\")作用和xml配置文件中的作用相同。 // @Component(\"userDao\") public class UserDaoImpl implements UserDao { private String username; private int num; //get、set、toString方法已省略 } 同理，下面的@Component(\"userService\")的作用和xml配置文件中的作用相同。 // @Component(\"userService\") public class UserServiceImpl implements UserService { private UserDao userDao; 6.1.2 @Scope注解 @Component(\"userService\") @Scope(\"singleton\") public class UserServiceImpl implements UserService { } 该注解的作用和xml文件中的作用相同，主要有两个属性值：singleton、prototype 6.1.3 @PostConstruct、@PreDestory注解 @PreDestroy public void init(){ System.out.println(\"init....\"); } @PostConstruct public void destroy(){ System.out.println(\"destroy.....\"); } 这两个方法用来指定初始化时执行的方法和销毁时执行的方法，作用与xml中的相同 PreDestroy：销毁前 PostConstruct：销毁后 6.1.4 @Value注解 @Component(\"userDao\") public class UserDaoImpl implements UserDao { // @Value(\"zhangsan\") private String username; // @Value(\"1\") private int num; @Value(\"${jdbc.url}\") private String url; } @Value是用来注入普通数据类型的属性的，如上： @Value(\"zhangsan\")的作用与xml配置中的作用一致，@Value(\"1\")也是如此。 但是如果@Value这样用的话发挥不出来其价值，因为这样还不如在声明变量的时候就直接指定变量的值，这样使用@Value有点大材小用，所以@Value一般搭配SpEL表达式一起使用，如下： @Value(\"${jdbc.url}\") private String url; 这样使用SpEL直接从Spring容器中获取值，然后注入给该属性才能体现出@Value的价值。 6.1.5 @Autowired、@Qualifier、@Resource的使用 这三个注解一般是用于注入引用数据类型的属性时才会使用，比如将userDao注入到userService内部。 @Component(\"userService\") public class UserServiceImpl implements UserService { @Autowired @Qualifier(\"userDao\") private UserDao userDao; @Resource(name = \"userDao\") private UserDao userDao1; } 如下，@Autowired、@Qualifier两个注解要联合使用，一个表示要注入，另一个表示要将Spring容器中的哪个Bean对象注入给该属性。@Qualifier(\"userDao\")中需要传递参数，该参数是一个id，是容器中其他Bean对象的唯一标识Id，含义就是将容器中该Id对应的Bean对象注入到该属性。 @Resource(name = \"userDao\")注解的作用与@Autowired、@Qualifier一起用相同 6.1.6 @Controller、@Service、@Repository注解 上面我们知道了，如果要将一个类实例化为Bean对象，那么需要在这个类上加上注解@Component，但是这样做有一个缺点： 如果采用分层思想，使用@Component注解无法区分哪个@Component注解标注的类是Dao层、哪个是Service层、哪个是Web层。为了让用户一目了然区分出Dao层、Service层、Web层，Spring提供了三个衍生注解。 这三个注解的作用与@Component注解相同，都是实例化类为Bean对象存储与Spring容器中，但不同的是这三个注解分别作用在不同的分层上。 @Controller需要标注在Web层实体类上；@Service需要标注在业务层实体类上；@Repository需要标注在Dao层实体类上；程序示例如下： Dao层： // @Component(\"userDao\") @Repository(\"userDao\") public class UserDaoImpl implements UserDao { } Service层： // @Component(\"userService\") @Service(\"userService\") public class UserServiceImpl implements UserService { } Web层： @Controller public class UserController { } 6.2 组件扫描 使用注解开发时，需要在Spring核心配置文件中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。 虽然我们已经配置好了注解，但是并没有告诉Spring，如果不告诉Spring，他就无法帮我们创建Bean对象，我们写的注解知识摆设。那么如何告诉Spring，让他识别我们的注解呢？ 需要在xml中配置组件扫描，通过组件扫描的形式告知Spring我们在什么地方编写了注解，让其到对应的包下识别注解并帮我们完成生成Bean对象、依赖注入等操作 配置包扫描同样需要引入context命名空间 以上我们就完成了Spring注解开发的入门程序，完整代码如下： applicationContext.xml配置如下： UserDaoImpl如下： package com.nanyu.dao.impl; import com.nanyu.dao.UserDao; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; // @Component(\"userDao\") // @Repository(\"userDao\") public class UserDaoImpl implements UserDao { @Value(\"zhangsan\") private String username; @Value(\"1\") private int num; @Value(\"${jdbc.url}\") private String url; // get、set、toString方法已经省略 @Override public void save() { System.out.println(\"save is running\"); System.out.println(username); System.out.println(num); System.out.println(url); System.out.println(\"集合已被注入。。。\"); } } UserServiceImpl如下： package com.nanyu.service.impl; import com.nanyu.dao.UserDao; import com.nanyu.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Scope; import org.springframework.stereotype.Component; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; import javax.annotation.Resource; // @Component(\"userService\") // @Service(\"userService\") @Scope(\"singleton\") public class UserServiceImpl implements UserService { @Autowired @Qualifier(\"userDao\") private UserDao userDao; //get、set、toString等方法已省略 @Override public void save() { userDao.save(); } } 测试代码如下（用的Junit进行测试）： package com.nanyu.Test; import com.nanyu.service.impl.UserServiceImpl; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Test { @Test public void test() { ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext1.xml\"); UserServiceImpl userService = app.getBean(UserServiceImpl.class); userService.save(); System.out.println(userService); } } /* 输出结果： save is running zhangsan 1 jdbc:mysql://localhost:3306/test 集合已被注入。。。 UserServiceImpl{userDao=UserDaoImpl{username='zhangsan', num=1, url='jdbc:mysql://localhost:3306/test'}} */ 6.3 Spring新注解 为什么要有新注解？ 为了完全替代Xml配置。通过上面学习到的原始注解我们可以发现，要想使用注解完全代替xml配置吗，其实有些xml配置是原始注解实现不了的，比如组件扫描、加载properties配置文件、实例化非自定义类（下面有介绍）等。 为什么原始注解不能实例化非自定义的类？ 非自定义的类就是我们导包导进来的类，比如Druid连接池的DruidDataSource类或者Math工具类，这些都不是我们自己写的类，都是别人写好，我们导包使用。 以连接池为例：无论是Druid、C3P0还是其他的连接池对象，他们均来自于我们导入的包，也就是说这些类并不属于我们，是别人帮我们写好的，我们只能导包使用，并不能修改其源码，不能修改源码意味着我们不能在这个类上增加注解将这些实体类实例化为Bean对象放在Spring容器中，只能通过Xml配置利用反射加无参构造器实现。 这是原始注解不能实现的功能之一（xml配置可以实现），因此引入了新注解来实现原始注解不能实现的这些Xml配置。 总结原始注解不能实现的配置如下几点： 非自定义的Bean的配置： 加载properties文件的配置： 组件扫描的配置： 新注解的引入就是为了解决上面XML配置能实现，但原始注解无法实现的功能。新注解的使用完全替代了Xml配置，将加载Xml配置文件转为了加载核心配置类下面是Spring提供的新注解： 注解 说明 @Configuration 用于不指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解 @ComponentScan 用于指定Spring在初始化容器时要扫描的包作用和在Spring的Xml配置文件中的 @Bean 使用在方法上，标注该方法的返回值存储到Spring容器中 @PropertySource 用于加载.properties文件中的配置 @Import 用于导入其他配置类 6.3.1 @Configuration注解 该注解是标志Spring核心配置类的注解，因为需要完全替代xml配置，但又不能没有配置，所以要使用配置类。创建一个类作为配置，加上@Configuration注解就成为了Spring核心配置类。 package com.nanyu.config; import org.springframework.context.annotation.Configuration; // 标志该类是Spring的核心配置类 @Configuration public class SpringConfiguration { } @ComponentScan注解的使用 该注解是用来配置包扫描，作用与xml配置文件中的>作用相同。 它还有一个相似的注解：@ComponentScans，复数形式，表示里面可以配置多个扫描路径，里面是一个数组，使用方法如下： @ComponentScan([\"com.nanyu\",\"com.yinuo\"]) // 标志该类是Spring的核心配置类 @Configuration // 包扫描注解 @ComponentScan(\"com.nanyu\") public class SpringConfiguration { } 6.3.2 @Bean注解 @Bean注解的作用：将一个方法的返回值，以指定的名称作为Bean对象存入Spring容器中。 这样就解决了非自定义类实例化为Bean对象的难题，先在方法中使用new创建一个对象，然后作为方法的返回值返回，使用@Bean注解接收这个方法的返回值，并将这个返回值塞进Spring容器中。 @Configuration // 配置包扫描 @ComponentScan(\"com.nanyu\") public class SpringConfiguration { //将方法的返回值以指定的名称存入Spring容器中。 @Bean(\"dataSource\") public DataSource getDataSource(){ // 获取Druid连接池对象 DruidDataSource dataSource=new DruidDataSource(); // 设置连接池对象数据 dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/test\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"123456\"); return dataSource; } } 6.3.3 @PropertySource注解 该注解的作用是加载properties配置文件，作用与XML核心配置文件中的一致 该注解有一个相似的注解@PropertySources([\"classpath:jdbc.properties\",\"classpath:user.properties\"])，该注解可以同时引入多个配置poperties文件，以数组的形式传递进去 // 标志该类是Spring的核心配置类 @Configuration // 配置包扫描 @ComponentScan(\"com.nanyu\") // 加载properties配置文件进Spring容器 @PropertySource(\"classpath:jdbc.properties\") public class SpringConfiguration { } 此时properties配置文件已经进入了Spring容器，配置文件中的键值对可以用SpEL表达式直接获取。，如下一个小实例： // 标志该类是Spring的核心配置类 @Configuration @ComponentScan(\"com.nanyu\") // 加载properties配置文件 @PropertySource(\"classpath:jdbc.properties\") public class SpringConfiguration { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String username; @Value(\"${jdbc.password}\") private String password; @Bean(\"dataSource\") public DataSource getDataSource(){ // 获取Druid连接池对象 DruidDataSource dataSource=new DruidDataSource(); // 设置连接池对象数据 dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; } } 6.3.4 @Import注解 该注解用来加载其他注解，与xml配置文件中的作用相同。 Spring加载时只加载一个核心配置文件，但为了项目结构更清晰，更容易维护，所以往往会划分很多子的模块，每个分模块有一个配置文件。最终将分模块加载到核心配置中 // 标志该类是Spring的核心配置类 @Configuration @ComponentScan(\"com.nanyu\") // 加载分模块的配置文件 @Import(DataSourceConfig.class) // 如果有多个配置文件：@Import({DataSourceConfig.class,xxx.clss}) public class SpringConfiguration { } 6.3.5 Spring加载核心配置类 回顾：Spring加载配置文件的方式有三种，这三种是ApplicationContext的实现类 ClassPathXmlApplicationContext：从根路径下加载配置文件（推荐使用这种） ApplicationContext app=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); FileSystemXmlApplicationContext：从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置（用的不多） ApplicationContext app=new FileSystemXmlApplicationContext(\"D:\\\\Appinstall\\\\Idea\\\\Project\\\\SpringStudy\\\\src\\\\main\\\\resources\\\\applicationContext.xml\"); AnnotationConfigApplicationContext：当使用注解配置容器对象时，需要使用此类来创建Spring容器（它需要的参数是一个实体配置类），它用来读取注解。注解开发的时候需要，暂时不需要这个 前两种都是加载xml配置的，最后一种AnnotationConfigApplicationContext是加载注解核心配置类的，使用方法如下： public class Test { @Test public void test() throws SQLException { //创建容器 // ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext1.xml\"); ApplicationContext app = new AnnotationConfigApplicationContext(SpringConfiguration.class); UserServiceImpl userService = app.getBean(UserServiceImpl.class); DataSource dataSource = app.getBean(DataSource.class); Connection connection = dataSource.getConnection(); System.out.println(connection); userService.save(); System.out.println(userService); } } /* 输出结果： com.mysql.jdbc.JDBC4Connection@6ad82709 save is running zhangsan 1 jdbc:mysql://localhost:3306/test 集合已被注入。。。 UserServiceImpl{userDao=UserDaoImpl{username='zhangsan', num=1, url='jdbc:mysql://localhost:3306/test'}} */ 综合以上原始注解加新注解的使用，我们可以使用全注解的形式开发项目，从而完全替代配置文件 7. SPring整合Junit 7.1 原始Junit测试Spring 在测试类中，每个测试方法都要有以下两行代码： // ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext1.xml\"); ApplicationContext app = new AnnotationConfigApplicationContext(SpringConfiguration.class); UserServiceImpl userService = app.getBean(UserServiceImpl.class); 这两行代码的作用是获取Spring‘容器，如果不写会报空指针异常，所以不能轻易删掉。这就造成代码的冗余 7.2 上述问题解决方案 让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它 将需要进行测是Bean直接在测试类中进行注入。 7.3 Spring继承Junit步骤 导入spring继承junit坐标 使用@Runwith注解替换原来的运行期（之前进行测试直接找Junit，现在找Spring，Spring再去找Junit） 使用@ContextConfiguration指定配置文件或配置类 使用@Autowired注入需要测试的对象 创建测试方法进行测试 程序实例： 导入spring Junit坐标 junit junit 4.13 org.springframework spring-test 5.3.12 编写SpringJunitTest测试类；加上@Runwith注解；加上@ContextConfiguration注解；使用@Autowired注解注入需要测试的对象；创建测试方法进行测试 package com.nanyu.Test; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import javax.sql.DataSource; import java.sql.Connection; import java.sql.SQLException; // 使用@RunWith注解替换原来的运行期 @RunWith(SpringJUnit4ClassRunner.class) // 使用@ContextConfiguration注解指定配置文件或配置类 @ContextConfiguration(\"classpath:applicationContext1.xml\") // 如果使用的配置方式是配置类而不是xml配置，则可以如下方式加载配置文件 // @ContextConfiguration(classes = {SpringConfiguration.class}) public class SpringJunitTest { // 注入需要测试的对象 @Autowired private DataSource dataSource; @Test public void test() throws SQLException { Connection connection = dataSource.getConnection(); System.out.println(connection); } } 注意： 加载配置文件的形式有两种，一种是配置文件的形式、一种是配置类的形式 // 使用@ContextConfiguration注解指定配置文件或配置类 @ContextConfiguration(\"classpath:applicationContext1.xml\") // 如果使用的配置方式是配置类而不是xml配置，则可以如下方式加载配置文件 @ContextConfiguration(classes = {SpringConfiguration.class}) 另外Sping-test坐标的版本号需要与Spring基本坐标spring-context版本号一致。 8. Spring集成Web 8.1 三层架构与MVC 8.1.1 三层架构 三层架构是哪三层？ 从下到上：Dao（持久层）、Service（业务层）、Controller（控制层），每一层都有自己所负责的内容。 控制层：Controller层，包含了前端界面显示的View和后端的请求控制Controller（现阶段是以Servlet充当COntroller） 业务层：Service层，进行业务逻辑的处理，比如登录逻辑、注册逻辑、增删改查的逻辑等。 持久层：Dao层，对数据进行持久化，将数据从存入数据库，将数据从数据库取出，对数据进行修改等操作 实体类：该层其实也是属于三层架构中的内容 为什么要分层？ 其实使用分层思想之前，很多程序员会将代码写到一起，比如对数据库操作的代码、登录、删除、搜索等业务代码、以及前端响应代码都会写到一起，导致代码整体没有层次感，想要维护时需要花费大量的时间翻找对应区块的代码，加大了维护负担，所以引入了分层思想，采用分而治之的思想开发项目，每一层负责不同的功能，后期如果要维护项目只需要对应的封层中更改代码即可。 各分层之间存在调用关系，上层会调用下层提供的方法，流程如下： 持久层与表现层都需要先创建接口，然后再创建对应的实体类来实现接口。持久层处于最底层，是负责与数据打交道的一层，在持久层中需要编写对应的方法来获取数据、修改数据或删除数据等操作。 持久层向上（业务逻辑层）提供持久层的接口，业务逻辑层先创建对应的接口，在创建的接口中创建登录、注册、增删改查的接口，通过调用具体的持久层中的方法并且实现业务逻辑层的接口来完成具体的登录、注册、删除、增加等业务逻辑。 业务逻辑层会向上（表现层），表现层包括控制层（Controller）和前端显示层（UI），控制层调用业务逻辑层完成前端用户的请求，对底层穿过来的数据进行加工（存入数组、列表、清洗等），然后将数据传递给前端显示层（UI），渲染给用户使用 8.1.2 MVC 设计模式：典型二十三种设计模式（工厂模式、单例模式、观察者模式、代理模式、筑造者模式等等）,MVC模式不属于设计模式，MVC由三个单词组成，分别代表不同的意思： Model：模型层，用JavaBean是实现，包括实体类、DAO层、Service层，用到的技术有JDBC/Mybatis/Mybatis-Plus等 entity层：实体类层（也可以写为Pojo），这一层编写的是与数据库中的表一一对应的Java类 dao层：database access object，dao层就是负责数据增删改查的接口 service层：负责调用dao层，实现具体的业务逻辑，如登录逻辑、修改数据的逻辑、删除数据的逻辑 View：视图层，显示数据给用户看的，用到的技术有Html/JS/CSS/JSP/Ajax等前端技术 Controller：控制层，现阶段的Servlet就是控制器，学了SpringMVC之后，Controller就叫控制器，职责就是负责接收请求，调用Model层获取用户想要请求的数据，然后将数据经过处理后返回给View层。 补充： JavaBeans : 是Java中一种特殊的类（换言之：JavaBean就是一个Java类)，一个Java类 ，满足以下要求，则可称为一个JavaBean a. public修饰的类，提供public 无参构造方法 b. 所有属性 都是private c. 提供getter和setter方法 从使用层面来看，JavaBean分为2大类： a. 封装业务逻辑的JavaBean （eg:LoginDao.java 封装了登录逻辑） b. 封装数据的JavaBean （实体类：eg：Student.java Vedio.java 。往往对应于数据库中的一张表，即数据库中有个Student表，项目中就有个Student.java类） JavaBean 是一个可以重复使用的组件，通过编写一个组件来实现某种通用功能，“一次编写、任何地方执行、任何地方重用”。 8.1.3 对比 三层架构其实是对MVC模式的更细的划分，三层架构是将MVC的Model层划分为持久层、业务逻辑层 8.2 Web环境搭建 由于现阶段我们技术有限，所以使用的是Servlet充当我们的Web层，JSP作为前端展示页面。如果你使用的是Maven搭建的项目，比如原始项目结构如下 那么你可以按照下面的流程一步一步的集成web环境 pom.xml中添加下面坐标 pom.xml中的配置尤为重要，因为是Web项目，所以需要打包为war包，如果不加这个配置，则默认会打成jar包。 war javax.servlet javax.servlet-api 3.1.0 provided javax.servlet.jsp javax.servlet.jsp-api 2.3.1 provided 在main包下创建webapp目录，如下： 补齐文件夹，如WEB-INF，web.xml等，只要是缺少的必要文件或目录直接手动创建补上即可。 如果是自己创建的web.xml，内容应该是空的，那么你需要在web.xml中引入下面的头协议 同时也可以在webapp目录下创建好存放静态文件、JSP页面的文件夹等。 以上web的基本环境我们已经创建完成，但我们的项目目前还没办法让别人访问到，所有的测试都只是在我们本地电脑上运行。想要别人通过IP+端口号访问到我们，我们还需要一个web应用服务器，将我们的程序放到Web服务器中，Web服务器就可以向外部公开一个IP+端口，让别人访问到我们的项目，这个Web服务器我们通常选用Tomcat。 我们的程序通常需要先打包，再放到Tomcat上运行（当然不打包Tomcat也可以运行，但一般正式发布项目时是通过打包的方式让Tomcat运行），Tomcat可以直接运行war包，这也是为什么会在pom.xml中引入war这句话的原因，加上了这句话之后，Maven在进行打包的时候会把项目一整个打包成war包，然后Tomcat会自动执行这个war包。 有关项目集成Tomcat的方法，可以看我之前的文章：项目集成Tomcat，写的很清楚。 集成完毕之后项目如下，启动服务器之后，默认打开webapp目录下的index.jsp或index,html： 下面是一个Servlet充当Controller的测试： package com.nanyu.controller; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/user\") public class UserServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ApplicationContext app=new ClassPathXmlApplicationContext(\"applicationContext1.xml\"); DataSource dataSource = app.getBean(DataSource.class); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doGet(req, resp); } } 8.3 ApplicationContext获取 在一个项目中我们通常会有很多Servlet，用户的一种请求，比如登录、注册、删除、注销、查询等都对应一个请求，一个请求又对应着一个Servlet，所以一个项目中我们通常需要非常多的Servlet。 从上面的代码中我们可以发现，每次我们想获取容器中的Bean对象，就要执行下面获取ApplicationContext应用上下文的代码，这会造成配置文件被加载很多次，应用上下文对象被创建多次，这些代码往往只需执行一次，但又是每个Servlet中不可避免的，所以有没有一种方法能将创建容器，获取ApplicationContext应用上下文的代码抽取出来，只执行一次？ ApplicationContext app=new ClassPathXmlApplicationContext(\"applicationContext1.xml\"); DataSource dataSource = app.getBean(DataSource.class); 思路： 在Web项目中，我们可以通ServletContextListener监听Web应用的启动，当项目启动时就执行new ClassPathXmlApplicationContext(\"applicationContext1.xml\");获取ApplicationContext应用上下文的对象，将获得app对象存入最大的域对象Application中，使用时通过Application.getAttribut()获得即可。 这样我们就能做到ApplicationContext对象只创建一次，所有使用的ApplicationContext对象都来自一此创建。 根据上面提供的思路，我们动手实验一下。 创建一个listener包，在包中创建一个ContextLoaderListener，并让该类实现ServletContextListener接口，重写接口中的方法。 package com.nanyu.listener; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import javax.servlet.ServletContext; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; public class ContextLoaderListener implements ServletContextListener { /* 项目启动时执行的方法 */ @Override public void contextInitialized(ServletContextEvent servletContextEvent) { // 项目只要启动就获取ApplicationContext应用上下文对象，并将其存入域对象中 ApplicationContext app=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 获取ServletContext域对象 ServletContext servletContext = servletContextEvent.getServletContext(); // 将Spring应用上下文对象存入ServletContext域对象中 servletContext.setAttribute(\"app\",app); } /* 项目销毁时执行的方法 */ @Override public void contextDestroyed(ServletContextEvent servletContextEvent) { // 这里可以写关闭Spring应用上下文对象的代码 } } 在web.xml中配置监听器 com.nanyu.listener.ContextLoaderListener 测试是否成功 package com.nanyu.controller; @WebServlet(\"/user\") public class UserServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 这的getServletContext()方法来自于HttpServlet的继承GenericServlet //ServletContext servletContext = this.getServletContext(); // 这的getServletContext()来自于HttpServletRequest的继承ServletRequest ServletContext servletContext = req.getServletContext(); ApplicationContext app = (ApplicationContext)servletContext.getAttribute(\"app\"); DataSource bean = app.getBean(DataSource.class); Connection connection = null; try { connection = bean.getConnection(); } catch (SQLException throwables) { throwables.printStackTrace(); } System.out.println(connection); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doGet(req, resp); } } /* 结果输出： com.mysql.jdbc.JDBC4Connection@1ff6fd4 */ 8.4 代码优化 观察上面的代码，我们已经实现了Spring应用上下文ApplicationContext对象的获取，减少了代码冗余，但是上面代码还存在一定的耦合度。 比如配置文件的名不能以字符串的形式写死，我们可以将其写入配置文件。 另外对于ApplicationContext app对象的获取，我们可以封装到一个工具类内的静态方法中，通过调用工具类中的静态方法直接获取ApplicationContext对象，从而让开发者并不必单独记住ApplicationContext对象的名称叫app。 于是，上面获取ApplicationContext对象的代码优化如下： 首先在web.xml中配置applicationContext1.xml的名称 ApplicationContext applicationContext1.xml com.nanyu.listener.ContextLoaderListener 修改监听器 package com.nanyu.listener; public class ContextLoaderListener implements ServletContextListener { /* 项目启动时执行的方法 */ @Override public void contextInitialized(ServletContextEvent servletContextEvent) { ServletContext servletContext = servletContextEvent.getServletContext(); // web.xml中的全局初始化参数获取到ApplicationContext配置文件的文件名 String applicationContext = servletContext.getInitParameter(\"ApplicationContext\"); // 项目只要启动就获取ApplicationContext应用上下文对象，并将其存入域对象中 ApplicationContext app=new ClassPathXmlApplicationContext(applicationContext); // 获取ServletContext域对象 // 将Spring应用上下文对象存入ServletContext域对象中 servletContext.setAttribute(\"app\",app); } /* 项目销毁时执行的方法 */ @Override public void contextDestroyed(ServletContextEvent servletContextEvent) { // 这里可以写关闭Spring应用上下文对象的代码 } } 编写工具类 package com.nanyu.utils; public class ApplicationContextUtils { public static ApplicationContext getApplicationContext(ServletContext servletContext){ return (ApplicationContext)servletContext.getAttribute(\"app\"); } } 修改Controller package com.nanyu.controller; @WebServlet(\"/user\") public class UserServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext servletContext = req.getServletContext(); ApplicationContext app = ApplicationContextUtils.getApplicationContext(servletContext); System.out.println(app); DataSource bean = app.getBean(DataSource.class); Connection connection = null; try { connection = bean.getConnection(); } catch (SQLException throwables) { throwables.printStackTrace(); } System.out.println(connection); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doPost(req,resp); } } /* 结果输出： com.mysql.jdbc.JDBC4Connection@7e5b8e19 */ 以上就是代码的优化，只是为了减少代码耦合，提高代码的可读性和可维护性。 8.5 Spring获取ApplicationContext 回到我们最开始的问题上，我们为什么花费这么多精力要获取ApplicationContext对象？ 其实就是为了减少代码冗余，避免在多个Servlet中多次编写获取ApplicationContext对象的代码。 那么Spring既然是一个非常强大的框架，Spring也考虑到了代码冗余的问题？其实上面的代码Spring已经替我们封装好了，思路和我们上面的思路一摸一样，我们经过简单配置就可以使用（之所以把上面的代码写一遍是为了更加了解Spring获取应用上下文对象的原理）。 Spring提供的获取应用上下文对象的方法： Spring提供了一个监听器ContextLoaderListener，该监听器所作的功能就是在内部加载Spring配置文件（或配置类），然后创建ApplicationContext应用上下文对象，然后将这个对象放入域对象ServletContext中。 Spring还提供了一个工具类WebApplicationContextUtils，这个工具类内部包含返回值类型为ApplicationContext对象的静态方法，静态方法中通过，servletContenxt.getAttribute()获取应用上下文对象并通过return返回。 思路与我们上面写的一摸一样，实现也基本一致 使用Spring提供的方法获取应用上下文对象，我们要做的只需要两步： 在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标） 使用WebApplicationContextUtils获得应用上下文对象Application 程序实例： 导入spring-web坐标 org.springframework spring-web 5.3.12 在web.xml中配置监听器 contextConfigLocation classpath:applicationContext1.xml org.springframework.web.context.ContextLoaderListener --> ApplicationContext--> classpath:applicationContext1.xml--> --> --> com.nanyu.listener.ContextLoaderListener--> --> 使用WebApplicationContextUtils工具类获得应用上下文对象 package com.nanyu.controller; @WebServlet(\"/user\") public class UserServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp){ ServletContext servletContext = req.getServletContext(); // ApplicationContext app = ApplicationContextUtils.getApplicationContext(servletContext); ApplicationContext app = WebApplicationContextUtils.getWebApplicationContext(servletContext); DataSource dataSource = app.getBean(DataSource.class); Connection connection = null; try { connection = dataSource.getConnection(); } catch (SQLException throwables) { throwables.printStackTrace(); } System.out.println(connection); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doPost(req,resp); } } /* 输出结果： com.mysql.jdbc.JDBC4Connection@1c8c4dea */ 综上，就是Spring为我们提供的获取Spring应用上下文对象的方法，还是回归到问题的最初，无论是我们自己写的获取Spring应用上下文对象的方法还是Spring提供的方法，最终都是为了解决由于多次创建导致代码冗余的问题。 9. SpringMVC简介 9.1 SpringMVC概述 SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架，属于SpringFrameWork的后续产品，已经融合在Spring Web Flow中。 SpringMVC已经称为目前最主流的MVC框架之一，并且随着Spring3.0的发布，全面超越Struts2，成为最优秀的MVC框架。它通过一套注解，让一个简单的ava类成为处理请求的控制器，而无需实现任何接口。同时它还支持RESTful编程风格的请求。 SpringMVC只是一个Web层的框架，它只负责接管Conrtroller层，对于Dao层、Service层SpringMVC不会接管，因为SpringMVC没有对Dao层、Service层的操作进行封装，它只对Web层的功能进行了封装，因此说SpringMVC是一个Web层框架。（后面我们会学到Dao层有其对应的封装好的框架MyBatis） 为什么要引入SpringMVC这个Web层框架？ 解释说明：框架的作用是什么？框架的作用是封装大量重复性且繁琐的工作，对外部提供更友好、更易用的接口供用户使用，用户不必关心框架内部是怎么实现的，只需要使用框架提供的接口即可。 目前我们Web层用的是Servlet来接收请求，经过处理返回响应给浏览器客户端。使用Servlet接收请求其实有很多重复性操作，比如开发时Servlet接收到请求后做的工作无非就这么几个：接收请求参数、封装实体、访问业务层、接收返回结果、指派页面。 如下，使用Servlet充当Web层时的Servlet中做的基本操作： package com.nanyu.servlet; @WebServlet(\"/register\") public class RegisterServlet extends HttpServlet { private UserService userService = new UserServiceImpl(); @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 1. 接收请求参数 String username = req.getParameter(\"username\"); String pwd = req.getParameter(\"pwd\"); // 2. 封装实体 UserVO userVO = new UserVO(username, pwd); // 3. 访问业务层并接收返回结果 boolean flag = userService.register(userVO); // 4. 指派页面 req.getRequestDispatcher(\"/register.jsp\").forward(req, resp); } } } 从上面的代码我们可以看出，Servlet收到请求之后做的操作无非就：接收请求参数、封装实体、访问业务层、接收返回结果、指派页面，上面我们也说过框架的作用其实就是对重复且繁杂的工作进行封装，对外提供简单易用的接口。 SpringMVC的作用就是如此，SpringMVC存在的意义就是对接收请求参数、封装实体、接收返回结果、指派页面等这些重复性操作抽取出来，对其进行封装，提供给我们更加方便快捷的Web层操作。用下面的图来说明一下SpringMVC在项目中起到的作用 描述： 客户端发送请求到Tomcat服务器，Tomcat服务器对发送过来的请求数据封装到request对象中，然后请求继续去寻找对应的Servlet，但SpringMVC把Servlet中的功能被划分为两部分，一部分是负责接收请求参数、封装实体、接收返回结果等的公共行为（调用业务层属于特有行为），还有一部分是特有行为，SpringMVC将公共行为与特有行为抽取出来，分离开来，所有请求到达服务器之后在访问资源之前都要先经过SpringMVC抽取出来的公共部分（这一部分叫做前端控制器，它其实还是一个Servlet），然后通过SprimgMVC的路由分发器，将这个请求映射到包含对应特有行为的方法中，执行特有行为。 9.2 SpringMVC开发步骤 理解了上面的图，我们下面来介绍一下SprimgMVC开发步骤 导入SpringMVC包 配置SpringMVC核心控制器DispathcerServlet：配置共有行为的Servlet，以该Servlet作为前端控制器，将Servlet的资源访问路径设为\"/\"，表示所有请求都会经过这个Servlet，执行共有行为（这个Servlet不需要我们创建，SpringMVC已经帮我们控制好了，名叫DispathcerServlet，我们只需要对其进行配置即可）。 创建Controller和视图页面：编写POJO，一般叫Controller，这个Controller就是上面所说的SprimgMVC抽离出来的具有特有行为部分，这个Controller内部往往负责调用业务层、封装数据、指派跳转视图等。 使用注解配置Controller类中业务方法的映射地址：使用注解的方式将Controller这个POJO放到Spring的IOC容器中（@Comnponent或者@Controller） 配置SpringMVC核心文件spring-mvc.xml：配置spring-mvc.xml配置文件，在这个配置文件中配置组件扫描，这个组件扫描的作用是专门扫描web层的Controller，不扫描的化就没办法告知SpringMVC此处是一个Controller，该Controller也就不会起作用。 客户端发请求测试：执行访问测试 程序实例： 导入SpringMVC坐标 注意：Spring-webmvc坐标与Spring-web坐标是不一样的，Spring-webmvc坐标SpringMVC框架所需的坐标，而Spring-web坐标是Spring集成Web环境所需要的坐标，如果不导入Spring-web这个坐标，Spring就无法集成web环境（如果使用纯Servlet形式进行开发，就不需要导入这些包，只需要配置一下就能集成Web环境，但现在使用的是Spring开发的项目，Web层也需要被Spring接管，所以需要导入必要的坐标） org.springframework spring-webmvc 5.3.12 配置前端控制器DispathcerServlet 导入SpringMVC坐标之后其内部就有了DispathcerServlet这个前端控制器，但我们现在还不能使用，要想使用还需要进行一些配置。因为这个前端控制器本质上还是Servlet，我们一般对于Servlet、Filter、Listener的配置都会在web.xml中进行配置，所以这个前端控制器也需要在web.xml中进行配置。 DispatcherServlet org.springframework.web.servlet.DispatcherServlet 1 DispatcherServlet / 创建Controller和视图页面，使用注解配置Controller类中业务方法的映射地址 @RequestMapping(\"test\")：翻译名为请求映射，就是将具体的请求映射到对应的方法中，在对应的方法中调用业务层，返回试图页面，完成整个请求的操作。该注解需要后需要跟路径，否则无法匹配到对应的执行方法。 package com.nanyu.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; @Controller // 这个地方可以携带路径也可以不携带，如果携带则最后访问路径就是 /user/test,如果不携带最后访问路径是/test @RequestMapping(\"/user\") public class UserController { // RequestMapping指映射地址，表示将请求映射到哪个方法中，映射到哪个方法中就执行哪个方法 @RequestMapping(\"/test\") public String userTest(){ System.out.println(\"看到我表示执行成功\"); return \"/user.jsp\"; } } 配置SpringMVC核心文件spring-mvc.xml SpringMVC的配置也可以写到Spring核心配置文件中（applicationContext.xml），但是一般不建议这样写，因为还是本着分而治之的原则，避免后期SpringMVC的大量配置与Spring的大量配置混乱。在项目的resource目录下创建spring-mvc.xml配置文件。 注意：spring-mvc配置包扫描只需要配置controller包即可，service层和dao层不需要Spring-mvc来扫，Spring核心配置文件会扫描service层和dao层的注解。两者是分开的。 回顾： Spring使用xml配置时如果要进行组件扫描，使用的是context命名空间下的 Spring全注解开发时，以配置类形式进行配置，如果要进行包扫描需要在配置类上使用@ComponentScan(\"com.nanyu\") spring-mvc配置完成之后还需要告知使用者加载配置文件，我们要明白spring-mvc这个配置文件是谁在使用？配置了之后是为谁服务的？ spring-mvc这个配置文件是DispatcherServlet这个前端控制器使用的，所以我们要告知DispatcherServlet加载配置文件，因为DispatcherServlet是一个Servlet，所以我们可以通过初始化参数的形式将spring-mvc传递进去，DispatcherServlet中有对应的方法接收并加载这个配置文件。 修改web.xml文件 将spring-nvc配置文件以初始化参数的形式传递到DispatcherServlet内部被其加载。加载流程如下： 配置好的spring-mvc配置文件以初始化参数的形式让DispatcherServlet加载，当服务器一启动，会自动创建DispatcherServlet对象，然后DispatcherServlet从初始化参数中获取spring-mvc配置文件，完成DispatcherServlet对象的创建。 DispatcherServlet org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath:spring-mvc.xml 1 DispatcherServlet / 请求测试 9.3 SpringMVC组件解析 SpringMVC执行的流程图如下： SpringMVC组件解析，对于浏览器传递过来的请求，都会先经过前端控制器DipatcherServlet，之前我们理解的是我们很多的工作都是DispatcherServlet进行封装的，其实并不是。 其实DispatcherServlet只是负责调度，SpringMVC内部有很多组件，DispatcherServlet就是负责调度这些组件来完成对应的功能。 SpringMVC一次请求过程： 文字描述： 用户发送请求至前端控制器DispatcherServlet。 DispatcherServlet收到请求，调用HandlerMapping处理器映射器（有很多种） HandlerMapping会找到具体的处理器（可以根据xml配置、注解进行查找），生成处理器对象（Controller对象）以及处理器拦截器（如果有拦截器就会生成拦截器对象）一并返回给DispatcherServlet。 DispatcherServlet调用HandlerAdapter处理器适配器（有多种，有执行处理器对象的，也有执行拦截器对象）。 HandlerAdapter经过适配调用具体的处理器（包括Controller处理器，也可能有拦截器处理器）执行。 经过Controller处理器的执行，Controller执行完成返回ModelAndView给HandlerAdapter处理器适配器 HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet DispatcherServlet将ModelAndView传递给ViewReslover视图解析器。 ViewReslover解析后返回具体的view，返回给DispatcherServlet。 DispatcherServlet根据ViewReslover传递过来的View进行渲染视图（即将模型数据填充至视图中）。DispatcherServletg响应给客户端用户 SpringMVC有九大组件： [ ] 组件补充 10. SpringMVC组件 11. SpringMVC数据响应 "},"12-Redis/1-Redis简介.html":{"url":"12-Redis/1-Redis简介.html","title":"6. Redis简介","keywords":"","body":"Redis五种数据类型 Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合），zset（有序集合） 1 string类型 string是Redis最基本的类型，可以理解成与Memcached一模一样的类型，一个key对应一个value。 string类型是二进制安全的。意思是Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。 string类型是Redis最基本的数据类型，string类型的值最大能存储512MB。 1.1 string类型基本操作 nil类似于Java中的null，基本运算必须为数字，否则报错 #！启动Redis客户端 [root@node01 ~]# redis-cli #！设置数据 127.0.0.1:6379> set name zhangsan OK #！查询数据 127.0.0.1:6379> get name \"zhangsan\" #！删除数据 127.0.0.1:6379> del name (integer) 1 127.0.0.1:6379> get name (nil) #！追加数据 127.0.0.1:6379> set s1 haha OK 127.0.0.1:6379> get s1 \"haha\" 127.0.0.1:6379> append s1 111 (integer) 7 127.0.0.1:6379> get s1 \"haha111\" #！显示长度 127.0.0.1:6379> strlen s1 (integer) 7 #！----------------------------- 127.0.0.1:6379> set s2 1 OK 127.0.0.1:6379> set s3 2 OK #！每次+1 127.0.0.1:6379> incr s2 (integer) 2 127.0.0.1:6379> get s2 \"2\" #！每次-1 127.0.0.1:6379> decr s3 (integer) 1 127.0.0.1:6379> get s3 \"1\" #！每次+4 127.0.0.1:6379> incrby s2 4 (integer) 6 127.0.0.1:6379> get s2 \"6\" #！每次-4 127.0.0.1:6379> decrby s2 4 (integer) 2 127.0.0.1:6379> get s2 \"2\" #！截取指定位置字符串 127.0.0.1:6379> set s4 abcdefg OK 127.0.0.1:6379> GETRANGE s4 0 3 \"abcd\" 127.0.0.1:6379> GETRANGE s4 0 -1 \"abcdefg\" 127.0.0.1:6379> GETRANGE s4 0 -2 \"abcdef\" 127.0.0.1:6379> GETRANGE s4 0 -3 \"abcde\" #！设置指定位置的值 127.0.0.1:6379> get s4 \"abcdefg\" 127.0.0.1:6379> SETRANGE s4 2 hehe (integer) 7 127.0.0.1:6379> get s4 \"abheheg\" #！设置值的过期的时间，15秒之后s5的值变为nil(空) 127.0.0.1:6379> setex s5 15 lalala OK 127.0.0.1:6379> get s5 \"lalala\" 127.0.0.1:6379> get s5 \"lalala\" #！判断key是否存在，不存在设置值，存在则不设置 127.0.0.1:6379> setnx s5 dadada (integer) 1 127.0.0.1:6379> get s5 \"dadada\" 127.0.0.1:6379> setnx s3 sssss (integer) 0 127.0.0.1:6379> get s3 \"1\" 127.0.0.1:6379> #！同时设置多个值 127.0.0.1:6379> mset k1 a k2 b k3 c OK 127.0.0.1:6379> mget k1 k2 k3 1) \"a\" 2) \"b\" 3) \"c\" 127.0.0.1:6379> get k2 \"b\" 2 hash数据类型 Redis hash是一个键值key=>value对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 类似于Java中的Map 2.1 hash数据类型基本操作 #！添加数据 127.0.0.1:6379> hset h1 name zhangsan age 18 gender M (integer) 3 127.0.0.1:6379> #！获取数据 127.0.0.1:6379> hget h1 age \"18\" 127.0.0.1:6379> hget h1 name \"zhangsan\" 127.0.0.1:6379> hget h1 gender \"M\" #！获取全部数据 127.0.0.1:6379> hgetall h1 1) \"name\" 2) \"zhangsan\" 3) \"age\" 4) \"18\" 5) \"gender\" 6) \"M\" #！修改数据 127.0.0.1:6379> hset h1 name lisi (integer) 0 127.0.0.1:6379> hget h1 name \"lisi\" #！批量修改数据 127.0.0.1:6379> hmset h1 age 90 gender F OK 127.0.0.1:6379> hgetall h1 1) \"name\" 2) \"lisi\" 3) \"age\" 4) \"90\" 5) \"gender\" 6) \"F\" #！获取长度 127.0.0.1:6379> hlen h1 (integer) 3 #！获取所有key 127.0.0.1:6379> HKEYS h1 1) \"name\" 2) \"age\" 3) \"gender\" #！获取所有value 127.0.0.1:6379> HVALS h1 1) \"lisi\" 2) \"90\" 3) \"F\" #！判断某一可以是否存在，若存在返回1，不存在返回0 127.0.0.1:6379> HEXISTS h1 name (integer) 1 127.0.0.1:6379> HEXISTS h1 email (integer) 0 3 list类型 Redis列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部或者尾部 它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差 列表最多可存储2^32-1个元素 3.1 list基本操作 #！创建list 127.0.0.1:6379> lpush k1 1 2 3 5 6 (integer) 5 #！查询数据 127.0.0.1:6379> LRANGE k1 0 -1 1) \"6\" 2) \"5\" 3) \"3\" 4) \"2\" 5) \"1\" 127.0.0.1:6379> LRANGE k1 0 -2 1) \"6\" 2) \"5\" 3) \"3\" 4) \"2\" 127.0.0.1:6379> LRANGE k1 0 4 1) \"6\" 2) \"5\" 3) \"3\" 4) \"2\" 5) \"1\" #！创建list 127.0.0.1:6379> rpush k2 1 2 3 5 6 (integer) 5 #！查询数据 127.0.0.1:6379> LRANGE k2 0 -1 1) \"1\" 2) \"2\" 3) \"3\" 4) \"5\" 5) \"6\" 127.0.0.1:6379> LRANGE k2 0 -2 1) \"1\" 2) \"2\" 3) \"3\" 4) \"5\" 127.0.0.1:6379> LRANGE k2 0 3 1) \"1\" 2) \"2\" 3) \"3\" 4) \"5\" #！LPOP与RPOP弹出顶值和尾值 127.0.0.1:6379> LRANGE k1 0 -1 1) \"5\" 2) \"3\" 3) \"2\" 4) \"1\" 127.0.0.1:6379> lpop k1 \"5\" 127.0.0.1:6379> rpop k1 \"1\" #！获取指定位置的值 127.0.0.1:6379> LPUSH k3 1 2 3 4 5 6 7 8 (integer) 8 127.0.0.1:6379> LRANGE k3 0 -1 1) \"8\" 2) \"7\" 3) \"6\" 4) \"5\" 5) \"4\" 6) \"3\" 7) \"2\" 8) \"1\" 127.0.0.1:6379> LINDEX k3 3 \"5\" #！获取长度 127.0.0.1:6379> llen k3 (integer) 8 #！删除n个指定的元素 127.0.0.1:6379> RPUSH k4 1 1 1 2 2 2 3 3 3 4 4 4 (integer) 12 127.0.0.1:6379> LRANGE k4 0 -1 1) \"1\" 2) \"1\" 3) \"1\" 4) \"2\" 5) \"2\" 6) \"2\" 7) \"3\" 8) \"3\" 9) \"3\" 10) \"4\" 11) \"4\" 12) \"4\" 127.0.0.1:6379> lrem k4 2 3 (integer) 2 127.0.0.1:6379> LRANGE k4 0 -1 1) \"1\" 2) \"1\" 3) \"1\" 4) \"2\" 5) \"2\" 6) \"2\" 7) \"3\" 8) \"4\" 9) \"4\" 10) \"4\" #！删除指定范围的元素 127.0.0.1:6379> LPUSH k5 1 2 3 4 5 (integer) 5 127.0.0.1:6379> LRANGE k5 0 -1 1) \"5\" 2) \"4\" 3) \"3\" 4) \"2\" 5) \"1\" 127.0.0.1:6379> LTRIM k5 0 2 OK 127.0.0.1:6379> LRANGE k5 0 -1 1) \"5\" 2) \"4\" 3) \"3\" #！RPOPLPUSH 源 目的地 127.0.0.1:6379> LPUSH k6 1 2 3 (integer) 3 127.0.0.1:6379> LPUSH k7 6 8 7 (integer) 3 127.0.0.1:6379> RPOPLPUSH k6 k7 \"1\" #！将k6尾数pop出来添加到k7中 127.0.0.1:6379> LRANGE k6 0 -1 1) \"3\" 2) \"2\" 127.0.0.1:6379> LRANGE k7 0 -1 1) \"1\" 2) \"7\" 3) \"8\" 4) \"6\" #！设定指定值为新值 127.0.0.1:6379> LPUSH k8 1 2 3 5 4 (integer) 5 #！在元素2的前面增加a 127.0.0.1:6379> linsert k8 before 2 a (integer) 6 127.0.0.1:6379> LRANGE k8 0 -1 1) \"4\" 2) \"5\" 3) \"3\" 4) \"a\" 5) \"2\" 6) \"1\" 4 set类型 Redis的Set是string类型的无序集合。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合内元素的唯一，第二次插入的元素将被忽略 常用于去重操作 4.1 set基本操作 #！添加数据 127.0.0.1:6379> sadd t1 1 2 3 4 1 1 2 5 (integer) 5 #！添加数据 127.0.0.1:6379> SMEMBERS t1 1) \"1\" 2) \"2\" 3) \"3\" 4) \"4\" 5) \"5\" #！判断数据是否存在，存在返回1，不存在返回0 127.0.0.1:6379> SISMEMBER t1 2 (integer) 1 127.0.0.1:6379> SISMEMBER t1 0 (integer) 0 #！判断集合元素的个数 127.0.0.1:6379> SCARD t1 (integer) 5 #！删除集合中指定的元素 127.0.0.1:6379> SREM t1 2 (integer) 1 127.0.0.1:6379> SMEMBERS t1 1) \"1\" 2) \"3\" 3) \"4\" 4) \"5\" #！随机获取几个数据 127.0.0.1:6379> sadd t2 1 1 1 2 3 4 5 6 7 8 9 3 2 4 6 (integer) 9 127.0.0.1:6379> SMEMBERS t2 1) \"1\" 2) \"2\" 3) \"3\" 4) \"4\" 5) \"5\" 6) \"6\" 7) \"7\" 8) \"8\" 9) \"9\" 127.0.0.1:6379> SRANDMEMBER t2 3 1) \"7\" 2) \"6\" 3) \"5\" 127.0.0.1:6379> SRANDMEMBER t2 3 1) \"8\" 2) \"7\" 3) \"9\" #！随机出栈 127.0.0.1:6379> SPOP t2 2 1) \"2\" 2) \"1\" 127.0.0.1:6379> SPOP t2 2 1) \"3\" 2) \"7\" 127.0.0.1:6379> SMEMBERS t2 1) \"4\" 2) \"5\" 3) \"6\" 4) \"8\" 5) \"9\" #！移动指定元素到另一个集合中 127.0.0.1:6379> sadd t3 1 2 3 (integer) 3 127.0.0.1:6379> sadd t4 a b c (integer) 3 127.0.0.1:6379> SMOVE t3 t4 3 (integer) 1 127.0.0.1:6379> SMEMBERS t3 1) \"1\" 2) \"2\" 127.0.0.1:6379> SMEMBERS t4 1) \"3\" 2) \"b\" 3) \"c\" 4) \"a\" #！差交并 127.0.0.1:6379> sadd t5 3 4 5 6 (integer) 4 127.0.0.1:6379> sadd t6 2 3 4 5 (integer) 4 127.0.0.1:6379> SDIFF t3 t5 1) \"1\" 2) \"2\" 127.0.0.1:6379> SINTER t5 t6 1) \"3\" 2) \"4\" 3) \"5\" 127.0.0.1:6379> SUNION t5 t6 1) \"2\" 2) \"3\" 3) \"4\" 4) \"5\" 5) \"6\" 5 zset类型 Redis zset和set一样也是string类型元素的集合，且不允许重复的成员。 每个元素都会关联一个double类型的评分。Redis正是通过分数来为集合中的成员进行从小到大的排序。 zset的成员是唯一的，但评分(score)却可以重复。 5.1 zset基本操作 #！添加数据 127.0.0.1:6379> zadd z1 10 v1 8 v2 12 v3 (integer) 3 #！查询数据 127.0.0.1:6379> ZRANGE z1 0 -1 1) \"v2\" 2) \"v1\" 3) \"v3\" #！查询数据，附加scores 127.0.0.1:6379> ZRANGE z1 0 -1 withscores 1) \"v2\" 2) \"8\" 3) \"v1\" 4) \"10\" 5) \"v3\" 6) \"12\" #！依据特定条件取数据 127.0.0.1:6379> ZRANGEBYSCORE z1 6 15 1) \"v2\" 2) \"v1\" 3) \"v3\" 127.0.0.1:6379> ZRANGEBYSCORE z1 10 15 1) \"v1\" 2) \"v3\" 127.0.0.1:6379> ZRANGEBYSCORE z1 (10 15 1) \"v3\" 127.0.0.1:6379> ZRANGEBYSCORE z1 10 (12 1) \"v1\" 127.0.0.1:6379> ZRANGEBYSCORE z1 10 15 limit 1 1 1) \"v3\" #！删除某一元素 127.0.0.1:6379> ZREM z1 v2 (integer) 1 127.0.0.1:6379> ZRANGE z1 0 -1 1) \"v1\" 2) \"v3\" #！获取集合长度 127.0.0.1:6379> ZCARD z1 (integer) 2 #！获取指定score范围元素的个数 127.0.0.1:6379> ZCOUNT z1 5 15 (integer) 2 #！获取指定元素的score值 127.0.0.1:6379> ZSCORE z1 v1 \"10\" "},"6-Python/1-Python数据分析.html":{"url":"6-Python/1-Python数据分析.html","title":"1. Python数据分析","keywords":"","body":"1.Pandas模块 1.1 什么是Pandas Pandas是一个开源的Python核心数据分析库，主要用于数据分析、数据处理、数据可视化。Pandas是数据分析三大剑客之一（Pandas、Numpy、Matplotlib），它提供了快速、灵活、明确的数据结构，能够简单、直观、快速的处理各种类型的数据。 Pandas处理的数据类型 SQL或Excel表类似的数据 有序和无序的时间序列数据 带行列标签的矩阵数据 任意其他形式的观测、统计数据集 Pandas提供两个主要的数据结构，也是Pandas中两个重要的对象。 Series：一维数据结构 DataFrame：二维数组结构 维数 名称 描述 1 Series 带标签的一维同构数组 2 DataFrame 带标签的，大小可变的，二维异构表格 Pandas是基于Numpy开发的，它可以与其他第三方科学计算库完美的集成。它是处理数据时最理想的工具。 图解Series、DataFrame 语文 数学 英语 0 110 105 99 1 105 88 115 3 109 120 130 原始数据（成绩表） 其中\"语文\"、\"数学\"、\"英语\"每一列都是一个Series对象。 \"语文\"是一个Series对象 语文 0 110 1 105 2 109 \"数学\"是一个Series对象 语文 0 105 1 88 2 115 \"英语\"是一个Series对象 语文 0 109 1 120 2 130 而\"语文\"、\"数学\"、\"英语\"三列组成了一个DataFrame对象 语文 数学 英语 0 110 105 99 1 105 88 115 3 109 120 130 1.1.1 创建Series对象 Series是Python的Pandas库中的一种数据结构，类似一维数组，由一组数据以及与这组数据相关的标签（索引）组成，或者仅有一组数据而没有索引也可以创建一个简单的Series对象。series可以存储整数、浮点数、字符串、Python对象等多种类型的数据。 列表创建 创建Series对象时，主要使用Pandas的Series方法，可以从列表中创建Series对象。 # 导入pandas模块 import pandas as pd # 导入numpy模块 import numpy as np s=pd.Series(5) s # 输出结果 0 5 dtype: int64 print(\"---------------------------分割线----------------------------\") s1=pd.Series([1,2,3,4]) print(s1) # 输出结果 0 1 1 2 2 3 3 4 dtype: int64 print(\"---------------------------分割线----------------------------\") s2=pd.Series([1,2,3,np.nan,5]) print(s2) print(\"---------------------------分割线----------------------------\") # 输出结果： 0 1.0 1 2.0 2 3.0 3 NaN 4 5.0 dtype: float64 结果中的dtype是DataFrame数据的数据类型，int为整型，float为浮点型，后面的数字表示位数 如上述成绩单实例，如果想想成绩表中添加一列物理成绩，可以通过创建一个Series对象来实现。 import pandas as pd s=pd.Series([80,90,100]) 如果通过Pandas模块引入Series对象，则可以直接在程序中使用Series对象。 import pandas as pd s=Series([110,105,109])#语文成绩 numpy数组创建 创建Series对象时，可以通过numpy生成数组的方式创建Series对象。 arr=np.array([1,2,3,4.5]) s=pd.Series(arr) s print(\"---------------------------分割线----------------------------\") # 输出结果 0 1.0 1 2.0 2 3.0 3 4.5 dtype: float64 s=pd.Series(np.array([1,2,3,4,5,2,4,6,np.nan,7,np.nan])) print(\"s的长度：\",len(s)) print(\"s的形状：\",s.shape) print(\"s中的非np.nan的个数：\",s.count()) print(\"s中不重复元素：\",s.unique()) print(\"s中非np.nan元素出现的次数：\",s.value_counts()) print(\"---------------------------分割线----------------------------\") # 输出结果 s的长度： 11 s的形状： (11,) s中的非np.nan的个数： 9 s中不重复元素： [ 1. 2. 3. 4. 5. 6. nan 7.] s中非np.nan元素出现的次数： 4.0 2 2.0 2 7.0 1 6.0 1 5.0 1 3.0 1 1.0 1 字典创建 使用字典创建，默认字典的key对应Series对象的索引，value对应Series对象的值 s=pd.Series({\"小明\":88.0,\"小石\":98.9,\"小丁\":95.2}) print(s) print(\"---------------------------分割线----------------------------\") print(s.index) print(\"---------------------------分割线----------------------------\") print(s.values) print(\"---------------------------分割线----------------------------\") #输出结果 小明 88.0 小王 98.9 小赵 95.2 dtype: float64 ---------------------------分割线---------------------------- Index(['小明', '小王', '小赵'], dtype='object') ---------------------------分割线---------------------------- [88. 98.9 95.2] data_dict = { 'BABA': 187.07, 'PDD': 21.83, 'JD': 30.79, 'BIDU': 184.77 } s3 = pd.Series(data_dict, name='中概股') s3.index.name = '股票代号' s3 print(\"---------------------------分割线----------------------------\") # 运行结果 股票代号 BABA 187.07 PDD 21.83 JD 30.79 BIDU 184.77 Name: 中概股, dtype: float64 print(\"---------------------------分割线----------------------------\") # 由于data_dict中没有TW，但索引中有，因此输出结果中TW索引下对应的值为 NaN。 #再者，代号里没有BABA，因此输出结果里面没有 BABA 对应的值 (即便 data_dict 里面有) sss={'TW','PDD','JD','BIDU'} s=pd.Series(data_dict,index=sss) s print(\"---------------------------分割线----------------------------\") # 输出结果 PDD 21.83 BIDU 184.77 TW NaN JD 30.79 dtype: float64 手动设置索引 创建Series对象时会能自动生成整数索引，默认值从0开始，至数据长度减1，除了使用默认索引，我们在创建Series对象时还可以手动设置索引。 s=pd.Series(1,index=['key1','key2','key3']) s # 输出结果 key1 1 key2 1 key3 1 dtype: int64 print(\"-------------------------------\") s=pd.Series([100,122,121],index=[4,5,6]) s # 输出结果 4 100 5 122 6 121 dtype: int64 print(\"--------------------------------------------\") s=pd.Series([120,99,130],index=[\"小明\",\"小丁\",\"小石\"]) s # 输出结果 小明 120 小丁 99 小石 130 dtype: int64 Series位置索引 "},"6-Python/2-初识Python.html":{"url":"6-Python/2-初识Python.html","title":"2. 初识Python","keywords":"","body":"1.1 Python简介 1.1.1 Python发展史 1989年圣诞节：Guido von Rossum开始写Python语言的编译器。 1991年2月：第一个Python编译器（同时也是解释器）诞生，它是用C语言实现的（后面），可以调用C语言的库函数。在最早的版本中，Python已经提供了对“类”，“函数”，“异常处理”等构造块的支持，还有对列表、字典等核心数据类型，同时支持以模块为基础来构造应用程序。 1994年1月：Python 1.0正式发布。 2000年10月16日：Python 2.0发布，增加了完整的垃圾回收)，提供了对Unicode的支持。与此同时，Python的整个开发过程更加透明，社区对开发进度的影响逐渐扩大，生态圈开始慢慢形成。 2008年12月3日：Python 3.0发布，它并不完全兼容之前的Python代码，不过因为目前还有不少公司在项目和运维中使用Python 2.x版本，所以Python 3.x的很多新特性后来也被移植到Python 2.6/2.7版本中。 1.1.2 Python的优缺点 Python优点 简单明了，容易上手，比其他语言易学 开放源代码，拥有很强大的社区和生态圈，尤其是在数据分析和机器学习领域、 解释型语言，具有很强的移植性，代码可工作于不同的平台 支持面向对象式编程和函数式编程】 代码规范性高，可读性强 Python的缺点 执行效率稍低，对执行效率要求高的部分可以由其他语言（如：C、C++）编写。 代码无法加密，但是现在很多公司都不销售卖软件而是销售服务，这个问题会被弱化。 在开发时可以选择的框架太多（如Web框架就有100多个），有选择的地方就有错误。 1.1.3 Python的应用领域 目前Python在Web应用后端开发、云基础设施建设、DevOps、爬虫、自动化自测、数据分析、机器学习等领域应用广泛。 1.2 安装Python 查看Python版本 可以Windows的命令行提示符中键入下面的命令。 python --version 在Linux或macOS系统的终端中键入下面的命令。 python3 --version 1.3Python语法基础 Python语法特点 注释规则：单行注释#，多行注释（3 个单引号（'''）或 双引号（\"\"\"）） 语句换行：语句太长，可使用反斜杠（\\）可以实现一条长语句的换行；以小括号()、中括号[]或大括号{}包含起来的语句，不必使用反斜杠也可以被分成多行。 一行写多个语句：Python 允许将多个语句写在同一行上，语句之间用分号隔开，例如： a=10; b=20;print(a+b) 代码块：缩进位置相同的一组语句形成一个代码块。例如，在下面示例代码中，if True：下面的两行代码就构成了一个代码块。 if True: print (\"结果:\") print (\"True\") 缩进分层：Python 最具特色的语法特点就是以缩进的方式来标识代码块，不再需要使用大括号（{}），使得代码看起来更加简洁。Python 程序中同一个代码块中的语句必须保证相同的缩进空格数，缩进的空格数没有硬性规定，但必须保证空格数是相同的，否则将会出错 模块：Python中的模块分为内置模块和非内置模块。内置模块不需手动导入，启动Python时系统会自动导入，任何程序都可以直接使用它们。非内置模块以文件的形式存在于Python的安装目录中，程序使用前需要导入模块。导入模块的语法格式如下： import [模块名] 例如，导入数学模块：import math # 导入数学模块 1.3.1 第一个Python程序 使用Pycharm编写第一个Python程序HelloWorld print('Hello World') 命令行模式运行程序 切换到源代码所在的目录并执行下面的命令，看看屏幕上是否输出了\"hello, world!\"。 python hello.py 1.3.2 代码注释 单行注释 - 以#和空格开头的部分 多行注释 - 三个引号开头，三个引号结尾 ''' print('Hello World') 多行注释 print(\"多行注释\")# 多行注释 ''' # print(\"多行注释\") 单行注释 1.2.3 Python之禅 在编辑器中输入下面代码并运行程序 import this 说明：输入上面的代码，在Python的交互式环境中可以看到Tim Peter撰写的“Python之禅”，里面讲述的道理不仅仅适用于Python，也适用于其他编程语言。 1.2.4 使用turtle在屏幕上绘制图形。 说明：turtle是Python内置的一个非常有趣的模块，特别适合对计算机程序设计进行初体验的小伙伴，它最早是Logo语言的一部分，Logo语言是Wally Feurzig和Seymour Papert在1966发明的编程语言。 import turtle turtle.pensize(4) turtle.pencolor('red') turtle.forward(100) turtle.right(90) turtle.forward(100) turtle.right(90) turtle.forward(100) turtle.right(90) turtle.forward(100) turtle.mainloop() 1.3.3 变量和类型 程序设计中，变量是一种存储数据的载体。计算机中的变量是实际存在的数据或者说是存储器中存储数据的一块 内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多种类型，除了数 值之外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类。 Python中的数据类型很多，而且也允许我们自定义新的数据类型，我们先介绍几种常用的数据类型。 整型：Python中可以处理任意大小的整数（Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如0b100，换算成十进制是4）、八进制（如0o100，换算成十进制是64）、十进制（100）和十六进制（0x100，换算成十进制是256）的表示法。 a=1;#a是整型 b=12241412545262345;#b也是整型 print(a,b); 浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。 a=1.10;#a是浮点型 b=1.2e2;#b也是浮点型 print(a,b); 字符串型：字符串是以单引号或双引号括起来的任意文本，比如'hello'和\"hello\",字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。** print('你好~') print('''q asdadfsafdafa asfassfa q''') 布尔型：布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 会产生布尔值True，而2 == 1会产生布尔值False）。 print(3>1)#true print(3>5)#false 复数型：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的i换成了j。 a=-1+3j; print(a)#(-1+3j) print(a.imag)#3.0 print(a.real)#-1.0 1.3.4 变量命名及使用 在Python中，变量命名需要遵循以下这些必须遵守硬性规则和强烈建议遵守的非硬性规则。 变量名有字母、数字、下划线、美元符号构成，数字不能开头 大小写敏感 不能是关键字和系统保留字 用小写字母拼写，多个单词用下划线连接。 受保护的实例属性用单个下划线开头（后面会讲到）。 私有的实例属性用两个下划线开头（后面会讲到）。 作为一个专业的程序员，给所有的标识符命名时做到见名知意也是非常重要的。 变量赋值及运算 示例一 a=121; b=11; print(a+b);#加 print(a/b);#除 print(a-b);#减 print(a//b);#整除 print(a**b);#幂 print(a%b);#模 示例二 #input()输入 f=input('请输入你的年龄：'); #type()函数判断变量的类型 print(type(f))#字符串类型 #int（）转换数据类型 ff=int(f);#整数类型 print(type(ff))#字符串类型 print('你今年'+f+'岁了');#你今年12岁了 用+拼接时所有参数类型必须相同 print('你今年',ff,'岁了');#你今年 12 岁了 用，拼接时参数类型不一定相同 示例三 a = int(input('a = '))#1 b = int(input('b = '))#3 print('%d + %d = %d' % (a, b, a + b)) print('%d - %d = %d' % (a, b, a - b)) print('%d * %d = %d' % (a, b, a * b)) print('%d / %d = %f' % (a, b, a / b)) print('%d // %d = %d' % (a, b, a // b)) print('%d %% %d = %d' % (a, b, a % b)) print('%d ** %d = %d' % (a, b, a ** b)) 示例四 a = 100 b = 12.345 c = 1 + 5j d = 'hello, world' e = True print(type(a)) print(type(b)) print(type(c)) print(type(d)) print(type(e)) 1.3.5 标准输入输出函数 标准输入函数input（） Python 内置的input() 函数用于接收用户通过键盘输入的字符串。input()函数的基本语法格式如下： input([prompt]) 其中，prompt 是可选参数，在输入的时候起辅助作用，提示用户输入需要输入什么样的数据。当用户输入数据并按回车后，input 函数就会返回字符串对象，通常需要一个变量来接收用户输入的数据。 name = input(\"请输入一个歌星的姓名：\") #input()输入 f=input('请输入你的年龄：'); #type()函数判断变量的类型 print(type(f))#字符串类型 #int（）转换数据类型 ff=int(f);#整数类型 print(type(ff))#字符串类型 print('你今年'+f+'岁了');#你今年12岁了 用+拼接时所有参数类型必须相同 print('你今年',ff,'岁了');#你今年 12 岁了 用，拼接时参数类型不一定相同 在一行中依次输入数值，并用空格分开 a,b,c=input().split() #输出样例 3 4 5 案例一:根据输入的数字打印乘法表 n=int(input()) for x in range(1,n+1): for y in range(1,x+1): print('%d*%d=%d'%(y,x,x*y),end=' ') print() 标准输出函数print（） Python 内置的print () 函数用于输出显示数据。print ()函数的基本语法格式如下： print(value,…，sep=' ' ,end='\\n') value 是表示输出对象，后面的省略号表示可以列出多个输出对象，以逗号隔开。 sep 用于设置多个要输出信息之间的分隔符，默认值为一个空格。 end 表示 print语句的结束符号，默认值为换行符。 print(\"我最喜欢的歌星是\",\"邓丽君\",sep=',') print(\"我最喜欢的歌星是\",\"邓丽君\",end='$') 1.3.6 数据类型 Python中的数据类型 简单数据类型：数字类型（int、float、bool、compiex）、字符串类型 复杂数据类型：List、Set、Tuple、Dictionary 数字类型： int（整型）：用于表示整数，不带小数点，但可以有正号或负号，例如：10、1024、-100、99、-66等。 Python 3.9对整型是没有大小限制的，只要内存许可，整数的取值范围几乎包括了全部整数（无限大），这给大 数据的计算带来便利。在Python 3.9中，只有一种整数类型 int，没有Python 2.7中的Long。 float（浮点型）：小数形式，示例：1.23、100.0、-123.45、-0.123 bool（布尔型）：布尔类型的值只有两个： True 和 False，表示真和假。如果将布尔值进行数值运算，True 会被当做整数 1，False 会被当做整数 0 complex（复数类型）:复数由实数（real）部分与虚数（imag）部分构成，表示形式为 real + imag（j/J后缀），实数和虚数部分都是浮点数。复数的示例如下： c=1.5+0.7j #实数 a=c.real=1.5 #虚数 b=c.imag=0.7 字符串类型： 标识字符串 用单引号标识字符串。 用双引号标识字符串。 用三引号（'''或者\"\"\"）标识字符串。 三引号相比单引号和双引号，有一个特殊的功能，它能够标识一个多行的字符串，而且该多行字符串中的换行、缩进等格式都会原封不动地保留。 转义字符 Python中的转义字符是以反斜杠“\\”为前缀，转义字符的意义就是避免字符出现二义性，二义性是所有编程语言都不允许的。 字符串常用方法 1.3.7 数据类型转换 int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 a = 100 b = '12.345' c = '11' d = 'h' print(int(c)); print(float(b)); print(str(a)); print(chr(a)); print(ord(d)) 计算结果如下 11 12.345 100 d 104 1.3.8 类型判断函数type() a = 100 b = 12.345 c = 1 + 5j d = 'hello, world' e = True print(type(a)) print(type(b)) print(type(c)) print(type(d)) print(type(e)) 输出结果如下 1.3.9 占位符 在python中，占位符的表示有三种： %s字符串占位符 %d整数占位符 %f浮点数占位符 %c字符占位符 %f只能占位浮点数，%.xf 则是精确至小数点后x位，而%1f表示保留1位，%2f表示保留2位， a = int(input('a = '))#1 b = int(input('b = '))#3 c=input()#哈哈 d=float(input())#1.4 print('%d + %d = %d' % (a, b, a + b)) print('%d - %d = %d' % (a, b, a - b)) print('%d * %d = %d' % (a, b, a * b)) print('%d / %d = %f' % (a, b, a / b)) print('%d // %d = %d' % (a, b, a // b)) print('%d %% %d = %d' % (a, b, a % b)) print('%d ** %d = %d' % (a, b, a ** b)) print('你叫%s'%c)#你叫哈哈 print('保留两位小数%.2f'%a)#1.00 输出结果如下 a = 1 b = 3 1 + 3 = 4 1 - 3 = -2 1 * 3 = 3 1 / 3 = 0.333333 1 // 3 = 0 1 % 3 = 1 1 ** 3 = 1 1.3.10 运算符的使用 Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，我们会陆续使用到它们。 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 >> 右移，左移 & 按位与 ^ ` ` > >= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 = += -= *= /= %= //= **= &= ` =`^= >>= 逻辑运算的真值表 赋值运算符 在 Python 中，使用 = 可以给变量赋值，在算术运算时，为了简化代码，Python 还提供了一系列的与算术运算符对应的赋值运算符 运算符练习 a=4; b=7; print('a=',a) print(a+b);#加 print(a/b);#除 print(a-b);#减 print(a//b);#整除 print(a**b);#幂 print(a%b);#模 flag1=a>b;#false flag2=a 计算结果如下 a= 4 11 0.5714285714285714 -3 0 16384 4 flag1= False flag2= True flag3= False flag4= False flag5= True True True True 练习一：华氏温度转换为摄氏温度 f = float(input('请输入华氏温度: ')) #度数转换 c = (f - 32) / 1.8 #占位符 print('%.1f华氏度 = %.1f摄氏度' % (f, c)) 练习二：输入圆的半径求圆的面积和周长 import math; r=int(input('请输入圆的半径：')); s=math.pi*r*r; c=2*math.pi*r; print('周长：%.2f'%c); print('面积：%.2f'%s); 练习三：输入年份判断是不是闰年。 year=int(input('请输入年份：')); is_leap=(year % 4 == 0 and year % 100 != 0 or year % 400 == 0); print(is_leap); 1.4 分支控制结构 迄今为止，我们写的Python代码都是一条一条语句顺序执行，这种结构的代码我们称之为顺序结构。然而仅有顺序结构并不能解决所有的问题，比如我们设计一个游戏，游戏第一关的通关条件是玩家获得1000分，那么在完成本局游戏后我们要根据玩家得到分数来决定究竟是进入第二关还是告诉玩家“Game Over”，这里就会产生两个分支，而且这两个分支只有一个会被执行，这就是程序中分支结构。 1.4.1 if语句的使用 admin=input('请输入用户名：'); passwd=input('请输入密码：'); if admin=='dingding' and passwd=='123456': print('欢迎光临！'); else : print('滚！'); 和C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于是一个执行的整体。 1.4.2 if···elif···else语句的使用 f(x)={3x−5(x>1)\\x+2(-1≤x≤1)\\5x+3(x # f(x)={3x−5(x>1)\\x+2(-1≤x≤1)\\5x+3(x1 : y=3*x-5; elif x>=-1 and x 当然根据实际开发的需要，分支结构是可以嵌套的，例如判断是否通关以后还要根据你获得的宝物或者道具的数量对你的表现给出等级（比如点亮两颗或三颗星星），那么我们就需要在if的内部构造出一个新的分支结构，同理elif和else中也可以再构造新的分支，我们称之为嵌套的分支结构，也就是说上面的代码也可以写成下面的样子。 x = float(input('x = ')) if x > 1: y = 3 * x - 5 else: if x >= -1: y = x + 2 else: y = 5 * x + 3 print('f(%.2f) = %.2f' % (x, y)) 练习一：掷色子 说明：代码中使用了random模块的randint函数生成指定范围的随机数来模拟掷骰子。 # 掷色子 from random import randint; face=randint(1,6); if face==1: print('唱歌吧'); elif face==2: print('跳舞吧'); elif face==3: print('吃饭吧'); elif face==4: print('逛街吧'); elif face==5: print('喝酒吧'); else: print('旅游把'); 练习二：分值转换 grade=int(input('请输入你的分数：')); if grade>=90 and grade=70 and grade=60 and grade=40 and grade=0 and grade 1.5 循环控制结构 如果在程序中我们需要重复的执行某条或某些指令，例如用程序控制机器人踢足球，如果机器人持球而且还没有进 入射门范围，那么我们就要一直发出让机器人向球门方向奔跑的指令。当然你可能已经注意到了，刚才的描述中其 实不仅仅有需要重复的动作，还有我们上一个章节讲到的分支结构。再举一个简单的例子，比如在我们的程序中要 实现每隔1秒中在屏幕上打印一个\"hello, world\"这样的字符串并持续一个小时，我们肯定不能够将print('hello, world')这句代码写上3600遍，如果真的需要这样做那么编程的工作就太无聊了。因此，我们需要了解一下循环 结构，有了循环结构我们就可以轻松的控制某件事或者某些事重复、重复、再重复的发生。在Python中构造循环 结构有两种做法，一种是for-in循环，一种是while循环。 1.5.1 for-in循环 如果明确的知道循环执行的次数或者是要对一个容器进行迭代（后面会讲到），那么推荐使用for-in循环，例如下面代码中计算∑100n=1n∑n=1100n。 sum=0; for x in range(101): sum=sum+x; print(sum) 代码中的range类型，range可以用来产生一个不变的数值序列，而且这个序列通常都是用在循环中的，例如： range(101)可以产生一个0到100的整数序列。 range(1, 100)可以产生一个1到99的整数序列。 range(1, 100, 2)可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。 也可以在循环中加入条件语句。 sum=0; for x in range(1,101): if x%2==0: sum=sum+x; print(sum) 1.5.2 while循环 如果要构造不知道具体循环次数的循环结构，我们推荐使用while循环，while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True循环继续，表达式的值为False循环结束。下面我们通过一个“猜数字”的小游戏（计算机出一个1~100之间的随机数，人输入自己猜的数字，计算机给出对应的提示信息，直到人猜出计算机出的数字）来看看如何使用while循环。 练习：猜数字游戏 import random; answer=random.randint(1,101); # print(answer) count=0; while True: count=count+1; number=int(input('请输入一个1-100之间的整数：')) if numberanswer: print('再小一点') else : print('恭喜你答对了') break print('你共猜了%d次'%count) if count>7: print('脑袋瓜子不行呀'); elif count 说明：上面的代码中使用了break关键字来提前终止循环，需要注意的是break只能终止它所在的那个循环，这一点在使用嵌套的循环结构（下面会讲到）需要引起注意。除了break之外，还有另一个关键字是continue，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。 1.5.3 循环嵌套 和分支结构一样，循环结构也是可以嵌套的，也就是说在循环中还可以构造循环结构。下面的例子演示了如何通过嵌套的循环来输出一个九九乘法表。 # 九九乘法表 for x in range(1,10): for y in range(1,x+1): print('%d*%d=%d'%(x,y,x*y),end='\\t') print() 案例一：根据输入的数字打印乘法表 n=int(input()) for x in range(1,n+1): for y in range(1,x+1): print('%d*%d=%d'%(y,x,x*y),end=' ') print() 1.5.4 break语句 Python中，break语句用于强制跳出当前循环。 i=2; while i(i/2): print(\"%d是素数\"%i) i=i+1; 1.5.5 pass语句 pass语句表示空代码，即程序不做热河事情。由于python语言没有花括号来表示代码块，但是在有些地方如果没有代码，系统会报错，此时就可以使用pass语句。pass语句常用来标记留待以后开发的代码，作为占位符使用。 i=0; for i in range(0,10): pass 1.6 Python数据结构 在Python中有四种内建的数据结构，分别是列表（List）、元组（Tuple）、字典（Dictionary）、集合（Set） 1.6.1 列表（List） list是动态的，长度大小不固定可以随意增加删除改变元素 列表有三种创建方式：方括号、函数、推导式 使用方括号创建列表 #列表创建 list=[\"钉子君\",90,\"南雨\",'nanyu'] 如果方括号中为空，则创建一个非空的列表，如list=[]; 使用构造函数创建列表 python提供了list类的构造函数，可以用来创建列表，类似类型转换。 #元组 t=(1,\"nanyu\",2,4) print(t) #使用list（）构造函数将元组转换为列表 list=list(t) print(list) 使用列表推导式创建列表 列表推导式是利用已有的列表根据要求创建一个新的列表，主要用于动态创建列表。 #已有列表 list1=[1,2,3,4] #利用已有列表动态创建新列表 list2=[n*2 for n in list1]#[2, 4, 6, 8] print(list2) 1.6.1.1 列表基本操作 访问列表元素 nums=[1,2,3,4] print(nums[1]) for循环遍历列表 nums=[1,2,3,4] for i in nums: print(i) while循环遍历列表 nums=[1,2,3,4] while i list常用方法 列表list是一个类，一旦一个列表被创建就构造了一个列表对象，可以使用该列表对象调用类的成员方法，也就是 可以用列表名调用列表的相关方法。语法格式如下：列表名.方法名（） append(x)方法： 再列表的末尾追加元素 nums=[1,2,3,4] nums.append(5) print(nums) insert(x,value)方法： 在指定位置添加元素 nums=[1,2,3,4] nums.insert(2,8) print(nums) extend(L）方法： 将一个列表添加到另一个列表的末尾 nums=[1,2,3,4] nums2=[5,6] nums.extend(nums2) print(nums) removex(x)方法： 删除列表中第一个与x相同的元素 nums=[1,2,3,4] nums.remove(2) print(nums) pop()方法： 删除列表中最后一位，并返回被删除的元素 nums=[1,2,3,4] a=nums.pop() print(nums) print(a) count(x)方法： 返回列表中x出现的次数 nums=[1,2,2,3,4] a=nums.count(2) print(2) index(x)方法： 返回列表中x元素第一次出现的下标 nums=[1,2,2,3,4] a=nums.index(2) print(a) reverse()方法： 反转列表元素 nums=[1,2,2,3,4] nums.reverse() print(nums) sort()方法: 堆列表进行排序 nums=[1,5,2,3,4] nums.sort() print(nums) 1.6.2 元组（Tuple） 元组、String是动态的，不能随意增加删除改变元素 元组的两种创建方式：圆括号、函数 使用圆括号创建元组 如果创建一个空tuple，可以直接用()表示。但是，如果创建含有一个元素的tuple，需要在元素后面加逗号。 T1=()#空列表 T2=(\"南雨\")#错误示范，这样的结果返回的是一个字符串，而不是元组 T3=(\"南雨\",)#正确示范，如果是元组中只有一个元素，则末尾必须有, print(T1,T2,T3) 使用构造函数构建元组 Python提供了tuple类的构造函数，可以用来创建元组，语法格式如下:变量= tuple ([可迭代对象]) T1=tuple(\"南雨\") T2=tuple([1,2,3,4]) print(T1,T2) 1.6.3.1 元组的基本操作 元组的遍历与访问 T2=tuple([1,2,3,4]) print(T2[2]) for i in T2: print(i) 元组常用方法 index()方法： T2=(1,1,2,3,4) a=T2.index(2) print(a) count()方法： T2=(1,1,2,3,4) b=T2.count(1) print(b) 元组与列表的区别 元组 T2=(1,1,2,3,4) T2[2]=2 print(T2) #结果如下 Traceback (most recent call last): File \"D:/Appinstall/Pycharm/Project/Project03/test.py\", line 4, in T2[2]=2 TypeError: 'tuple' object does not support item assignment 列表 L=[1,2,3,4] L[2]=1 print(L) #结果如下 [1, 2, 1, 4] 元组的元素在确定之后不可以再做增上改操作，但列表在创建之后还可以进行增删改等操作。 1.6.3 序列及通用方法 序列是Python中最基本的数据结构。序列中的每个元素都分配一个索引，如果有n个元素，那么第一个索引是0， 第二个索引是1，依此类推，最后一个元素索引为n-1。另外，可以用负数来逆序表示元素的索引，最后一个元素 的索引是-1，倒数第二个元素索引是-2，以此类推，第一个元素索引是-n。 前面的列表，元组以及字符串都是序列。这些序列都可以使用以下操作:切片，连接和复制，成员检查，计算长度，取最大值等。 切片操作： L=[1,2,3,4,5,6] T=(1,2,3,4,5,6) S=\"123456\" print(L[0:4:2])#打印列表中1-4的元素，步长为2 print(T[0:4:2])#打印元组中1-4的元素，步长为2 print(S[0:4:2])#打印字符串中1-4的元素，步长为2 在切片操作中开始索引和结束索引都可以为空，下面是切片操作几种用法的介绍。 (1）如果切片的结束索引j为空，那么就获取从开始索引i到序列结束的所有元素。 (2）如果切片的开始索引i为空，那么获取从序列开始到索引为j-1的元素。 (3）如果开始和结束的索引都为空，那么获取整个序列。 (4）根据获取元素的顺序，如果开始元素位于结束元素之后，那么获取一个空序列。 (5）如果步长值为负数，表示逆序获取序列元素。 L=[1,2,3,4,5,6] T=(1,2,3,4,5,6) S=\"123456\" print(L[:4])#[1, 2, 3, 4] print(T[2:])#(3, 4, 5, 6) print(S[:])#123456 print(L[4:2])#[] print(L[2:4:-1])#[] print(T[4:2:-1])#(5, 4) 序列连接 在python中，可以使用连接操作符“+”把多个相同的序列合并在一起,并返回一个新的序列。 L=[1,2,3,4,5,6] L1=[9,8,7] T1=(1,2,3) T2=(4,5,6) S1=\"123\" S2=\"456\" print(T1+T2)#(1, 2, 3, 4, 5, 6) print(S1+S2)#123456 print(L+L1)#[1, 2, 3, 4, 5, 6, 9, 8, 7] 序列复制 在python中，使用操作符\"*\"可以把一个序列复制若干次形成新的序列。 L=[1,2,3,4,5,6] T1=(1,2,3) S1=\"123\" print(L*3)#[1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6] print(T1*2)#(1, 2, 3, 1, 2, 3) print(S1*4)#123123123123 成员检查（in和not in） Python提供了两个成员运算符in和not in，用来判断一个元素是否在序列中。如果用in运算符，存在则返回 True，否则为False。如果用not in运算符，不存在则返回True，存在则返回False。 L=[1,2,3,4,5,6] T1=(1,2,3) S1=\"123\" print(7 in L)#False print(4 in T1)#False print(\"4\" not in S1)#True 内置函数 Python中内置了许多有关序列的函数，比如len()、max()、min()等等。 L=[1,2,3,4,5,6] T1=(1,2,3) S1=\"123\" print(len(L),len(T1),len(S1))#6，3，3 print(max(L))#6 print(min(T1))#1 1.6.4 元组、列表、字符串的相互转换 字符串转元组和列表 L=[1,2,3,4,5,6] T1=(1,2,3) S1=\"123\" #字符串转列表和元组 print(list(S1))#['1', '2', '3'] print(tuple(S1))#('1', '2', '3') 列表与元组相互转换 L=[1,2,3,4,5,6] T1=(1,2,3) S1=\"123\" #字符串转列表和元组 print(list(T1))#[1, 2, 3] print(tuple(L))#(1, 2, 3, 4, 5, 6) 1.6.5 字典 Python中，字典Dict使用键-值对来存储数据。一个字典中无序的存储了若干个条目，每个条目都是一个键-值 对，关键字在字典中是唯一的，每个关键字匹配个值，可以使用键来获取相关联的值。 "},"7-Hadoop/1-Centos7安装.html":{"url":"7-Hadoop/1-Centos7安装.html","title":"1. Centos7安装","keywords":"","body":"Centos7安装 点击创建新的虚拟机 选择自定义，然后点击下一步 直接点击下一步。 选择稍后安装操作系统。 选择Linux系统，版本为CentOS7 64位 修改虚拟机位置。 处理器根据自己电脑配置及自己需求配置即可。 根据自己电脑配置及需求设置内存大小。 选择NAT模式。 默认即可。 默认即可。 选择创建新的虚拟磁盘。 根据自己需求设置磁盘大小。 可做修改也可不修改。 自定义硬件。 选择新CD/DVD，使用ISO镜像文件，点击浏览选择下载好的ISO镜像文件。 最后点击关闭即可。 点击完成。 开启虚拟机 鼠标点入黑框，使用上方向键选择Install CentOS7。 选择中文简体 选择安装位置 直接点击完成。 网络配置 点击网络和主机名。 接下来选择常规。 选择IPV6，选择忽略。 选择IPV4设置，将自动改为手动，然后先不要关闭，下面还要设置IP。 点击VM虚拟机的左上角编辑-虚拟网络编辑器，选择NAT模式-NAT设置 点击IPV4中的Add，把虚拟网络编辑器中的配置一一对应填进去，具体步骤如下图。（地址栏对应子网ip，最后一位0可随意换成100-255之间的数字，子网掩码填24，网关对应网关IP） 配置好的网络状况如下，无误后点击完成。 点击开始安装。 设置Root账户密码。 设置密码之后点击完成。 等待安装完成即可，时间可能较久。 安装完成之后，点击重启。 输入账户：root，密码：（输入之后看不见，输完之后直接回车）。 ping百度网址，测试网络是否通顺。 新节点安装成功。 "},"7-Hadoop/2-Hadoop环境搭建.html":{"url":"7-Hadoop/2-Hadoop环境搭建.html","title":"2. Hadoop环境搭建","keywords":"","body":"Hadoop环境配置 前提条件：已安装虚拟机，已安装三台centOS7 1.1 基本工具安装 安装openssh 三台节点上都要安装 [root@node01 ~]# yum -y install openssh-clients [root@node02 ~]# yum -y install openssh-clients [root@node03 ~]# yum -y install openssh-clients 安装时间同步工具 三台节点均要安装 #!安装ntpdate工具 [root@node01 ~]# yum -y install ntp ntpdate #!设置与网络时间同步 [root@node01 ~]# ntpdate cn.pool.ntp.org #!系统时间写入硬件时间【将硬件时钟调整为与目前的系统时钟一致】 [root@node01 ~]# hwclock --systohc 安装vim编辑器 每个节点都要安装 [root@node01 ~]# yum -y install vim 安装上传（rz）下载(sz)工具 在主节点安装即可 [root@node01 ~]# yum -y install lrzsz 安装网络下载工具wget 主节点安装即可 [root@node01 ~]# yum -y install wget 关闭防火墙 每个节点都需要操作（包括关闭防火墙和开机自启防火墙） #!查看防火墙开启状态 [root@node01 ~]# systemctl status firewalld #!关闭防火墙 [root@node01 ~]# systemctl stop firewalld #!禁止开机启动防火墙 [root@node01 ~]# systemctl disable firewalld #！无需执行------------------------------------------------- #!开启防火墙 [root@node01 ~]# systemctl start firewalld #!设置开机启动防火墙 [root@node01 ~]# systemctl enable firewalld #!重启防火墙 [root@node01 ~]# systemctl restart firewalld 1.2 修改Host文件 在每个节点中都添加以下内容 192.168.154.101 node01 192.168.154.102 node02 192.168.154.103 node03 注释掉前两行 [root@node01 ~]# vim /etc/hosts #127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 #::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 192.168.100.101 node01 192.168.100.102 node02 192.168.100.103 node03 1.3 配置免密登录 每个节点都执行 #! 每台节点先使用ssh执行以下，以在主目录产生一个.ssh 文件夹 [root@node01 ~]# ssh 192.168.154.101 #! 然后输入no即可 The authenticity of host '192.168.100.101 (192.168.100.101)' can't be established. ECDSA key fingerprint is SHA256:PamSi9sKideQkXQWm9stSYkf85oydA+TUbwiBtXkf4E. ECDSA key fingerprint is MD5:5b:17:f8:7c:ae:49:27:f8:2a:24:30:65:a6:f3:4a:49. Are you sure you want to continue connecting (yes/no)? no Host key verification failed. #! 每台机器均进入~/.ssh 目录进行操作 [root@node01 ~]# cd ~/.ssh #! 输入以下命令，一路回车，用以产生公钥和秘钥 [root@node01 .ssh]# ssh-keygen -t rsa -P '' #! 出现以下信息说明生成成功 Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: SHA256:KU0Z/kXpvREFPvkq6wBwog8NLjZ6fSQDyM+747BtUsA root@node01 The key's randomart image is: +---[RSA 2048]----+ | . ...o.| |.. . o ..... | |o.. . o = ...+. | | Eoo + * o .. oo | | =o* + S . o.| | o =.* . . .. | |..o.. o . . . | | o+o.. . o | | .++. .o | +----[SHA256]-----+ #! 将每台机器上的id_rsa.pub公钥内容复制到authorized_keys文件中 [root@node01 .ssh]# cp id_rsa.pub authorized_keys #! 将所有的authorized_keys文件进行合并（最简单的方法是将其余两台node主机的文件内容追加到node01主机上） [root@node02 .ssh]# cat ~/.ssh/authorized_keys | ssh root@node01 'cat >> ~/.ssh/authorized_keys' [root@node03 .ssh]# cat ~/.ssh/authorized_keys | ssh root@node01 'cat >> ~/.ssh/authorized_keys' #! 查看node01上的authorized_keys文件内容，类似如下即可 [root@node01 .ssh]# more authorized_keys ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCqJi/Q061hGWv91WkRl+fpvoiQ6OyqLSc4lu5KR0FLmWmRxu/Bp1AeuBzf1V8YyjK+UNapYQMgX2/0RPjDWdCKfchrfhvQz9rOX7w8bqmcYGS44EFvy0kxBxPRUd0q/X/cm6J9tvOHsgKJEXIzTG1HD+arjUBmgbP6MOr1mH3UgjJqkhRS5SYP+RcbrRDnTVH+9IE2bKBBHadxK2r8GlP6DL/CtjjYAQSms9x9b9YR9rk/hDUmRO6piq+upy2Gmp4br1EnRTk3LLgIe5sJZQiBQOaoULL7tj6J7D2LXbC0z+a9p8s/PfE/G/7jhxBAoYpzB30JV5BPZmz702JOQjRn root@node01 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDLeDS5mF/PwxExo++I99A3BfK8gyaLUYC8mZGLT4q0H8Skb/7jN1qIjb8MfwubluoIKiHWrA2h/4iEkb2rBzEfUy/JxP+5a+zpi5NIOcVCX1PcNb7mPmWm1X42Zp6/hOZVXnAHfQv4ZuEZRZrp49GmOnZR8g5mz8Gpr0rl9hk0c1m50qpfY6I8EYjQ200suo/9vkd941Qquk3aX4A+6huAZq1Lu8B1EyTTDoV6cWS1eN4AbEdN4nedYN1NqfN5KxYs9ujCfCNfmF41l7HS8vgPc4Yu0aI4LmZnmFhLei0FdK6HSE03nptm7YJ45oDux5iehxXT8M0nvwC2JcK26aoD root@node02 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTpPnqphGbBH3vqFFdI0oxq1EmI0zWbrl/52qIy6ysvJ+cqib34XzFHs4N61P4pyXwzL7tgMaYrAw0YfVMbZwmK3AAlpxlLTpfWLii/dBTazGcXaHhR0J3s6qKIwu3ZEaeAUGWyGO4KU1uMWM9foLWeAQthTJhYj4HmE2YNmHV5M39uw+F0j2JXMiWZBLEaklu/IpuWY0IgYVvj/uACowmeFUHHWsYezH0GbxcHPpLnenSfcWxUAXNNaVYURKV6WnXqmsxV/9k8rWQ49Apk5AjHsAKpdWRXEzGVr0FBBydoGkCCNvgrr1ORAAiUnFOp0ZEx/Pq9T8cQVdCjk0pILwv root@node03 #! 将node01上的authorized_keys文件分发到其他主机上 [root@node01 .ssh]# scp ~/.ssh/authorized_keys root@node02:~/.ssh/ [root@node01 .ssh]# scp ~/.ssh/authorized_keys root@node03:~/.ssh/ #! 每台机器之间进行ssh免密码登录操作，包括自己与自己 [root@node01 ~]# ssh node01 [root@node01 ~]# ssh node02 [root@node02 ~]# ssh node01 [root@node01 ~]# ssh node03 [root@node03 ~]# ssh node01 [root@node01 ~]# ssh node02 [root@node02 ~]# ssh node02 [root@node02 ~]# ssh node03 [root@node03 ~]# ssh node02 [root@node02 ~]# ssh node03 [root@node03 ~]# ssh node03 1.4 下载JAVA Hadoop 的运行需要Java环境，因此必须在所有节点上安装Java，并且对Java版本有如下要求：Hadoop 3.3 以上支持Java 8 and Java 11，但是编译时只支持Java 8 Hadoop 3.0 — 3.2 只支持Java 8 Hadoop 2.7.x — 2.x 支持Java 7 and Java 8 官网下载：https://www.oracle.com/java/technologies/oracle-java-archive-downloads.html 1.5 安装JDK 注意： 只需要在node01上配置即可，其他节点可以在最后远程复制过去 /etc/profile：在用户第一次登录时，加载一次 #! 在node01主节点上创建指定目录 [root@node01 ~]# mkdir -p /opt/apps #! 进入到apps目录 [root@node01 ~]# cd /opt/apps/ #! 使用rz命令从Windows主机上传jdk压缩包到node01节点，也可以直接拖拽至xshell命令窗口 [root@node01 apps]# rz #! 解压到当前目录 [root@node01 apps]# tar -zxvf jdk-8u261-linux-x64.tar.gz #! 配置环境变量，亦可配置到 /etc/bashrc 中 [root@node01 apps]# vim /etc/profile #! 在该文件后面追加一下内容 export JAVA_HOME=/opt/apps/jdk1.8.0_261 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib/rt.jar export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin #! 使刚才的设置生效 [root@node01 apps]# source /etc/profile #! 检测是否配置成功 [root@node01 apps]# java -version java version \"1.8.0_261\" Java(TM) SE Runtime Environment (build 1.8.0_261-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode) 1.6 下载Hadoop并安装 官网链接：https://hadoop.apache.org/releases.html 下载完成后上传至node01节点，其他节点可以先不配置，最后统一远程拷贝即可。 #! 上传 [root@node01 ~]# cd /opt/apps [root@node01 apps]# rz #! 解压 [root@node01 apps]# tar -zxvf hadoop-3.1.4.tar.gz #! 查看解压后的目录信息 [root@node01 apps]# ll hadoop-3.1.4/ 总用量 176 drwxr-xr-x. 2 1001 1002 183 7月 21 16:27 bin drwxr-xr-x. 3 1001 1002 20 7月 21 16:07 etc drwxr-xr-x. 2 1001 1002 106 7月 21 16:27 include drwxr-xr-x. 3 1001 1002 20 7月 21 16:27 lib drwxr-xr-x. 4 1001 1002 288 7月 21 16:27 libexec -rw-rw-r--. 1 1001 1002 147145 7月 21 14:34 LICENSE.txt -rw-rw-r--. 1 1001 1002 21867 7月 21 14:34 NOTICE.txt -rw-rw-r--. 1 1001 1002 1366 7月 21 14:34 README.txt drwxr-xr-x. 3 1001 1002 4096 7月 21 16:07 sbin drwxr-xr-x. 4 1001 1002 31 7月 21 16:45 share 1.7 修改配置文件 在Hadoop中有以下配置文件需要做修改，详情请查看Hadoop 3.1.4 集群配置 hadoop-env.sh 此配置文件是Hadoop一些核心脚本的配置文件，要指定JAVA_HOME。 [root@node01 apps]# cd hadoop/ [root@node01 hadoop]# vim etc/hadoop/hadoop-env.sh export JAVA_HOME=/opt/apps/jdk core-site.xml 此配置文件是Hadoop核心的配置文件，对应于Common模块在此配置文件中配置文件系统的访问端口和访问权限等。 [root@node01 hadoop]# vim etc/hadoop/core-site.xml 中间添加一下内容--> fs.defaultFS hdfs://node01:9000 hadoop.tmp.dir file:/opt/apps/hadoop/tmp hadoop.http.staticuser.user root hdfs-site.xml 此配置文件是HDFS核心的配置文件，对应于HDFS模块，在此配置文件中配置文件系统数据存储路径和SecondaryNameNode地址等。 [root@node01 hadoop]# vim etc/hadoop/hdfs-site.xml 中间添加一下内容--> dfs.namenode.name.dir file:/opt/apps/hadoop/dfs/name dfs.datanode.data.dir file:/opt/apps/hadoop/dfs/data dfs.replication 2 dfs.namenode.checkpoint.dir file:/opt/apps/hadoop/dfs/namesecondary dfs.namenode.secondary.http-address node03:9868 dfs.namenode.secondary.https-address node03:9869 yarn-site.xml [root@node01 hadoop]# vim etc/hadoop/yarn-site.xml 此配置文件是Yarn核心的配置文件，对应于Yarn模块，在此配置文件中配置ResourceManager主机名和NodeManager内存大小等。 中间添加一下内容--> yarn.nodemanager.aux-services mapreduce_shuffle yarn.nodemanager.aux-services.mapreduce_shuffle.class org.apache.hadoop.mapred.ShuffleHandler yarn.resourcemanager.hostname node02 yarn.nodemanager.resource.memory-mb 4096 yarn.log-aggregation-enable true yarn.log-aggregation.retain-seconds 604800 mapred-site.xml 此配置文件是MapReduce核心的配置文件，对应于MapReduce模块， [root@node01 hadoop]# vim etc/hadoop/mapred-site.xml mapreduce.framework.name`MapReduce程序运行的框架，默认为local，集群模式配置为`yarn mapreduce.framework.name yarn mapreduce.jobhistory.address node01:10020 mapreduce.jobhistory.webapp.address node01:19888 workers 该文件中配置所有DataNode节点的主机名 [root@node01 hadoop]# vim etc/hadoop/workers #添加以下内容:这里添加的是所有的数据节点，注意删除原来的localhost【必须配置】 node01 node02 node03 1.8 文件分发 将node01节点上的apps目录远程拷贝到其他节点 [root@node01 ~]# scp -r /opt/apps root@node02:/opt/ [root@node01 ~]# scp -r /opt/apps root@node03:/opt/ 1.9 设置环境变量 #! 所有各节点均编辑/etc/profile文件 [root@node01 hadoop-3.1.4]# vim /etc/profile #! 添加以下内容 ##Hadoop export HADOOP_HOME=/opt/apps/hadoop export HADOOP_LOG_DIR=$HADOOP_HOME/logs export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin ##Hadoop User export HADOOP_USERNAME=root export HDFS_NAMENODE_USER=$HADOOP_USERNAME export HDFS_DATANODE_USER=$HADOOP_USERNAME export HDFS_SECONDARYNAMENODE_USER=$HADOOP_USERNAME export YARN_RESOURCEMANAGER_USER=$HADOOP_USERNAME export YARN_NODEMANAGER_USER=$HADOOP_USERNAME #! 使设置立即生效 [root@node01 hadoop-3.1.4]# source /etc/profile 2.0 格式化Hadoop 格式：hdfs namenode -format [root@node01 ~]# hdfs namenode -format nanyu WARNING: /opt/apps/hadoop-3.1.4/logs/hadoop does not exist. Creating. 2020-09-02 03:53:28,388 INFO namenode.NameNode: STARTUP_MSG: /************************************************************ STARTUP_MSG: Starting NameNode STARTUP_MSG: host = node01/192.168.100.101 STARTUP_MSG: args = [-format, hnumi] STARTUP_MSG: version = 3.1.4 STARTUP_MSG: classpath = ********** STARTUP_MSG: build = https://github.com/apache/hadoop.git -r 1e877761e8dadd71effef30e592368f7fe66a61b; compiled by 'gabota' on 2020-07-21T08:05Z STARTUP_MSG: java = 1.8.0_261 /************************************************************ SHUTDOWN_MSG: Shutting down NameNode at node01/192.168.100.101 ************************************************************/ 2.1 启动Hadoop #! 在node01上启动HDFS [root@node01 ~]# start-dfs.sh Starting namenodes on [node01] 上一次登录：三 8月 2 04:21:57 CST 2020pts/0 上 Starting datanodes 上一次登录：三 8月 2 04:23:35 CST 2020pts/0 上 Starting secondary namenodes [node03] 上一次登录：三 8月 2 04:23:37 CST 2020pts/0 上 #! 在node02上启动Yarn [root@node02 ~]# start-yarn.sh Starting resourcemanager 上一次登录：三 9月 2 04:21:43 CST 2020pts/0 上 Starting nodemanagers 上一次登录：三 9月 2 04:23:28 CST 2020pts/0 上 #! 在node01上启动MapReduce历史记录服务 [root@node01 ~]# mapred --daemon start historyserver #! 在所有节点上使用jps命令查看进程状态 [root@node01 ~]# jps 3588 JobHistoryServer 2838 NodeManager 3068 NameNode 3196 DataNode 3646 Jps [root@node02 ~]# jps 2768 NodeManager 3207 Jps 3096 DataNode 2622 ResourceManager [root@node03 ~]# jps 1985 NodeManager 2275 Jps 2090 DataNode 2190 SecondaryNameNode 2.2 停止Hadoop #! 停止 MapReduce 历史服务 [root@node01 ~]# mapred --daemon stop historyserver #! 停止 Yarn [root@node02 ~]# stop-yarn.sh Stopping nodemanagers 上一次登录：三 8月 2 04:23:30 CST 2020pts/0 上 Stopping resourcemanager 上一次登录：三 8月 2 05:03:58 CST 2020pts/0 上 [root@node01 ~]# stop-dfs.sh Stopping namenodes on [node01] 上一次登录：三 8月 2 04:23:41 CST 2020pts/0 上 Stopping datanodes 上一次登录：三 8月 2 05:04:26 CST 2020pts/0 上 Stopping secondary namenodes [node03] 上一次登录：三 8月 2 05:04:28 CST 2020pts/0 上 2. Centos7安装Anaconda 2.1 下载 首先下载Anaconda，下面提供几种下载方法 可以去官网下载：官网下载 使用国内下载镜像，速度更快点，下载完之后再上传至服务器，这是清华镜像，点击即可跳转下载：清华镜像源 使用wget命令直接下载： wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2021.05-Linux-x86_64.sh 2.2 安装 使用bash直接执行脚本即可 bash ./Anaconda3-2021.05-Linux-x86_64.sh "},"9-Flume/1-Flume.html":{"url":"9-Flume/1-Flume.html","title":"3. Flume","keywords":"","body":"一、Flume 1.1 Flume简介 Flume提供了一个分布式的，可靠的,对大数据量的日志进行高效的收集，聚合,转移的服务,只能在Linux下使用。基于流式框架，容错性强，比较灵活简单。使用- -个简单的可扩展数据模型,可以为在线系统提供服务。可以用于对数据进行实时采集，Kafka (卡弗卡)实时采集。Spark,Storm对数据进行实时的处理。impala对数据进行实时的查询。Hive做离线数据处理，MR离线数据处理。 1.2 Flume架构 Flume主要有Agent组成，Agent由三部分组成Source（输入）、Channel（连接）、Sink（输出） Flume架构图 Agent 是一个 JVM 进程，它以Event(事件)的形式将数据从源头送至目的地。 Source 用于采集数据，即与数据的来源进行对接，然后将采集的数据流传输到 Channel。支持各种数据源的采集： Avro、Thrift、Exec、JMS、Spooling Directory、Taildir、Twitter、Kafka、NetCat、Sequence Generator、Syslog、Http、Stress、Legacy 以及自定义数据源。 Channel 即将 Source 和 Sinks 连接起来，类似于一个队列，是数据的缓冲区，默认有 Memory Channel 和 File Channel。 Sink 从 Channel 轮询读取数据，然后将数据写到目的地，目的地类型有：下一个 Source，HDFS、Hive、Logger、Avro、Thrift、IRC、File、HBase、ElasticSearch、Kafka、HTTP、Kite以及自定义 Sink。 Event 数据的传输单元。即事件，类似Java中的bean类。 数据传输 Source 可以监控某个文件或数据流，或端口等等，一旦数据源产生新的数据，拿到数据后，将数据分装成一个事件（Event），然后放入（put）到 Channel 中然后（Submit）提交，Channel 队列先进先出，Sink 就去 Channel 队列拉去数据，然后写入到目标中（ HDFS 或者其他的目标） 1.3 Flume应用设计 Flume不止有单Flumne设计，还可以有多Flum设计、合并设计、多输出设计 单Flume设计 一个Agent，Source连接的是被采集数据端，Sink连接的是输出端位置的地方。 多Flume设计 按照一定的顺序将多个Flume连接起来，一个Agent的Sink端指向下一个Agent的Source端，并且前一个Agent的Sink端，与下一个Agent的Source端必须都为Avro类型 合并Flume设计 多个Agent，多个Agent的Sink（Avro类型）的数据输出作为另外一个Agent（Avro类型）的Source是数据输入（常见于日志收集） 多输出Flume设计 将 Agent 数据流复用到一个或多个目的地。(多Channels，多Sink，多输出) 二、环境搭建 2.1 Flume环境搭建 要求：JDK1.8以上 Flume下载：官网链接 在一台节点上安装Flume即可 ## 1. 创建安装目录并上传 Flume 安装包 [root@node01 ~]# cd /opt/apps/ [root@node01 SoftWare]# mkdir Flume [root@node01 SoftWare]# cd Flume/ [root@node01 Flume]# rz [root@node01 Flume]# ls apache-flume-1.9.0-bin.tar.gz ## 2. 解压 Flume 安装包 [root@node01 Flume]# tar -zxf apache-flume-1.9.0-bin.tar.gz ## 3. 重命名 Flume文件夹名称 [root@node01 Flume]# mv apache-flume-1.9.0-bin flume-1.9.0 [root@node01 Flume]# ls apache-flume-1.9.0-bin.tar.gz flume-1.9.0 ## 4. 删除 Flume 安装包 [root@node01 Flume]# rm -rf apache-flume-1.9.0-bin.tar.gz ## 5. 复制Flume的环境配置文件，并修改Java目录 [root@node01 Flume]# cd flume-1.9.0/conf/ [root@node01 conf]# cp flume-env.sh.template flume-env.sh [root@node01 conf]# vim flume-env.sh ## 修改JAVA_HOME为自己的JDK安装目录即可 export JAVA_HOME=/opt/apps/jdk1.8.0_256 ## 6. 修改 /etc/profile 文件环境变量配置 [root@node01 conf]# vim /etc/profile #Flume 环境变量配置 export FLUME_HOME=/opt/apps/Flume/flume-1.9.0 export PATH=$PATH:$FLUME_HOME/bin ## 7. 使配置生效 [root@node01 conf]# source /etc/profile ## 9. 检查 Flume 配置是否成功 [root@node01 conf]# flume-ng version Flume 1.9.0 Source code repository: https://git-wip-us.apache.org/repos/asf/flume.git Revision: d4fcab4f501d41597bc616921329a4339f73585e Compiled by fszabo on Mon Dec 17 20:45:25 CET 2018 From source with checksum 35db629a3bda49d23e9b3690c80737f9 三、Flume实例 3.1 监控端口的数据流 需求： 使用Flume监控node01上的6666端口，并将数据结果输出到控制台上（当向node01上的6666端口发送数据时，node01就会检测到发来的数据，并将这个数据输出到控制台上） 步骤： 1.创建目录 [root@node01 conf]# cd /opt/apps/Flume/ [root@node01 Flume]# mkdir conf [root@node01 Flume]# cd conf/ 2.创建配置文件 [root@node01 conf]# vim flume-netcat.conf # 配置agent中的名字：a1表示agent的名字，r1表示输入的Source的名字 a1.sources = r1 a1.sinks = k1 a1.channels = c1 # 配置source：输入源类型，地址，端口 a1.sources.r1.type = netcat a1.sources.r1.bind = node01 a1.sources.r1.port = 6666 # 配置sink：输出目的地的类型【控制台日志】 a1.sinks.k1.type = logger # 配置channel：类型；Channel中可以存放1000个event，收集100个event就提交事务 a1.channels.c1.type = memory a1.channels.c1.capacity = 1000 a1.channels.c1.transactionCapacity = 100 # 建立关系 a1.sources.r1.channels = c1 a1.sinks.k1.channel = c1 3.启动Flume监控端口 flume-ng agent \\ --conf conf \\ --conf-file /opt/apps/Flume/flume-conf/flume-netcat.conf \\ --name a1 \\ -Dflume.root.logger==INFO,console 4.向端口中写入数据，需要先安装nc（netcat）(Ctrl+Z结束数据输入) [root@node02 ~]# yum -y install nc [root@node02 ~]# nc node01 6666 hahaha OK 1111 OK node01上监控的结果（Ctrl+Z结束检测） 2020-12-10 14:17:05,372 INFO sink.LoggerSink: Event: { headers:{} body: 68 61 68 61 68 61 hahaha } 2020-12-10 14:17:35,384 INFO sink.LoggerSink: Event: { headers:{} body: 31 31 31 31 1111 } 3.2 实时读取本地文件到HDFS 需求： 监控本地某一个文件，产生新的内容就添加到 HDFS，并且在控制台显示。其实就是多个输出 步骤 [root@node01 conf]# vim flume-exec.conf ## 添加以下配置信息 a2.sources = r2 a2.sinks = k2 a2.channels = c2 ## source a2.sources.r2.type = exec a2.sources.r2.command = tail -F /opt/data/tmp.log ## sink a2.sinks.k2.type = hdfs #1. 文件上传的HDFS路径 a2.sinks.k2.hdfs.path = hdfs://node01:9000/flume/%y-%m-%d/%H-%M #2. 文件的前后缀 ## 文件前缀 a2.sinks.k2.hdfs.filePrefix = tmp-log- ## 文件后缀 a2.sinks.k2.hdfs.fileSuffix = .log ## 文件正在写入时的前缀 a2.sinks.k2.hdfs.inUsePrefix = progress- ## 文件正在写入时的后缀 a2.sinks.k2.hdfs.inUseSuffix = .tmp #3. 时间戳问题 ##时间戳是否应四舍五入 a2.sinks.k2.hdfs.round = true ##四舍五入到小于当前时间的最高倍数 a2.sinks.k2.hdfs.roundValue = 1 ##四舍五入值的单位 a2.sinks.k2.hdfs.roundUnit = minute #4. 滚动产生新的文件 ##滚动当前文件之前要等待的秒数 a2.sinks.k2.hdfs.rollInterval = 30 ##触发滚动的文件大小，以字节为单位 a2.sinks.k2.hdfs.rollSize = 125829120 ##滚动之前写入文件的事件数 a2.sinks.k2.hdfs.rollCount = 30 a2.sinks.k2.hdfs.fileType = DataStream #hdfs.minBlockReplicas这个就是block块的数目 #是否启用本地时间 a2.sinks.k2.hdfs.useLocalTimeStamp = true ##Channel a2.channels.c2.type = memory a2.channels.c2.capacity = 1000 a2.channels.c2.transactionCapacity = 100 ##关联 a2.sources.r2.channels = c2 a2.sinks.k2.channel = c2 创建本地文件 [root@node01 ~]# cd /opt/ [root@node01 opt]# mkdir data [root@node01 opt]# vim /opt/data/tmp.log 启动Flume监控 flume-ng agent \\ --conf conf \\ --name a2 \\ --conf-file /opt/apps/Flume/flume-exec.conf 使用echo向tmp.log中写入数据 [root@node01 data]# echo 'hahahaha' >> /opt/data/tmp.log 如果出现如下错误，还是guava中的jar包错误。 修改/opt/apps/Flume/flume-1.9.0/lib/中的guava包为高版本即可。 java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument(ZLjava/lang/String;Ljava/lang/Object;)V at org.apache.hadoop.conf.Configuration.set(Configuration.java:1357) at org.apache.hadoop.conf.Configuration.set(Configuration.java:1338) at org.apache.hadoop.conf.Configuration.setBoolean(Configuration.java:1679) at org.apache.flume.sink.hdfs.BucketWriter.open(BucketWriter.java:221) at org.apache.flume.sink.hdfs.BucketWriter.append(BucketWriter.java:572) at org.apache.flume.sink.hdfs.HDFSEventSink.process(HDFSEventSink.java:412) at org.apache.flume.sink.DefaultSinkProcessor.process(DefaultSinkProcessor.java:67) at org.apache.flume.SinkRunner$PollingRunner.run(SinkRunner.java:145) at java.lang.Thread.run(Thread.java:748) Exception in thread \"SinkRunner-PollingRunner-DefaultSinkProcessor\" java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument(ZLjava/lang/String;Ljava/lang/Object;)V at org.apache.hadoop.conf.Configuration.set(Configuration.java:1357) at org.apache.hadoop.conf.Configuration.set(Configuration.java:1338) at org.apache.hadoop.conf.Configuration.setBoolean(Configuration.java:1679) at org.apache.flume.sink.hdfs.BucketWriter.open(BucketWriter.java:221) at org.apache.flume.sink.hdfs.BucketWriter.append(BucketWriter.java:572) at org.apache.flume.sink.hdfs.HDFSEventSink.process(HDFSEventSink.java:412) at org.apache.flume.sink.DefaultSinkProcessor.process(DefaultSinkProcessor.java:67) at org.apache.flume.SinkRunner$PollingRunner.run(SinkRunner.java:145) at java.lang.Thread.run(Thread.java:748) 3.3 监控目录输出到HDFS 需求: 监控目录中的文件情况，一旦有新文件产生就立即上传至 HDFS 步骤 创建配置文件 创建目录 启动Flume监控目录 将其他文件移动指定目录 1.创建配置文件 a3.sources = r3 a3.sinks = k3 a3.channels = c3 ## source a3.sources.r3.type = spooldir a3.sources.r3.spoolDir = /opt/test/flume/dir #a3.sources.r3.includePattern.log #a3.sources.r3.ignorePattern.tmp ## sink a3.sinks.k3.type = hdfs #文件上传的HDFS路径 a3.sinks.k3.hdfs.path = hdfs://node01:9000/flume/dir/%H-%M ##a3.sinks.k3.hdfs.path = hdfs://node01:9000/flume/dir/%y-%m-%d/%H-%M #文件的前缀 a3.sinks.k3.hdfs.filePrefix = dir- #是否按照时间滚动产生新的文件夹 a3.sinks.k3.hdfs.round = true #按照多长时间滚动一次 a3.sinks.k3.hdfs.roundValue = 1 #时间的单位 a3.sinks.k3.hdfs.roundUnit = hour #滚动产生新的文件 a3.sinks.k3.hdfs.rollInterval = 300000 a3.sinks.k3.hdfs.rollSize = 125829120 a3.sinks.k3.hdfs.rollSize = 125829120 #设置事件多少个之后产生新的文件 a3.sinks.k3.hdfs.rollCount = 52428800 a3.sinks.k3.hdfs.fileType = DataStream #hdfs.minBlockReplicas这个就是block块的数目 a3.sinks.k3.hdfs.useLocalTimeStamp = true ##Channel a3.channels.c3.type = memory a3.channels.c3.capacity = 1000 a3.channels.c3.transactionCapacity = 100 ##关联 a3.sources.r3.channels = c3 a3.sinks.k3.channel = c3 2.创建目录 [root@node01 opt]# mkdir -p test/flume/dir 3.启动flume监控目录 flume-ng agent \\ --conf conf \\ --name a3 \\ --conf-file /opt/apps/Flume/flume-dir.conf 3.4 单数据源多出口 1.创建配置文件 [root@master flume]# vim flume-more.conf a4.sources = r1 a4.sinks = k1 k2 a4.channels = c1 c2 ##source a4.sources.r1.type = exec a4.sources.r1.command = tail -F /opt/test/flume/date.log ##sink a4.sinks.k1.type = hdfs a4.sinks.k1.hdfs.path = hdfs://node01:9000/flume/more a4.sinks.k1.hdfs.roundUnit = hour a4.sinks.k1.hdfs.rollInterval = 0 a4.sinks.k1.hdfs.rollCount = 0 a4.sinks.k1.hdfs.fileType = DataStream a4.sinks.k2.type = file_roll a4.sinks.k2.sink.directory = /opt/test/flume/new ​##channel a4.channels.c1.type = memory a4.channels.c1.capacity = 1000 a4.channels.c1.transactionCapacity = 100 a4.channels.c2.type = memory a4.channels.c2.capacity = 1000 a4.channels.c2.transactionCapacity = 100 a4.sources.r1.channels = c1 c2 a4.sinks.k1.channel = c1 a4.sinks.k2.channel = c2 2.创建目录 [root@master ~]# mkdir -p /opt/test/flume/date.log [root@master ~]# mkdir -p /opt/test/flume/new 3.启动flume监控目录 flume-ng agent \\ --conf conf \\ --name a4 \\ --conf-file /opt/apps/Flume/flume-more.conf 3.5 多数据源单出口 1.创建配置文件 [root@master flume]# vim flume-one-more.conf ##sources a5.sources = r1 r2 a5.sinks = k1 a5.channels = c1 a5.sources.r1.type = exec a5.sources.r1.command = tail -F /opt/data/date1.log a5.sources.r2.type = exec a5.sources.r2.command = tail -F /opt/data/date2.log ##sinks a5.sinks.k1.type = hdfs a5.sinks.k1.hdfs.path = hdfs://node01:9000/flume/sum a5.sinks.k1.hdfs.roundUnit = hour a5.sinks.k1.hdfs.rollInterval = 0 a5.sinks.k1.hdfs.rollCount = 0 a5.sinks.k1.hdfs.fileType = DataStream ##channels a5.channels.c1.type = memory a5.channels.c1.capacity = 1000 a5.channels.c1.transactionCapacity = 100 a5.sources.r1.channels = c1 a5.sources.r2.channels = c1 a5.sinks.k1.channel = c1 2.创建目录 [root@node01 ~]# mkdir -p /opt/data/date1.log [root@node01 ~]# mkdir -p /opt/data/date2.log 3.启动flume监控目录 flume-ng agent \\ --conf conf \\ --name a5 \\ --conf-file /opt/apps/Flume/flume-one-more.conf 3.6 一个agent到多个agent输出 1.创建配置文件 ## Flume1 [root@master flume]# vim flume-more-flume1.conf a1.sources = r1 a1.sinks = k1 k2 a1.channels = c1 c2 a1.sources.r1.type = exec a1.sources.r1.command = tail -F /opt/test/flume/date.log a1.sinks.k1.type = avro a1.sinks.k1.hostname = master a1.sinks.k1.port = 5555 a1.sinks.k2.type = avro a1.sinks.k2.hostname = master a1.sinks.k2.port = 5556 a1.channels.c1.type = memory a1.channels.c1.capacity = 1000 a1.channels.c1.transactionCapacity = 100 a1.channels.c2.type = memory a1.channels.c2.capacity = 1000 a1.channels.c2.transactionCapacity = 100 ​ a1.sources.r1.channels = c1 c2 a1.sinks.k1.channel = c1 a1.sinks.k2.channel = c2 ​ ## Flume2 [root@master flume]# vim flume-more-flume2.conf a2.sources = r1 a2.sinks = k1 a2.channels = c1 a2.sources.r1.type = avro a2.sources.r1.bind = master a2.sources.r1.port = 5555 a2.sinks.k1.type = hdfs a2.sinks.k1.hdfs.path = hdfs://master:9000/flume/more-flume a2.sinks.k1.hdfs.roundUnit = hour a2.sinks.k1.hdfs.rollInterval = 0 a2.sinks.k1.hdfs.rollCount = 0 a2.sinks.k1.hdfs.fileType = DataStream a2.channels.c1.type = memory a2.channels.c1.capacity = 1000 a2.channels.c1.transactionCapacity = 100 a2.sources.r1.channels = c1 a2.sinks.k1.channel = c1 ## Flume3 [root@master flume]# vim flume-more-flume3.conf a3.sources = r1 a3.sinks = k2 a3.channels = c2 a3.sources.r1.type = avro a3.sources.r1.bind = master a3.sources.r1.port = 5556 a3.sinks.k2.type = file_roll a3.sinks.k2.sink.directory = /opt/test/flume/new1 a3.channels.c2.type = memory a3.channels.c2.capacity = 1000 a3.channels.c2.transactionCapacity = 100 a3.sources.r1.channels = c2 a3.sinks.k2.channel = c2 "},"8-Hive/1-Hive入门.html":{"url":"8-Hive/1-Hive入门.html","title":"4. Hive入门","keywords":"","body":"1.1 Hive 是什么 Hive是领英公司开发，是基于Hadoop的一个开源数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行，需要注意的是，Hive它并不是数据库。 数据仓库：数据仓库注重存储、查询数据（并不注重对数据的查删改等操作） 数据库：数据库注重管理数据，比如对数据的增删改查等操作。 Mysql\\Oracle:数据库管理软件。 Hive 提供了一系列的工具，可以用来进行数据的提取、转换和加载【ETL】，是一种可以存储、查询和分析存储在 Hadoop中的大规模数据的架构体系。 1.2 为什么要有Hive Hive 简化了 MapReduce 的开发难度，只要会 SQL，不需要去实现底层Map Reduce代码，就能快速的上手 Hive，通过简单的 SQL 语句就能实现复杂的 MapReduce 所能达到的功能。（通过简单的Sql语句，即可实现MapReduce大多数功能） 1.3 Hive的优点 简单容易上手操作接口采用类 SQL 语法，提供快速开发的能力。 学习成本低避免了去写MapReduce，减少开发人员的学习成本。 可扩展Hive 可以自由扩展集群规模，一般情况下不需要重启服务 延展性Hive支持用户自定义函数，用户可以根据自己的需求来实现自己的函数 容错性良好的容错性，即使节点出现问题 SQL 仍能够正常完成 1.4 Hive的缺点 Hive 的 HQL 表达能力有限迭代式算法无法表达，比如 pagerank 。数据挖掘方面，比如 k-means . Hive 的效率比较低Hive 自动生成的 MapReduce 作业，通常情况下不够智能化 Hive 调优比较困难，粒度较粗 Hive 可控性差 1.5 Hive与传统数据库的比较 项目 Hive 传统数据库 查询语言 HiveQL SQL 存储 HDFS【理论上无限存储】 存储有限，随着容量增加，计算速度急剧下降 执行引擎 依赖于 MR/Spark框架，无法进行良好的性能优化 可以选择更加有效的算法执行查询，以此提高执行效率 灵活性 元数据独立存储，数据存储在HDFS上，耦合度降低 数据用途单一，耦合度高 执行效率 在大数据情况下，执行效率远远高于传统数据库 在少量数据情况下，比较快 延迟性 高 低 数据加载模式 读时模式 写时模式 数据操作 数据覆盖追加 行级更新删除 索引 0.7.0版本后加入，索引比较简单 复杂索引 事务 支持，只能对数据库和表设置锁 完全支持，具备完善的事务机制 可靠性 借助于 HDFS 数据有备份 需要设置数据库的热备，以防止丢失 基本环境 应用场景 大规模数据分析查询 小规模数据的实时查询 费用 开源，免费 商业应用，收费较高"},"8-Hive/2-Hive环境配置.html":{"url":"8-Hive/2-Hive环境配置.html","title":"5. Hive环境配置","keywords":"","body":"Hive是基于Hadoop的一个数据仓库工具，因此Hive的安装前提必须是Hadoop能够正常运行。 2.1 Hive安装模式 根据元数据的位置，将Hive的安装分为三个模式：内嵌模式、独立模式、远程模式（最复杂） 1.1.1 Hive内嵌安装模式 不需要额外安装元数据库，采用Hive默认的Derby数据库，这种模式的缺点是只允许有一个 Hive 会话连接。 1.1.2 Hive独立安装模式 集群中一个节点即做服务端，同时也做客户端。在安装 Hive 的节点上安装一个 MySQL 服务端，同时将 hive.metastore.local 的值设置为 true，配置 MySQL 地址和用户名密码即可。 1.1.3 Hive远程安装模式（√） 将 Hive 服务端与元数据的存储地址分开，元数据直接存储在远程的数据库服务器上即可。 因此node01 安装 Hive 服务端，node02安装Hive客户端 ，node03 安装 MySQL，以此来实现 Hive 与元数据的解耦操作。 2.2所需软件合集 Mysql:官网下载地址 下载版本如下： Hive：官网下载地址 ​ 下载版本如下 2.3 安装Mysql 2.3.1 安装Mysql 下载Mysql，在其中一台节点上安装就行（这里选择在node03上安装Mysql） ## 1、先卸载node03上的数据库mariadb，不卸载会报错 [root@node03 ~]# rpm -qa | grep mariadb mariadb-libs-5.5.65-1.el7.x86_64 [root@node03 ~]# rpm -e --nodeps mariadb-libs-5.5.65-1.el7.x86_64 ## 2、安装 net-tools 工具，否则会报缺少依赖的错 [root@node03 ~]# yum -y install net-tools ## 3、安装 perl,否则会报缺少依赖的错误 [root@node03 ~]# yum -y install perl ## 4、上传Mysql压缩包到node03上 ## 创建一个新的文件夹用于存放安装包 [root@node03 ~]# mkdir /opt/apps/Mysql [root@node03 ~]# cd /opt/apps/ [root@node03 apps]# ls Hadoop Java Mysql ## 上传Mysql压缩包到node03的/opt/SoftWare/Mysql目录中 [root@node03 ~]# cd /opt/SoftWare/Mysql ## 安装上传下载软件 [root@node03 Mysql]# yum -y install lrzsz [root@node03 Mysql]# rz [root@node03 Mysql]# ls mysql-5.7.32-1.el7.x86_64.rpm-bundle.tar ## 5、解包（并非解压） [root@node03 Mysql]# tar -xvf mysql-5.7.28-1.el7.x86_64.rpm-bundle.tar mysql-community-client-5.7.32-1.el7.x86_64.rpm mysql-community-common-5.7.32-1.el7.x86_64.rpm mysql-community-devel-5.7.32-1.el7.x86_64.rpm mysql-community-embedded-5.7.32-1.el7.x86_64.rpm mysql-community-embedded-compat-5.7.32-1.el7.x86_64.rpm mysql-community-embedded-devel-5.7.32-1.el7.x86_64.rpm mysql-community-libs-5.7.32-1.el7.x86_64.rpm mysql-community-libs-compat-5.7.32-1.el7.x86_64.rpm mysql-community-server-5.7.32-1.el7.x86_64.rpm mysql-community-test-5.7.32-1.el7.x86_64.rpm ## 开始安装，安装的顺序不能乱 [root@node03 Mysql]# rpm -ivh mysql-community-common-5.7.32-1.el7.x86_64.rpm 警告：mysql-community-common-5.7.32-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY 准备中... ################################# [100%] 正在升级/安装... 1:mysql-community-common-5.7.32-1.e################################# [100%] [root@node03 Mysql]# rpm -ivh mysql-community-libs-5.7.32-1.el7.x86_64.rpm 警告：mysql-community-libs-5.7.32-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY 准备中... ################################# [100%] 正在升级/安装... 1:mysql-community-libs-5.7.32-1.el7################################# [100%] [root@node03 Mysql]# rpm -ivh mysql-community-libs-compat-5.7.32-1.el7.x86_64.rpm 警告：mysql-community-libs-compat-5.7.32-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY 准备中... ################################# [100%] 正在升级/安装... 1:mysql-community-libs-compat-5.7.3################################# [100%] [root@node03 Mysql]# rpm -ivh mysql-community-client-5.7.32-1.el7.x86_64.rpm 警告：mysql-community-client-5.7.32-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY 准备中... ################################# [100%] 正在升级/安装... 1:mysql-community-client-5.7.32-1.e################################# [100%] [root@node03 Mysql]# rpm -ivh mysql-community-server-5.7.32-1.el7.x86_64.rpm 警告：mysql-community-server-5.7.32-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY 准备中... ################################# [100%] 正在升级/安装... 1:mysql-community-server-5.7.32-1.e################################# [100%] 2.3.2 启动Mysql服务 ## 1、启动Mysql服务 [root@node03 Mysql]# systemctl start mysqld ## 2、查看Mysql状态 [root@node03 Mysql]# systemctl status mysqld mysqld.service - MySQL Server Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled) Active: active (running) since 六 2020-11-28 15:12:41 CST; 2min 0s ago Docs: man:mysqld(8) http://dev.mysql.com/doc/refman/en/using-systemd.html Process: 1394 ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid $MYSQLD_OPTS (code=exited, status=0/SUCCESS) Process: 1345 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS) Main PID: 1397 (mysqld) CGroup: /system.slice/mysqld.service └─1397 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid 11月 28 15:12:36 node03 systemd[1]: Starting MySQL Server... 11月 28 15:12:41 node03 systemd[1]: Started MySQL Server. ## 3、设置开机自启动 [root@node03 Mysql]# systemctl enable mysqld ## 4、删除安装包（节省空间） [root@node03 Mysql]# ls mysql-5.7.32-1.el7.x86_64.rpm-bundle.tar mysql-community-embedded-devel-5.7.32-1.el7.x86_64.rpm mysql-community-client-5.7.32-1.el7.x86_64.rpm mysql-community-libs-5.7.32-1.el7.x86_64.rpm mysql-community-common-5.7.32-1.el7.x86_64.rpm mysql-community-libs-compat-5.7.32-1.el7.x86_64.rpm mysql-community-devel-5.7.32-1.el7.x86_64.rpm mysql-community-server-5.7.32-1.el7.x86_64.rpm mysql-community-embedded-5.7.32-1.el7.x86_64.rpm mysql-community-test-5.7.32-1.el7.x86_64.rpm mysql-community-embedded-compat-5.7.32-1.el7.x86_64.rpm [root@node03 Mysql]# rm -rf mysql-* [root@node03 Mysql]# ls 2.3.3 修改Root密码 ## 1、 在日志文件中查看mysql的root用户默认密码 ## 如下，默认密码为root@localhost:后面的内容，即：4uNuB5DdiX+X [root@node03 Mysql]# grep 'temporary password' /var/log/mysqld.log 2020-11-28T07:12:38.953216Z 1 [Note] A temporary password is generated for root@localhost: 4uNuB5DdiX+X ## 2、取消密码检查策略s ## 修改/etc/my.cnf文件，在文件中添加以下内容以禁用密码策略 ## validate_password=off（必须手敲，不能拷贝，拷贝会报错） [root@node03 Mysql]# vim /etc/my.cnf ## 3、重启Mysql服务 [root@node03 Mysql]# systemctl restart mysqld ## 4、进入mysql，并输入4uNuB5DdiX+X密码 [root@node03 Mysql]# mysql -uroot -p Enter password: 4uNuB5DdiX+X ## 5、修改密码为123456 mysql> ALTER USER 'root'@'localhost' IDENTIFIED BY '123456'; Query OK, 0 rows affected (0.01 sec) ## 6、退出mysql的命令 mysql> exit 2.3.3.1 为什么要禁用密码策略 mysql中的密码策略规定，密码不能太过于简单；必须要有大小写；长度必须符合规定等限制。如果没有取消密码策略检查，则在mysql5.7中必然会报错，让你修改密码。 ## 密码策略示意表 mysql> show variables like '%password%'; +----------------------------------------+-----------------+ | Variable_name | Value | +----------------------------------------+-----------------+ | default_password_lifetime | 0 | | disconnect_on_expired_password | ON | | log_builtin_as_identified_by_password | OFF | | mysql_native_password_proxy_users | OFF | | old_passwords | 0 | | report_password | | | sha256_password_auto_generate_rsa_keys | ON | | sha256_password_private_key_path | private_key.pem | | sha256_password_proxy_users | OFF | | sha256_password_public_key_path | public_key.pem | +----------------------------------------+-----------------+ 10 rows in set (0.01 sec) 2.3.4 修改数据库编码为UTF-8 ## 在/etc/my.cnf文件中的添加以下内容 character_set_server=utf8 init_connect='SET NAMES utf8' 2.3.5 添加Root用户的登录权限 默认只允许 root 帐户在本地登录，如果要在其它机器上连接 MySQL，必须修改 root 允许远程连接，或者添加一个允许远程连接的帐户 ## 1. 进入mysql [root@master SoftWare]# mysql -uroot -p123456 ## 2. 修改root的远程访问权限 ## root代表用户名， %代表任何主机都可以访问， 123456为root访问的密码 mysql> GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION; ## 3. flush privileges 刷新MySQL的系统权限，使其即时生效，否则就重启服务器 mysql> FLUSH PRIVILEGES; ## 4. 退出 mysql> exit; 2.4 安装Hive 2.4.1 上传解压Hive压缩包配置环境变量 在node01和node02上都要执行一遍。 ## 1、创建新的目录用于存放Hive安装包 [root@node01 ~]# mkdir /opt/apps/Hive [root@node01 ~]# cd /opt/apps [root@node01 apps]# ls Hadoop3.1.4 Hive JDK1.8 ## 2、上传Hive安装包到Hive文件中 [root@node01 Hive]# rz ## 3、解压Hive安装包 [root@node01 Hive]# ls apache-hive-3.1.2-bin-hadoop-3.1.4.tar.gz [root@node01 Hive]# tar -zxf apache-hive-3.1.2-bin-hadoop-3.1.4.tar.gz ## 4、重命名文件，方便使用 [root@node01 Hive]# mv apache-hive-3.1.2-bin hive-3.1.2 [root@node01 Hive]# ls apache-hive-3.1.2-bin-hadoop-3.1.4.tar.gz hive-3.1.2 ## 5、删除Hive安装包 [root@node01 Hive]# rm -rf apache-hive-3.1.2-bin-hadoop-3.1.4.tar.gz [root@node01 Hive]# ls hive-3.1.2 ## 6、配置环境变量 [root@node01 Hive]# cd hive-3.1.2/ [root@node01 hive-3.1.2]# pwd /opt/apps/Hive/hive-3.1.2 ## 编辑 profile 文件，添加以下环境变量内容 [root@node01 hive-2.3.6]# vim /etc/profile ## Hive 环境变量 ##Hive export HIVE_HOME=/opt/apps/Hive/hive-3.1.2 export PATH=$PATH:$HIVE_HOME/bin 2.4.2 修改相关配置文件 2.4.2.1 Server端配置（node01） ## 新建一个conf文件，在里面创建hive-site.xml配置文件，并添加一下内容 [root@node01 hive-3.1.2]# vim conf/hive-site.xml javax.jdo.option.ConnectionURL jdbc:mysql://node03:3306/metastore?createDatabaseIfNotExist=true&amp;useSSL=false javax.jdo.option.ConnectionDriverName com.mysql.jdbc.Driver javax.jdo.option.ConnectionUserName root javax.jdo.option.ConnectionPassword 123456 hive.exec.local.scratchdir /hive/tmp hive.metastore.warehouse.dir /hive/warehouse hive.querylog.location /tmp/hive/logs hive.server2.logging.operation.log.location /tmp/hive/logs hive.downloaded.resources.dir /tmp/hive/resources beeline.hs2.connection.user root beeline.hs2.connection.password 123456 2.4.2.2 Client端配置（node02） ## 新建一个conf文件，在里面创建hive-site.xml配置文件，并添加一下内容 [root@node02 hive-2.3.6]# vi conf/hive-site.xml hive.metastore.local false hive.exec.local.scratchdir /hive/tmp hive.metastore.warehouse.dir /hive/warehouse hive.metastore.uris thrift://node01:9083 hive.querylog.location /tmp/hive/logs hive.server2.logging.operation.log.location /tmp/hive/logs hive.downloaded.resources.dir /tmp/hive/resources hive.cli.print.current.db true hive.cli.print.header true 2.4.3 添加Mysql驱动 服务端（node01）与客户端（node02）都需要将驱动jar包上传至lib目录下 ## 上传驱动jar包到lib目录下 [root@node02 hive-3.1.2]# cd lib/ [root@node02 lib]# rz -E rz waiting to receive. [root@node02 lib]# ls mysql-* mysql-connector-java-5.1.49.jar mysql-metadata-storage-0.12.0.jar 2.4.4 修改日志文件 Hive 的 log 默认存放在 /tmp/root/hive.log目录下（当前用户名下），可以对其进行修改，两台节点均需要配置 ## 重新复制一份log4j配置文件，从Hive 2.1.0 开始，使用的是log4j2。 [root@node01 hive-3.1.2]# cp conf/hive-log4j2.properties.template conf/hive-log4j2.properties [root@node01 hive-3.1.2]# vi conf/hive-log4j2.properties ## 修改下面的内容 property.hive.log.dir = /opt/apps/hive-3.1.2/logs 2.4.5 格式化Hive 先修改Hadoop的相关配置，否则会报错。 ## 1. 修改 Hadoop 中的 core-site.xml 配置文件 [root@node01 Hive]# vi /opt/SoftWare/Hadoop/hadoop-2.7.7/etc/hadoop/core-site.xml ## 添加以下内容 hadoop.proxyuser.root.groups root Allow the superuser oozie to impersonate any members of the group group1 and group2 hadoop.proxyuser.root.hosts * The superuser can connect only from host1 and host2 to impersonate a user 在node01上格式化Hive [root@node01 hive-2.3.6]# schematool -initSchema -dbType mysql SLF4J: Class path contains multiple SLF4J bindings. SLF4J: Found binding in [jar:file:/opt/SoftWare/Hive/hive-2.3.6/lib/log4j-slf4j-impl-2.6.2.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: Found binding in [jar:file:/opt/SoftWare/Hadoop/hadoop-2.7.7/share/hadoop/common/lib/slf4j-log4j12-1.7.10.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation. SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory] Metastore connection URL: jdbc:mysql://node03:3306/metastore?createDatabaseIfNotExist=true&useSSL=false Metastore Connection Driver : com.mysql.jdbc.Driver Metastore connection User: root Starting metastore schema initialization to 2.3.0 Initialization script hive-schema-2.3.0.mysql.sql Initialization script completed schemaTool completed 2.4.6 启动Hive 两种方式区别 方式一：只要是支持Jdbc的，都能连接（支持的是Jdbc协议） 方式二：必须使用hive客户端才能连接（支持的是thrift协议） 先启动Hadoop集群 启动方法1 ## 1. 启动服务端 将启动时的结果输出到null中（扔掉） &表示后台运行，在前台不显示 [root@node01 hive-3.1.2]# hiveserver2 > /dev/null 2>&1 & ## 2. 查询服务端进程 ID [root@node01 hive-3.1.2]# ps -aux| grep hiveserver2 root 13931 1.0 11.1 2344932 431620 pts/0 Sl 00:10 0:16 ## 3. 停止服务端【这里暂时不操作，关闭 Hive 的时候操作】 [root@node01 hive-3.1.2]# kill -9 13931 ##4.先关闭Hadoop集群的安全模式 [root@node01 ~]# hdfs dfsadmin -safemode leave //集群退出安全模式 Safe mode is OFF ## 5. 启动客户端 [root@node02 hive-3.1.2]# beeline -u jdbc:hive2://node01:10000 -n root -p 123456 0: jdbc:hive2://node01:10000> show tables; +-----------+ | tab_name | +-----------+ | +-----------+ 1 row selected (0.616 seconds) 启动方法2 ## 1. 启动服务端 [root@node01 hive-2.3.6]# hive --service metastore > /dev/null 2>&1 & ## 2. 查看服务端进程 ID [root@node01 hive-2.3.6]# ps -aux| grep metastore root 14342 5.5 8.9 2297776 345508 pts/0 Sl 01:18 0:09 ## 3. 杀死服务进程 [root@node01 hive-2.3.6]# kill -9 14342 ## 4. 启动客户端 [root@node02 hive-2.3.6]# hive hive (default)> show tables; OK tab_name student2 Time taken: 0.755 seconds, Fetched: 1 row(s) hive (default)> exit; 启动方法3 ## 1. 启动服务端 [root@node01 hive-2.3.6]# hive --service metastore > /dev/null 2>&1 & ## 2. 查看服务端进程 ID [root@node01 hive-2.3.6]# ps -aux| grep metastore root 14342 5.5 8.9 2297776 345508 pts/0 Sl 01:18 0:09 ## 3. 杀死服务进程 [root@node01 hive-2.3.6]# kill -9 14342 ## 4. 启动客户端（用的比较多的方法，因为可以写脚本） [root@node02 hive-2.3.6]# hive -e \"show tables;\" which: no hbase in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/SoftWare/Java/jdk1.8.0_212/bin:/opt/SoftWare/Java/jdk1.8.0_212/jre/bin:/opt/SoftWare/Hadoop/hadoop-2.7.7/bin:/opt/SoftWare/Hadoop/hadoop-2.7.7/sbin:/root/bin:/opt/SoftWare/Java/jdk1.8.0_212/bin:/opt/SoftWare/Java/jdk1.8.0_212/jre/bin:/opt/SoftWare/Hadoop/hadoop-2.7.7/bin:/opt/SoftWare/Hadoop/hadoop-2.7.7/sbin:/opt/SoftWare/Hive/hive-2.3.6/bin) SLF4J: Class path contains multiple SLF4J bindings. SLF4J: Found binding in [jar:file:/opt/SoftWare/Hive/hive-2.3.6/lib/log4j-slf4j-impl-2.6.2.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: Found binding in [jar:file:/opt/SoftWare/Hadoop/hadoop-2.7.7/share/hadoop/common/lib/slf4j-log4j12-1.7.10.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation. SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory] Logging initialized using configuration in file:/opt/SoftWare/Hive/hive-2.3.6/conf/hive-log4j2.properties Async: true OK tab_name student2 Time taken: 1.274 seconds, Fetched: 1 row(s) "},"8-Hive/3-Hive基本命令.html":{"url":"8-Hive/3-Hive基本命令.html","title":"6. Hive基本命令","keywords":"","body":"3.1 Beeline命令 Beeline是 Hive 0.11版本引入的新命令行客户端工具,基于SQLLine CLI的JDBC客户端。 Beeline支持内嵌模式(embedded mode)和远程模式(remote mode)。在嵌入式模式下，运行嵌入式的Hive(类似Hive CLI)，而远程模式可以通过Thrift连接到独立的HiveServer2进程上。从Hive 0.14版本开始，Beeline使用HiveServer2工作时，它也会从HiveServer2输出日志信息到STDERR。 Hive的三种安装方式 内嵌模式：不需要额外安装元数据库，采用的是Hive默认的Derby数据库，但这种模式有极大的缺陷就在于只允许一个 Hive 会话连接。 独立模式：在安装 Hive 的节点上安装一个 MySQL 服务端，并且将 hive.metastore.local 设置为 true 远程模式：将 Hive 服务端与元数据的存储地址分开，元数据直接存储在远程的数据库服务器上即可。因此这里我们采用的是 node01 安装 Hive 服务端，而node03 安装 MySQL，以此来实现 Hive 与元数据的解耦操作。 Beeline和其他工具有一些不同，执行查询都是正常的SQL输入。 create databases;【创建数据库】 select * from table_name;【查询表】 但是如果是一些管理的命令，比如进行连接，中断，退出，执行Beeline命令需要带上“!”，不需要终止符。 !connect url 【连接不同的Hive2服务器】 !exit 【退出shell】 !help 【显示全部命令列表】 !verbose 【显示查询追加的明细】 3.2 hive -e 不用进入交互窗口就能执行数据库相关命令 [root@node02 ~]# hive -e \"show databases\"; ## 以下是结果 which: no hbase in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/apps/jdk1.8.0_261/bin:/opt/apps/jdk1.8.0_261/jre/bin:/opt/apps/hadoop-3.1.4/bin:/opt/apps/hadoop-3.1.4/sbin:/opt/apps/hive-3.1.2/bin:/root/bin) SLF4J: Class path contains multiple SLF4J bindings. SLF4J: Found binding in [jar:file:/opt/apps/hive-3.1.2/lib/log4j-slf4j-impl-2.10.0.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: Found binding in [jar:file:/opt/apps/hadoop-3.1.4/share/hadoop/common/lib/slf4j-log4j12-1.7.25.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation. SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory] Hive Session ID = e308f3e6-6cac-4e85-b4a1-2f53376dc53c Logging initialized using configuration in file:/opt/apps/hive-3.1.2/conf/hive-log4j2.properties Async: true Hive Session ID = 2b23427f-3062-4ad0-a6e4-5c51159af89d OK database_name default student teaceher Time taken: 3.745 seconds, Fetched: 3 row(s) 3.3 hive -f 不用进入交互窗口，用vim或vi创建一个文件，写入一些sql命令，通过hive -f 即可执行。 [root@node02 apps]# vim hive.sql ## 文件中的内容 show databases; ## 以下是执行结果 [root@node02 apps]# hive -f hive.sql which: no hbase in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/apps/jdk1.8.0_261/bin:/opt/apps/jdk1.8.0_261/jre/bin:/opt/apps/hadoop-3.1.4/bin:/opt/apps/hadoop-3.1.4/sbin:/opt/apps/hive-3.1.2/bin:/root/bin) SLF4J: Class path contains multiple SLF4J bindings. SLF4J: Found binding in [jar:file:/opt/apps/hive-3.1.2/lib/log4j-slf4j-impl-2.10.0.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: Found binding in [jar:file:/opt/apps/hadoop-3.1.4/share/hadoop/common/lib/slf4j-log4j12-1.7.25.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation. SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory] Hive Session ID = 1bf5a42e-f5e7-4bd4-87cb-a5d8aa719c62 Logging initialized using configuration in file:/opt/apps/hive-3.1.2/conf/hive-log4j2.properties Async: true Hive Session ID = 1fe787c1-bac7-42bf-9cb6-2254f95fab17 OK database_name default student teaceher Time taken: 3.399 seconds, Fetched: 3 row(s) 3.4 其他命令 退出hive客户端命令（非beeline模式下） hive(default)>exit; hive(default)>quit; 退出hive客户端命令（beeline模式下） hive(default)>!quit; 通过客户端用命令行来查看HDFS的文件系统 hive (default)> dfs -ls /; Found 4 items drwxr-xr-x - root supergroup 0 2020-12-06 20:09 /data drwxr-xr-x - root supergroup 0 2020-12-02 12:53 /hive drwxr-xr-x - root supergroup 0 2020-11-03 16:42 /system drwxrwxrwx - root supergroup 0 2020-11-28 19:04 /tmp 查看本地的文件系统（即虚拟机上的文件系统） hive (default)> ! ls /opt/apps; data hadoop-3.1.4 hive-3.1.2 hive.sql jdk1.8.0_261 查看历史记录(即hive客户端的操作记录) ## 必须进入主目录才行 [root@node02 apps]# cat .hivehistory cat: .hivehistory: 没有那个文件或目录 [root@node02 apps]# cd ~ [root@node02 ~]# cat .hivehistory exit; show tables; exit; 3.5 HQL HiveQL（简称HQL）是支持的类似的查询语言，HQL大体分为DDL、DDL、DML、UDF 四种类型。 DDL: （database definition language） 数据定义语言 引起的是结构上变化，不会影响数据 create drop alter DML: DataManipulationLanguage 数据操作语言 不会引起结构上的变化 引起的是数据的变化 update DQL: 数据查询语言 不会引起结构上的变化，也不会引起数据的变化，select where DDL可以创建数据库、创建表、进行数据库和表的删除；DML可以进行数据的添加、查询；UDF还支持用户自定义查询函数。 3.6 Hive之DDL （Database Definition Language） 数据定义语言 引起的是结构上变化，不会影响数据 create drop alter。 DDL主要负责的是数据库的创建、查看、修改、删除、表的创建、修改。（主要侧重于对数据库、表的操作） 内部表： 由Hive进行管理，创建内部表时，把内部表对应的数据会一并复制到对应的HDFS上（数据仓库）HIve所对应的目录下 外部表 不由Hive管理，在创建外部表时，同时指定一个指向实际数据的路径作为表的信息一同储存在映射表中，用户可以通过查询表中这一数据知道该映射结构表的实际数据在什么位置。创建外部表时，仅记录数据所在的路径，不会对数据位置进行任何改变 内部表和外部表的区别： 内部表和外部表在结构上没有任何区别，但在删除数据时，内部表可以用Hive进行删除，同时会把数据仓库上（HDFS上）对应的数据删掉。外部表则只是删除数据库中的数据信息，但不会真正的数据。 创建外部表时，要加一个External 分区表： 分区表实际上就是对应一个 HDFS 文件系统上的独立的文件夹，该文件夹下是该分区所有的数据文件。Hive 中的分区就是分目录，把一个大的数据集根据业务需要分割成小的数据集。在查询时通过 WHERE 子句中的表达式选择查询所需要的指定的分区，这样的查询效率会提高很多。（例如，将数科所有班级存入一张大表中（其实是个目录），为了利于管理，看起来更加系统，将这个大表进行分区，将数科191、数科192、数科201、数科202划分为四个区，辅导员需要哪个班级的数据时直接调对应分区的表即可。） 数据库操作 3.6.1 创建数据库 创建数据库的SQL格式 CREATE (DATABASE|SCHEMA) [IF NOT EXISTS] database_name [COMMENT database_comment] [LOCATION hdfs_path] [WITH DBPROPERTIES (property_name=property_value, ...)]; -------------------------------------------------------------------------------------- --(DATABASE|SCHEMA)：必须有的参数 -- [IF NOT EXISTS]：可有可无（判断数据库是否已经存在） -- [COMMENT database_comment]：可有可无，对数据库加以说明 -- [LOCATION hdfs_path]：指明数据库创建的路径 --if not exists 用于判断数据库是否已经存在，不存在就创建（可有可无），COMMENT用于对数据库做介绍（可有可无） create database if not exists books COMMENT \"第一个数据库\"; --什么也不加 create database books; --指定创建位置 create database books location \"/school\"; 3.6.2 查看数据库 --查看数据库 show databases; --过滤显示数据库 show databases like \"student\"; --显示数据库的基本信息 desc database student; OK db_name comment location owner_name owner_type parameters student hdfs://node01:9000/hive/warehouse/student.db root USER Time taken: 0.185 seconds, Fetched: 1 row(s) --显示数据库的详细信息 desc database extended student; OK db_name comment location owner_name owner_type parameters student hdfs://node01:9000/hive/warehouse/student.db root USER Time taken: 0.108 seconds, Fetched: 1 row(s) 3.6.3 修改数据库 # 修改数据库的属性 ALTER (DATABASE|SCHEMA) database_name SET DBPROPERTIES (property_name=property_value, ...); -- (注意: 在 Hive 0.14.0 增加了 SCHEMA 选项) # 修改数据库的拥有者和角色 ALTER (DATABASE|SCHEMA) database_name SET OWNER [USER|ROLE] user_or_role; -- (注意: Hive 0.13.0 以上版本可用;在 Hive 0.14.0 增加了 SCHEMA 选项) # 修改数据库的存储路径 ALTER (DATABASE|SCHEMA) database_name SET LOCATION hdfs_path; -- (注意: Hive 2.2.1, 2.4.0以及以上版本可用) 3.6.4 删除数据库 --删除空数据库 drop database books; --如果存在的话删除空数据库 drop database if exists books; --强制删除数据库 drop database books cascade; 表操作 3.6.3 创建内部表 create table if not exists studen( stuid int, --学生学号 stuname string, --学生姓名 stuage int --学生年龄 ) -- 每行字段以 \\t分割 row format delimited fields terminated by '\\t' -- 根据查询结果创建表：有数据 create table if not exists student2 as select * from student; create table if not exists student4 as select count(*) from teacher1; --根据已经存在的表创建表（类似复制一张表） create table if not exists student3 like student; OK student3.sno student3.sname student3.sage student3.ssex Time taken: 0.773 seconds 加载数据到表中 load data local inpath '/opt/apps/data/teacher.txt' into table teacher; 查看表的类型 desc formatted student3; 3.6.4 创建外部表 外部表的创建与内部表没什么区别，只不过是在创建时要加上一个external关键字即可。 create external table tea( stuid int, stuname string, stuage int ) row format delimited fields terminated by '\\t'; 加载数据到表中 load data local inpath '/opt/apps/data/teacher.txt' into table teacher; 查看数据 select * from ext_stu; 查询表的类型 desc formatted ext_stu; 删除表 drop table tea; drop table student3; 3.6.5 创建分区表 创建分区表 create table student(id int,name string ) partitioned by(day string comment 'study') row format delimited fields terminated by '\\t'; 上传数据到分区中 load data local inpath '/opt/apps/data/student.txt' into table student partition (day='01'); 增加分区 --增加单分区 alter table student add partition(day='05'); --增加多分区 alter table student add partition(day='06') partition(day='07'); 删除分区 alter table student4 drop partition (day='183'); 查看分区结构 desc formatted student; study.db为数据库；student为表（其实再HDFS文件系统中是一个目录）；表里面的day05、day06、day07、day08为分区表。 创建二级分区 create table teacher(id int,name string) partitioned by(day string ,month string ) row format delimited fields terminated by '\\t'; 分区数据关联的三种方式 -- 方式一：先hadoop上传，后修复 dfs -put /opt/data/student.txt /hive/warehouse/student.db/student/day=04; -- 查看 select * from student; -- 执行修复 msck repair table student; -- 查看 select * from student; -- 方式二：先hadoop上传，后修改 dfs -mkdir /hive/warehouse/study.db/student/day=06; dfs -put /opt/data/teacher /hive/warehouse/study.db/student/day=06; alter table student add partition(day='06'); -- 方式三：先上传，后加载 dfs -mkdir /hive/warehouse/study.db/student/day=07; load data local inpath '/opt/data/teacher.txt' into table student partition(day='07'); 3.6.6 修改表 表的重命名 alter table student rename to student6; 添加列 alter table student6 add columns(new string); 更改列：将某一列更改 alter table student6 change column new bb string; 替换所有列：后面跟的是新的列名 alter table student6 replace columns(ids int,names string,newb string); 修改内部表 student2 为外部表 alter table student2 set tblproperties('EXTERNAL'='TRUE'); 3.7 Hive之DML Hive 数据真正存放在 Hadoop 之上，因此最简单的数据导入方式就是将数据上传至 HDFS 相应目录即可，但是此操作会非常不方便，因此 Hive 为我们提供了以下数据加载的方式。 DML负责数据的导入、导出、更新、删除等操作（主要负责对数据的操作）。 3.7.1 数据导入 Hive的数据是存放在Hadoop之上的，因此Hive在处理数据时需要将数据上传到HDFS中去。比如创建内部表时，需要将数据复制到HDFS上指定的目录中去。 Hive提供以下五种数据上传到HDFS上的方法，分别是：Load模式、Import模式、Insert模式、as select模式、Location模式 3.7.1.1 导入数据（Load模式） 创建普通数据表 create table test(id int,name string) row format delimited fields terminated by '\\t'; 从本地(Linux)上传数据 load data local inpath '/opt/data/student' into table test; 从本上传数据并覆盖原有 load data local inpath '/opt/data/student' overwrite into table test; 创建分区表 create table test02(id int,name string) partitioned by (num string) row format delimited fields terminated by '\\t'; 向分区表中加载数据 load data local inpath '/opt/apps/data/student.txt' into table test02 partition (num='01'); 向分区表中加载数据,但是不指定分区(可以上传成功,但会报错) load data local inpath '/opt/apps/data/student.txt' into table test02; ## 错误如下 Query ID = root_20201218174108_6408e79a-4ec5-4aa1-9d5e-52558c638b98 Total jobs = 3 Launching Job 1 out of 3 Number of reduce tasks not specified. Estimated from input data size: 1 In order to change the average load for a reducer (in bytes): set hive.exec.reducers.bytes.per.reducer= In order to limit the maximum number of reducers: set hive.exec.reducers.max= In order to set a constant number of reducers: set mapreduce.job.reduces= Starting Job = job_1608280545793_0001, Tracking URL = http://node02:8088/proxy/application_1608280545793_0001/ Kill Command = /opt/apps/hadoop-3.1.4/bin/mapred job -kill job_1608280545793_0001 Hadoop job information for Stage-1: number of mappers: 0; number of reducers: 0 2020-12-18 17:41:19,840 Stage-1 map = 0%, reduce = 0% Ended Job = job_1608280545793_0001 with errors Error during job, obtaining debugging information... FAILED: Execution Error, return code 2 from org.apache.hadoop.hive.ql.exec.mr.MapRedTask MapReduce Jobs Launched: Stage-Stage-1: HDFS Read: 0 HDFS Write: 0 FAIL Total MapReduce CPU Time Spent: 0 msec 3.7.2 导入数据(insert模式) 也可以使用 insert 子句将查询结果插入表中 (这种插入方法只能一条一条的插入)。 创建分区表 create table test03(id int ,name string) partitioned by(age int) row format delimited fields terminated by '\\t'; 向分区表中加载数据 insert into table test03 partition(age=1) values(1001,'zhangsan'),(1002,'lisi'); "},"11-Scala/1-Scala.html":{"url":"11-Scala/1-Scala.html","title":"7. Scala","keywords":"","body":"Scala基础知识 1.1 什么是Scala Scala是一门多范式的编程语言，一种类似java的编程语言 ，设计初衷是实现可伸缩的语言、并集成面向对象编程和函数式编程的各种特性。 函数式编程更适合用于Map/Reduce和大数据计算，比java更适合用于大数据计算。 Scala作者是JVM的开发者之一，它能运行在java虚拟机之上，并兼容现有的java程序，他开发Scala的目的即解决编写Java时的繁琐的规范。 Spark、Flink等都是采用Scala开发和编写的，所以学好Scala是学好大数据的关键。 Scala官网：点我进入 1.2 Scala特点 Scala是一种有趣的语言。它一方面吸收继承了多种语言中的优秀特性，一 方面又没有拋弃Java这个强大的平台，它运行在Java虚拟机(Java Virtual Machine)之上，轻松实现和丰富的Java类库互联互通它既支持面向对象的编程方式，又支持函数式编程。它写出的程序像动态语言一样简洁，但事实上它确是严格意义上的静态语言。 静态语言:需要先编译再执行，比如java、C++ 动态语言:不需要经过编译直接来运行，比如Html、JS。 Scala有以下四个特点： 即包含面向对象，又包含函数式编程 属于静态类型 可扩展性 并发性 1.3 Scala函数式编程 纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。 函数式编程的特点： 函数是一等公民 以表达式为中心 无副作用 不修改状态 引用透明 函数式编程优势： 代码简洁，开发速度快 接近自然语言，易理解 易于代码管理 适合并发编程 适用于热升级 1.4 Scala的优点 优雅:这是框架设计师第一个要考虑的问题，框架的用户是应用开发程序员，API是否优雅直接影响用户体验。 速度快: Scala语言表达能力强，一行代码抵得上Java多行，开发速度快 Scala是静态编译的;，所以和JRuby, Groovy比起来速度会快很多(体验度比java等其他语言好)。 能融合到Hadoop生态圈: Hadoop现在 是大数据事实标准，Spark并不是要取代Hadoop，而是要完善Hadoop生态。JVM语言 大部分可能会想到Java，但Java做出来的API太丑，或者想实现-一个优雅的API太费劲。 1.5 JDK\\Scala的安装及环境配置 因为Scala是运行在JVM之上 , 因此需要先安装JDK1.8 并且配置java环境变量 ,最后安装和配置Scala SDK 1.5.1 JDK1.8安装 双击JDK1.8安装包 ,开始安装 尽量放到C盘以外的盘 ,修改好后点击确定. 等待安装成功. 更改java安装位置 修改完成之后点击下一步,等待安装完成即可. 1.5.2 环境变量配置 打开文件管理器 , 找到此电脑 , 鼠标右击 , 选择属性. 点击最左侧的高级系统设置 , 随后点击环境变量. 在系统变量中点击新建 , 输入如下变量. 随后在系统变量中找到Path , 选择后点击编辑. 在Path中添加以下内容 java环境变量配置完成 , 使用命令Java -version检验环境变量是否配置成功 1.5.3 Scala下载 到Scala官网下载安装包 , 选择所有版本. 找到Scala2.11.8版本 , 点击进去. 如下图 , 如果是Linux和Windows下载这两个版本就行. 如果是Windows系统,双击下载好的.msi文件即可安装,安装步骤较为简单 , 傻瓜式操作即可. 1.5.4 Scala环境变量配置 Scala的环境变量配置与JDK类似 , 与上图中JDK一样,先打开环境变量设置窗口 , 将变量值设置为自己Scala的安装路径 找到Path并选择 , 点击编辑. 添加一行如下图的内容即可. 最后测试Scala环境变量是否配置完成 至此 , JDK与Scala环境变量全部配置完成! Scala简单代码 选择IDE作为开发Scala程序的工具 2.1 Scala编写的HelloWord 第一个Scala编写的HelloWord程序代码如下: object HelloWord{ def main(Args:Array[String]):Unit={ println(\"HelloWorld\") } } 2.2 Scala解释器 使用Win+R命令打开终端，在终端中输入Scala，终端可以自动解释所输入的代码(前提是先配置环境变量) Scala解释器读到一个表达式，对它进行求值，将它打印出来，接着再继续读下一一个表达式。这个过程被称做读取--求值一打印-循环，即: REPL。 从技术上讲，scala程序并不是一个解释器。实际发生的是，你输入的内容被快速地编译成字节码，然后这段字节码交由Java虛拟机执行。正因为如此，大多数scala程序员更倾向于将它称做“REPL” `scala scala>\" Hello' resl: String = Hello scala> 1+2 res5: Int = 3 scala> \"Hello\". filter(line=>(line!=' I')) res2: String = Heo` 2.3 Scala变量 字段/变量的定义Scala中使用var/val 变量/不变量名称:类型的方式进行定义，例如: var index1 : Int=1 val index2 : Int = 1 其中var与va1的区别在于，var是变量，以后的值还可以改变，va1的值只能在声明的时候赋值，但是val不是 常量，只能说是不变量或只读变量。 类型推断: var index1 = 1 val index2 = 1 类型推断(type inference) 的能力，它能让scala自动理解你省略了的类型。这里，你用int字面量初始化 index1,因此scala推断index1的类型是Int。对于可以由Scala解释器(或编译器)自动推断类型的情况，就没有必 要非得写出类型标注不可。 其实根据函数式编程思想中，var变量是个不好的存在，Scala中 推荐大家尽可能的采用val的不变量， 主要原因是: vaI的不可变有助于理清头绪，但是相对的会付出一部分的性能代价。 另外一点就是如果使用var，可能会担心值被错误的更改。 使用val而不是var的第二点好处是他能更好地支持等效推论 2.4 Scala的数据类型 scala拥有和java-样的数据类型，和java的数据类型的内存布局完全一致$ 精度也完全一致。下面表格中是scala支持的数据类型: 2.5 Scala数学运算 Scala里，可以舍弃方法调用的空括号。例外就是如果方法带有副作用就加上括号，如println(),不过如果方法没有副作用就可以去掉括号，如String.上调用的toLowerCase，你可以通过中缀操作符，加号(+)，减号(-)，乘号(*)，除号(/)和余数(%)，在任何数类型上调用数学方法，scala中的基础运算与java-致。 2.6 Scala表达式 Scala中的任何表达式都具有返回值，Scala中的Unit（）与java中的void（）相同，代表没有返回值。 2.6.1 什么是表达式 一个具有执行结果的代码块，结果是具体的值或没有值（） 2.6.1 表达式与语句的区别 表达式有返回值，语句被执行。表达式一般是一个语句块，执行后返回一个值。 不使用return语句，最后一个表达式即是返回值。 2.7Scala-if循环表达式 if/else表达式有值，这个值就是跟在if或者else之后的表达式的值。每一个表达式都有一个类型；条件表达式有值；混合型表达式，结果是Any或AnyVal；Scala中没有switch语句 单分支 基本语法: if (条件表达式) {执行代码块} 说明:当条件表达式为ture时，就会执行{ }的代码。 双分支 基本语法: if (条件表达式) {执行代码块1 } else {执行代码块2 } 说明:当条件表达式成立，即执行代码块1，否则执行代码块2。 多分支 基本语法: if (条件表达式1) {执行代码块1} else if (条件表达式2) {执行代码块2 } else {执行代码块n } 2.8 Scala块表达式 在Java或C++中，块语句是- -个包含于I[{}中的语句序列。每当需要在逻辑分支或循环中执行多个动作时， 你都可以使用块语句。 在Scala中，{}块包含一 些列表达式，其结果也是- -个表达式。块中最后- -个表达式式的值就是块的值。 var f=3 varn=10 varm= 1 val d = if(n d=24 注意:前面提到过，scala中的语句终止就是换行，也就是一行一个语句，此时便可以省略 ”;”，但是当 一行有多条语句的时候，就应该使用”;”分隔。在表达式块中同样可以使用换行作为一条语句的分隔。 2.9 Scala循环简介 概述 在scala中有for循环和while循环，用for循环比较多。其中while循环和do. .. while循环和java中得语法结构一致，for循环稍有差异。 to和until to和until主要是用于生成一个列表或者范围。 i to j (包含i和j) i until j (包含i,但不包含j) 2.10 IDEA整合Scala插件 2.10.1 IDEA下载Scala插件 2.10.2 创建Scala项目 接下来就可以通过IDEA创建一个新的Scala项目 ![) 2.11 基于Maven来创建项目 在实际开发中，更多的时基于Maven来构建Scala项目 新建项目之前，首先先设置Scala模块，方法如下； 此时点击New可以新建一个Scala项目。 模块创建完成之后，在新项目创建完成之后，在pom.xml中添加依赖。 org.scala-lang scala-library 2.11.8 2.11.1 编写第一个HelloWorld 使用Scala写的第一个Scala代码 package com.zut.nanyu.scala object one { def main(args: Array[String]): Unit = { println(\"HelloWorld\") } } Scala中的流程控制-循环 3.1 Scala中的while循环 需要注意的是Scala中 ; 可加可不加，不会产生影响。 Scala中不能用++或--来代替 自增或自减，因为++/—-是Scala中集合的一个函数 package com.zut.nanyu.scala /** * While循环 * java语言实现 int sum=0; int n=1; while(n 3.2 Scala中的do-while循环 package com.zut.nanyu.scala /**do-While循环 *java语言实现 int sum=0; int n=1; do{ sum=sum+n; n++; }while(n 3.3 while-if循环控制练习 题目要求：登录用户名密码的游戏:三次机会，从控制台输入用户名密码，如果成功登录，返回登录成功，失败，则反馈错误信息! package com.zut.nanyu.scala import scala.io.StdIn /* 使用Scala简单实例 */ object WhileIfDemo { def main(args: Array[String]): Unit = { val Username=\"钉子君\" val Passwd=\"123456\" var n=3; //Scala中从控制台输入的api是StdIn.Line/StdIn.Int/StdIn.next等等，与Java不同，使用方法如下 while(n>0) { var user=StdIn.readLine(\"请输入用户名：\"); var pw=StdIn.readLine(\"请输入密码：\"); if (Username==user&&Passwd==pw){ println(\"登录成功！\"); n=0; }else{ println(\"登录失败！请重新输入\"); n=n-1; } } } } 3.4 for循环 在java中有2中写法，普通的for循环for (变量;条件;自增或自减) {循环体} or for(类型 变量:集合) {}。 scala中的for循环该如何定义呢?scala中并没有像java中普通for循环的语法结构，更像是高级for循环。 语法格式: for (变量 package com.zut.nanyu.scala /* Java中的for循环 int sum=10; for(int i=0;i 3.5 for循环的嵌套 除了for循环的基本形态之外，Scala也提供了其它丰富的高级特性。比如可以在for循环括号里同时包含多组”变量for (i for循环的这种结构类似Java中的嵌套循环结构。 if循环守卫可以为嵌套循环通过if表达式添加条件 for(i if表达式是否添加括号，结果无变化。 for(i 注意:注意在if之前并没有分号。 package com.zut.nanyu.scala /* 打印一个五行五列的矩阵 ***** ***** ***** ***** ***** */ object ForDemo { def main(args: Array[String]): Unit = { println(\"---------------------打印矩形---------------------\"); for(n=n){ print(\"*\"); }else{ print(\" \"); } } println; } println(\"---------------------打印九九乘法表---------------------\"); for(n 3.6 循环终止的三种方式 在java中终止循环有关键字，continue, bHreak, return,但是在scala中没有前两者continue和break。在scala中有三种方式来结束循环: 使用return语 句来控制循环结束 使用循环结束的条件来进行控制，比如上例中的count >= 0 还可以使用breakable函数体来进行控制 3.6.1 使用return来终止循环 object WhileIfDemo { def main(args: Array[String]): Unit = { val Username=\"钉子君\" val Passwd=\"123456\" var n=3; //Scala中从控制台输入的api是StdIn.Line/StdIn.Int/StdIn.next等等，与Java不同，使用方法如下 while(n>0) { var user=StdIn.readLine(\"请输入用户名：\"); var pw=StdIn.readLine(\"请输入密码：\"); if (Username==user&&Passwd==pw){ println(\"登录成功！\"); //n=0; //使用return来结束循环 return; }else{ println(\"登录失败！请重新输入\"); n=n-1; } } } } 3.6.2使用循环结束条件来结束循环 object WhileIfDemo { def main(args: Array[String]): Unit = { val Username=\"钉子君\" val Passwd=\"123456\" var n=3; //Scala中从控制台输入的api是StdIn.Line/StdIn.Int/StdIn.next等等，与Java不同，使用方法如下 while(n>0) { var user=StdIn.readLine(\"请输入用户名：\"); var pw=StdIn.readLine(\"请输入密码：\"); if (Username==user&&Passwd==pw){ println(\"登录成功！\"); //使用循环结束条件来结束循环，比如n作为计数器，作为循环结束条件 n=0; return; }else{ println(\"登录失败！请重新输入\"); n=n-1; } } } } 3.6.3使用breakable函数结束循环 //导入Breaks下面的所有包 import scala.util.control.Breaks._ object WhileIfDemo { def main(args: Array[String]): Unit = { val Username=\"钉子君\" val Passwd=\"123456\" breakable{//使用breakable作为外壳，套在循环外 var n=3; while(n>0) { var user=StdIn.readLine(\"请输入用户名：\"); var pw=StdIn.readLine(\"请输入密码：\"); if (Username==user&&Passwd==pw){ println(\"登录成功！\"); // n=0; // return; break();//此时便能可以通过调用break（）函数来结束循环 }else{ println(\"登录失败！请重新输入\"); n=n-1; } } } } } 3.7 Scala异常控制和懒加载 3.7.1 异常控制 Scala的异常处理和其它语言比如Java类似，一个方法可以通过抛出异常的方法而不返回值的方式终止相关代码的运行。调用函数可以捕获这个异常作出相应的处理或者直接退出，在这种情况下，异常会传递给调用函数的调用者，依次向上传递，直到有方法处理这个异常。 try { //vari=1 / 0 lazy val num = Integer. valueOf (”abcd' \") val file = new FileInputStream(\"abedefg\") } catch { case e: ArithmeticException => println(e. getMessage) case el: NumberFormatException => el. printStackTrace () case_ :Exception => {//_下划线代表上述没有匹配到的其他的异常 println(\"文件找不到\") } Scala中文件从磁盘中读取（即Scala中的IO流） package com.zut.nanyu.scala import scala.io.Source object ExceptionsDemo { def main(args: Array[String]): Unit = { //Source为Scala中读取文件的接口，即Scala中的IO.读取磁盘中的Hello.txt文件 val lines = Source.fromFile(\"D:\\\\AppInstall\\\\IDEA\\\\IDEAScala\\\\Scalo0\\\\data\\\\Hello.txt\"); //得到从磁盘中的得到的内容 val cont = lines.mkString println(cont) } } 结果：D:\\AppInstall\\JDK\\bin\\java.exe Hellojava! HelloScala! HelloWeb! 当Source找不到文件时，就会出现FileNotFoundException错误，Scala中需要用try{}catch{}做抛出异常操作。 package com.zut.nanyu.scala import java.io.FileNotFoundException import scala.io.Source object ExceptionsDemo { def main(args: Array[String]): Unit = { try { //Source为Scala中读取文件的接口，即Scala中的IO.读取磁盘中的Hello.txt文件 val lines = Source.fromFile(\"D:\\\\AppInstall\\\\IDEA\\\\IDEAScala\\\\Scalo0\\\\data\\\\Hello1.txt\"); //Hello1文件并不存在，所以会有异常 //得到从磁盘中的得到的内容 val cont = lines.mkString println(cont) } catch { case fnfe: FileNotFoundException => { println(fnfe.getMessage) } } } } j结果：D:\\AppInstall\\IDEA\\IDEAScala\\Scalo0\\data\\Hello1.txt (系统找不到指定的文件。) Scala中如果代码中有多个异常需要抛，可以一个一个用case（不推荐），也可以使用通用异常处理方法，只用写一个case即可 一个一个用case抛的案例（如果异常过多，会很麻烦） object ExceptionsDemo { def main(args: Array[String]): Unit = { //Source为Scala中读取文件的接口，即Scala中的IO.读取磁盘中的Hello.txt文件 val cont = Source.fromFile(\"D:\\\\AppInstall\\\\IDEA\\\\IDEAScala\\\\Scalo0\\\\data\\\\Hello.txt\").mkString; //Hello1文件并不存在，所以会有异常 //得到从磁盘中的得到的内容 println(cont) try { var i = 1 / 0; } catch { case fnfe: FileNotFoundException => { println(fnfe.getMessage)}//用于处理文件不存在的异常 case am:ArithmeticException =>{ println(am.getMessage)}//用于处理数字运算异常 } } } 使用通用抛异常的方法，只需要一个case就能解决 object ExceptionsDemo { def main(args: Array[String]): Unit = { //Source为Scala中读取文件的接口，即Scala中的IO.读取磁盘中的Hello.txt文件 val cont = Source.fromFile(\"D:\\\\AppInstall\\\\IDEA\\\\IDEAScala\\\\Scalo0\\\\data\\\\Hello.txt\").mkString; //Hello1文件并不存在，所以会有异常 //得到从磁盘中的得到的内容 println(cont) try { var i = 1 / 0; } catch { case _ => {// — 在Scala中表示全部的意思 println(\"通用异常处理\") } } } } 3.7.2 懒加载 lazy : 懒加载，被lazy所修饰的变量，之后当第一次被调用的时候才会进行初始化，之前只是做了语法结构的正确性判断。 object ExceptionsDemo { def main(args: Array[String]): Unit = { try { //Source为Scala中读取文件的接口，即Scala中的IO.读取磁盘中的Hello.txt文件 lazy val cont = Source.fromFile(\"D:\\\\AppInstall\\\\IDEA\\\\IDEAScala\\\\Scalo0\\\\data\\\\Hello1.txt\").mkString; //Hello1文件并不存在，所以会有异常 //得到从磁盘中的得到的内容 //println(cont) } catch { case _ => { println(\"通用异常处理\") } } } } 在cont前加上lazy之后，cont就延迟被加载一次，即不会执行这条命令，只有当cont被调用时才会被加载（即把Println（cont）取消注释之后就会执行lazy） 懒加载的使用场景：打开博客网站时，页面会出现一些文章，而当点击底部的更多文章时，就会出现更多的文章，这些文章都是通过懒加载实现的，只有被点击调用时才会被加载，呈现出来。 3.8 Scala函数与方法的定义 Scala除了方法外还支持函数。方法对对象进行操作，函数不是。要定义函数，你需要给出函数的名称、参 数和函数体，就像这样: def:相当于Java中private、public、protect welcome：相当于Java中的方法名 name：String：相当于Java中的参数 String：相当于Java中的返回值类型 1、你必须给出所有参数的类型。不过，只要函数不是递归的，你就不需要指定返回类型。Scala编译器 可以通过=符号右侧的表达式的类型推断出返回类型。 2、“=”并不只是用来分割函数签名和函数体的，它的另-个作用是告诉编译器是否对函数的返回值进行类型推断! 如果省去=,则认为函数是没有返回值的! Scala中函数的定义 /* Scala中函数的定义 */ object FunctionDemo { def main(args: Array[String]): Unit = { val Str = PrintDemo(\"钉子君\"); println(Str) } def PrintDemo(name: String): String = { \"Hello\" + name; } } 如果定义的函数写了返回值类型，则必须要加\"=\",不然编译器通不过 //当有返回值，且返回值后不加 “=” 时，编译器会报错 def PrintDemo1(name: String): String{ \"Hello\" + name; } 如果没有写返回值类型， 但是加了\"=\"，编译器会自动的进行类型推断 //当无返回值，且加 “=” 时，编译器会自动识别返回类型 def PrintDemo1(name: String)={ \"Hello\" + name; } 如果没有写返回值类型，也没有加\"=”，编译器认为你该函数没有返回值类型， 或者返回值类型unit //当无返回值，且不加 “=” 时，编译器没有返回类型或返回类型为unit def PrintDemo1(name: String){ \"Hello\" + name; } 3.9 Scala基本函数 Scala的几个基本函数: 无返回值的函数 //没有返回值的函数 def PrintDemo1(name: String){ println(\"Hello\" + name) } 空参函数: 如果一个函数在定义的时候没有参数,在调用时,可以省略掉() ,如果在定义一个空参函数时,省略了(),则在调用时也要省略掉() object FunctionDemo { def main(args: Array[String]): Unit = { PrintDemo1(\"于士豪\"); PrintDemo2(); PrintDemo2;//可以省略掉() PrintDemo3;//必须省略() } //空参函数 def PrintDemo2(){ println(System.currentTimeMillis()) } def PrintDemo3{ println(System.currentTimeMillis()) } 单行函数:必须要使用\" =\"将函数与函数体连接 object FunctionDemo { def main(args: Array[String]): Unit = { PrintDemo1(\"于士豪\"); PrintDemo2(); PrintDemo2; PrintDemo3(\"中国\"); } //单行函数 def PrintDemo3(name: String) = println(name + \"加油！\"); 递归函数 object FunctionDemo { def main(args: Array[String]): Unit = { PrintDemo1(\"于士豪\"); PrintDemo2(); PrintDemo2 PrintDemo3(\"中国\") var sum=PrintDemo4(5) println(sum); } //没有返回值的函数 def PrintDemo4(n: Int):Int= { if(n 4.0 Scala中的默认参数和带名参数 1、我们在调用某些函数时并不显式地给出所有参数值，对于这些函数我们可以使用默认参数。 def sayDefaul tFunc (name: String, address: String = \"Beijing\"， tellphone: String = 13*) ={ println (name +\" address=>\" + address +\"\\t teIlphone=>\" + tellphone) 2、不指定具体参数时:给出默认值 sayDefaultFunc(\"Garry”) 3、如果相对参数的数量,你给出的值不够，默认参数会从后往前逐个应用进来。 sayDefaultFunc (\"Garry \", \"Shanhai ”) 4.给出全部的参数值 sayDefaultFunc(\"Garry \", \"Shanhai ”,”13709872335*) 5、帶名参数可以让函数更加可读。它们对于那些有很多默认参数的函数来说也很有用。 sayDefaul tFunc (address =” 上海”，tellphone=' \"12109876543 \", name= \"Tom”) 6、你可以混用未命名参数和带名参数,只要那些未命名的参数是排在前面的即可: sayDefaultFunc(\"Tom\" tellphone= ”12109876543 , address = \"上海”) class word{ } //单例对象，写入主方法mian object word{ } "},"13-Blog/1-CSS之postion属性.html":{"url":"13-Blog/1-CSS之postion属性.html","title":"1. CSS之Postion属性","keywords":"","body":"1 CSS中postion属性 CSS中postion属性是用于元素定位的属性，即指定某元素的在页面中的位置。 属性的常用取值： absolute：绝对定位 fixed：固定定位 relative：相对定位 这几种是平常用到的最多的定位方式，当然还有其他属性值，一般比较少用（或者说我很少使用)，下面一一介绍这三种定位方式。 1.1 固定定位：fixed 固定定位的参照物是浏览器窗口，即相对浏览器窗口的位置，把元素固定在浏览器窗口的某一位置。被固定的元素不占文档空间，其他元素可以占该元素正常布局时的位置。被固定的元素可以通过top、bottom、left、right改变元素相对浏览器窗口的位置。 固定定位一般用在侧边导航栏或底部导航栏。 举一个简单的固定定位的例子： postion /* 初始化一下文档 */ * { margin: 0; padding: 0; } .test1 { /* 设置块级元素的大小和颜色 */ width: 100px; height: 100px; background-color: aqua; /* 采用固定定位固定元素位置 */ position: fixed; /* 设置该div与浏览器窗口的位置 */ /* 左边间隔30px */ left: 30px; /* 上边间隔50px */ top: 50px; } 一般情况下，固定定位常用于固定底部导航栏。下面是一个底部导航栏的案例。 postion * { margin: 0; padding: 0; } .footer { height: 60px; position: fixed; bottom: 0; right: 0; left: 0; } .footer ul { overflow: hidden; } .footer ul li { float: left; list-style: none; width: 33.3%; background-color: rgb(116, 113, 113); } .footer ul li a { text-decoration: none; } .footer li img { display: block; margin: 7px auto 7px; width: 23px; height: 23px; } .footer li a span { display: block; text-align: center; color: #fff; font-size: 14px; font-weight: normal; margin-bottom: 7px; } 首页 分类 我的 固定之后，导航栏不会随着屏幕的滑动而滑动。 1.2 绝对定位：absolute 绝对定位的参照物是当前元素的上一级元素（可以是body），即相对该元素的父元素的位置。用了相对定位之后该元素在其父元素内不占空间，该父元素中的其他元素可以叠加到该元素之上。 被定位的元素在其父元素中通过left、right、bottom、top来调整相对位置。 下面是一个使用绝对定位的小例子。 postion * { margin: 0; padding: 0; } .box { /* 设置一个父元素,设置宽度与高度 */ width: 400px; height: 500px; background-color: purple; position: relative; } .item { /* 使用绝对定位的元素 */ width: 200px; height: 300px; background-color: powderblue; /* 使用绝对定位 */ position: absolute; /* 距离顶部40px */ top: 40px; /* 距离左边90px */ left: 90px; } 1.3 相对定位：relative 相对定位指相对该元素原来位置，它的参照物是该元素最初的位置。相对定位也是通过left、right、top、bottom来调整位置。 postion * { margin: 0; padding: 0; } .box { width: 400px; height: 500px; margin-left: 100px; margin-top: 50px; padding: 20px 20px; border: 2px solid blue; } .item1 { display: block; width: 150px; background-color: gray; margin-top: 10px; color: white; } .item2 { display: block; width: 250px; margin-top: 10px; color: white; background-color: rgb(223, 138, 138); position: relative; left: 20px; } .item3 { display: block; width: 250px; margin-top: 10px; color: white; background-color: rgb(141, 223, 138); position: relative; right: 10px; } .item4 { display: block; width: 250px; margin-top: 10px; color: white; background-color: rgb(24, 145, 175); position: relative; top: -110px; } 这是最初的位置 这是相对最初位置向右20px的位置 这是相对最初位置向左10px的位置 移动相对定位元素，它原本所占的空间不会改变 相对定位只是造成视觉显现出现移动的偏差，但其最初所占的空间不会改变。 即某个元素设置了相对定位，看起来它向左或向右移动了一段距离，但这只是视觉上造成的偏差。而实际上该元素最初所占的空间不会移动，还在原来的位置，该元素下面那些没有设置定位的元素不会移动上来。 一般相对定位与绝对定位的使用时按照子绝父相的原则。 "},"13-Blog/2-CSS之浮动.html":{"url":"13-Blog/2-CSS之浮动.html","title":"2. CSS之浮动","keywords":"","body":""},"13-Blog/3-flask_migrate数据库迁移.html":{"url":"13-Blog/3-flask_migrate数据库迁移.html","title":"3. Flask Migrate数据库迁移","keywords":"","body":"第一次进行迁移时： python manage.py db migrate -m \"init tables\" python manage.py db upgrade 后续进行字段更新时： python manage.py db migrate # 检查模型字段是否修改,如果改变,就产生新的迁移文件. python manage.py db upgrade # 对迁移文件进行迁移 "},"13-Blog/4-HEU KMS ActivatorHEU KMS Activator重装系统激活Office必备 .html":{"url":"13-Blog/4-HEU KMS ActivatorHEU KMS Activator重装系统激活Office必备 .html","title":"4. HEU KMS ActivatorHEU KMS Activator重装系统激活Office必备","keywords":"","body":"经常重装系统的小伙伴应该知道，每次重装完系统之后都要重新激活系统和Office，但正版激活序列一般较贵，所以很多人喜欢在某购物平台上买激活序列。 其实，除了购买激活序列，还有一种方式可以激活系统和Office，即使用KMS激活，这也是微软官方认可的一种系统激活方式，它的激活命令是由微软官方提供、官方可查询。 而今天小钉分享的这款，是由大神知彼而知己开发，多年来备受好评，多年前曾开放源码。这款软件激活成功率高、安全无毒、无捆绑后门、可断网激活。 #软件介绍 软件名称: HEU KMS Activator 软件大小：7.1M适用系统：Win下载地址：见文末 虽然软件安全无毒，但杀毒软件会误报，所以如果出现误报，请先关闭杀毒软件。 如果当前系统还没有激活，软件可以识别最佳的激活方式。 同时软件可检测系统系统是否已经激活，如果已经激活也可重置激活。 可使用KMS激活方式来激活系统或激活Office。 也可以使用数字许可证激活方式或KMS38方式激活系统。 最近的版本又新增了OEM激活方式。 软件作者开设的也有微信公众号，名叫：知彼而知己，有兴趣的可以去作者的公众号看看哦。 今天的分享就到这啦，有需要的小伙伴建议收藏起来，暂时用不到的也可以收藏起来，有备无患~ #软件下载 点我下载 欢迎关注微信公众号：钉子君 "},"13-Blog/5-Hexo搭建个人博客.html":{"url":"13-Blog/5-Hexo搭建个人博客.html","title":"5. Hexo搭建个人博客","keywords":"","body":"身处互联网这个大浪潮下，能有一个属于自己的网站（个人博客）用来记录身边的趣事，记录自己学习的心得，将自己的所得所想分享给别人感觉是一件非常酷的事。再者在自己的网站上想发什么就可以发什么（除了违法的），完全不用考虑平台限制发言的问题。 可能有些人会想：自己一没有技术，二没资金，拿什么搭建个人博客？ 其实这些事情完全不用考虑，现在网上的一些博客程序已相对成熟，它不需要我们拥有过多技术，不需要花钱也能搭建一个属于自己的网站。 今天小丁就通过Hexo+Github Pages的方法（如果你不知道这两个东西是什么，我在下面会有简单的介绍）来教大家如何搭建一个完全免费又非常棒的博客平台（前提是你有玩机的热情）。如果你是完全的电脑小白，但也想拥有一个自己的个人博客，那你也不用担心，这篇教程是完全零基础的，只要手把手跟着做基本是不会出错的，能说明白的小丁会尽量为大家说清楚。 因篇幅限制，所以教程共分为两篇，本篇文章主要教大家博客的搭建，第二篇主要教大家如何更换博客的主题（即网站皮肤）以及让自己的网站被搜索引擎收录从而让别人更加容易的搜到你的网站。 好了，不啰嗦了，下面正文开始。为了更方便阅读，以下是整篇文章的目录。 Hexo介绍 Github介绍 安装NodeJS 安装Git 安装Hexo 博客搭建完成 Hexo介绍 Hexo是什么？ 这是整个博客搭建的整体框架，其中Hexo是当下非常流行的博客框架，Github Pages是国外代码托管平台Github为用户免费提供的静态服务页面，我们的博客正是依赖于它存在的（也可以使用国内的Gitee Pages,不过Github Pages与Gitee Pages各有好坏，这在后面会介绍） 在正式开始搭建前需要做以下准备 1.安装Nodejs 2.安装git 3. "},"13-Blog/6-MySQL查询乱码.html":{"url":"13-Blog/6-MySQL查询乱码.html","title":"6. MySQL查询乱码","keywords":"","body":"在使用JDBC做数据查询时总是查询失败，找了找原因最终发现是编码问题，对于编码问题的解决，有以下两种方案 第一种：使用jdbc连接时，指定编码 String url = \"jdbc:mysql:///project?useSSL=false&useUnicode=true&characterEncoding=utf8\"; 第二种：修改MySQL配置文件 找到MySQL中的my.ini配置文件 再[mysqld]下面添加下面一行： character_set_server = utf8 然后保存重启MySQL服务 "},"13-Blog/7-计算APP评分.html":{"url":"13-Blog/7-计算APP评分.html","title":"7. 计算APP评分","keywords":"","body":"计算APP评分 在上一个MapReduce实例WordCount中，使用的是默认的数据格式IntWirteable。但由于MapReduce的数据格式是可以自定义的。 因此，该篇文章是记录使用自定义输入数据类型来实现:大量用户对App四方面性能的平均得分。 案例要求： 求用户对 ： “拼多多、快手、biubiu加速器、腾讯加速器、抖音、QQ、你我当年、京东、作业帮、淘宝、微信、美团、腾讯视频、哔哩哔哩、钉钉、爱奇艺、菜鸟、微博、酷狗音乐、迅雷、小红书、学习通、夸克、QQ音乐、Soul、网易云音乐、百度网盘、饿了么、学习强国、知乎” 这30款App：UI设计 响应速度 使用率 喜爱程度 四个性能的平均评分 注意：必须使用自定义输入数据类型 源数据（30万用户量）： 源数据格式如下（部分）： 分别对应用户ID App名称 UI评分 响应速度评分 使用率评分 喜爱程度评分 U472239003843261 京东 60 75 46 99 U542820822173045 快手 2 20 80 19 U542820822173045 学习通 45 29 34 39 U542820822173045 滴滴出行 31 47 42 49 U542820822173045 作业帮 52 63 93 99 U542820822173045 夸克 11 13 4 92 U542820822173045 QQ音乐 94 68 87 50 U542820822173045 网易云音乐 46 15 81 14 U542820822173045 京东 81 61 81 57 U542820822173045 网易云音乐 5 69 50 66 代码实现： 自定义输入数据类型NewWriteable类 package com.zut.nanyu.hadoop.project4; import org.apache.hadoop.io.WritableComparable; import java.io.DataInput; import java.io.DataOutput; import java.io.IOException; import java.text.NumberFormat; /* 自定义数据类型需继承WritableComparable类 */ public class NewWriteable implements WritableComparable { private double Ui;//UI设计组件 private double Vel;//响应速度组件 private double De;//使用程度组件（Degree） private double Lov;//喜好程度组件 private double All;//总评分 /* 无参构造器 */ public NewWriteable() { } /* 有参构造器 */ public NewWriteable(double Ui, double Vel, double De, double Lov, double All) { this.Ui = Ui; this.Vel = Vel; this.De = De; this.Lov = Lov; this.All = All; } public NewWriteable(double Ui, double Vel, double De, double Lov) { this.Ui = Ui; this.Vel = Vel; this.De = De; this.Lov = Lov; } public double getUi() { return Ui; } public void setUi(int ui) { Ui = ui; } public double getVel() { return Vel; } public void setVel(int vel) { Vel = vel; } public double getDe() { return De; } public void setDe(int de) { De = de; } public double getLov() { return Lov; } public void setLov(int lov) { Lov = lov; } public double getLAll() { return All; } public void setAll(int all) { All = all; } /* 普通的方法类，也可以单独写一个工具类来实现 */ public NewWriteable run(Iterable values) { int count = 0;//用于计数，算平均 double Ui = 0, Vel = 0, De = 0, Lov = 0, All = 0, Ave = 0;//依次对应UI设计、响应名称、使用率、喜爱程度、总评分 for (NewWriteable value : values) { Ui = Ui + value.getUi(); Vel = Vel + value.getVel(); De = De + value.getDe(); Lov = Lov + value.getLov(); Ave = (Ui + Vel + De + Lov) / 4; count = count + 1; } //最终数数据保留两位小数 NumberFormat ny = NumberFormat.getInstance(); ny.setMaximumFractionDigits(2); double UI = Ui / count; double VEL = Vel / count; double DE = De / count; double LOV = Lov / count; double AVE = Ave / count; return new NewWriteable(Double.parseDouble(ny.format(UI)), Double.parseDouble(ny.format(VEL)), Double.parseDouble(ny.format(DE)), Double.parseDouble(ny.format(LOV)), Double.parseDouble(ny.format(AVE))); } @Override public String toString() { return \" \" + Ui + \" \" + Vel + \" \" + De + \" \" + Lov + \" \" + All; } /* 序列化与反序列化 */ @Override public void write(DataOutput out) throws IOException { out.writeDouble(this.Ui); out.writeDouble(this.Vel); out.writeDouble(this.De); out.writeDouble(this.Lov); out.writeDouble(this.All); } @Override public void readFields(DataInput in) throws IOException { this.Ui = in.readDouble(); this.Vel = in.readDouble(); this.De = in.readDouble(); this.Lov = in.readDouble(); this.All = in.readDouble(); } @Override public int compareTo(NewWriteable o) { return 0; } } MapReduce类 package com.zut.nanyu.hadoop.project4; import org.apache.hadoop.io.LongWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Mapper; import org.apache.hadoop.mapreduce.Reducer; import java.io.IOException; /* @钉子君 Mapreduce实例 需求：统计每个App指标的平均评分 */ /* Map阶段 */ class AveMapper extends Mapper { @Override protected void map(LongWritable key, Text value, Mapper.Context context) throws IOException, InterruptedException { //使用制表符分隔成数组 String strs[] = value.toString().split(\"\\t\"); //strs[0]为用户ID，无用。strs[1]为APP名称，作为Map输出的key值，Map输出的value值为自定义数据类型，参数为strs[2]、strs[3]、strs[4]、strs[5] for (String str : strs) { context.write(new Text(strs[1]), new NewWriteable(Double.parseDouble(strs[2]), Double.parseDouble(strs[3]), Double.parseDouble(strs[4]), Double.parseDouble(strs[5]))); } } } /* Reduce阶段 */ class AveReducer extends Reducer { @Override protected void reduce(Text key, Iterable values, Context context) throws IOException, InterruptedException { context.write(key, new NewWriteable().run(values)); } } Driver类 package com.zut.nanyu.hadoop.project4; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Job; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat; /* Driver类里设置各种变量，同时采用Win系统上运行 */ public class Driver { public static void main(String[] args) throws Exception { Configuration conf = new Configuration(); Job job = Job.getInstance(conf, \"App\"); job.setJarByClass(Driver.class); job.setMapperClass(AveMapper.class); job.setReducerClass(AveReducer.class); job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(NewWriteable.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(NewWriteable.class); FileInputFormat.addInputPath(job, new Path(\"file:///D:\\\\Download\\\\MapReduceData\\\\in\")); FileOutputFormat.setOutputPath(job, new Path(\"file:///D:\\\\Download\\\\MapReduceData\\\\out\")); System.out.println(job.waitForCompletion(true)?0:1); } } 最终结果： 总结：其实现原理和WordCount的实现原理是一致的，只是Word Count使用的是默认的数据类型IntWriteable，而本篇文章中的案例，必须使用自定义输入数据格式来实现，底层原理是一样的。 "},"13-Blog/8-动态规划解决最大子数组问题.html":{"url":"13-Blog/8-动态规划解决最大子数组问题.html","title":"8. 动态规划解决最大子数组问题","keywords":"","body":"动态规划解决最大子数组问题 最大子数组问题： 输入：数组，一组数据 输出：Smax=max{s(l,r)}（l // 1. 问题结构分析 P[i,c]=max{P[i-1,c-v(i)]+p(i),P[i-1,c]} //左边选取该商品后的价格，右边为不选该商品后的价格 // Smax是输入的一组数据中最大的子数组的和，l表示开始元素的下标，r表示结束元素的下标 Smax=maxS{l,r} // 优化后的枚举，S[l,r]：下标为l到下标为r的数组的和。 S[l,r]=S[l+1,r]+X[l] // S[l,r]=S[l+1,r]+X[l]：表示下一个子数组的和，等于上一个子数组的和加x[r] S[l+1,r]=S[l+2,r]+X[l+1] ...... S[r-1,r]=S[r,r]+X[r-1] // 遍历到最后变成了从下标r到下标r，其结果就是X[r] S[r,r]=X[r] // 上面的代码有两个参数，下面是变成一个参数。 // D[i]:从下标为i开始的最大的子数组和 // D[1]:表示从1开始到下标为2、3、4、5、n的最大子数组的和，是个列表[D(1,2),D(1,3),D(1,n)] // 从D[i]的得到的子数组和中选择一个最大的：max{D[i]} i∈{1,n} D[i]=X[i]+X[i+1]+X[i+2]+......+X[n] D[i+1]= X[i+1]+X[i+2]+......+X[n] D[i+2]= X[i+2]+......+X[n] ...... D[n]=X[n] i开头 D[i]=D[i+1]+X[i] D[i]= X[1]+X[2]+X[3]+......++X[i-1]+X[i] D[i+1]=X[1]+X[2]+......+X[i-2]+X[i-1] ...... D[n]=X[n] i结尾 D[i]=D[i-1]+X[i] // 2. 递推关系建立 // 上述规律总结 D[i]=X[i]+D[i+1] // 求最大子数组和 D[i]=X[i]+D[i+1] if D[i+1]>0, max{D[i]}=X[i]+D[i+1] D[i]=X[i]+D[i+1] if D[i+1]0 //大于0的时候保留D[i+1]，表示选取了D[i+1] Rec[i]=Rec[i] if D[i+1] 动态规划四部曲 问题结构分析 递推关系建立 自底向上计算 最优方案追踪 子序列 将给定序列中零个或多个元素去掉后的结果 最大子数组和 最长公共子序列 最长公共子序列的要求：给定两个序列X和Y，要求两个子序列中存在的最长的公共子序列 如： 序列X：A B C B D A B 序列Y：B D C A B A 求两个数列中存在的最长公共子序列 输入： 序列X{x1,x2,x3....xm},序列Y{y1,y2....yn} 输出： 求解一个公共子序列Z={z1,z2,z3....zl}，令max{Z} 约束条件 # l是公共子序列的长度，m是序列X的长度，n是Y序列的长度 0 动态规划中的最优子结构性质：原问题的最优解肯定包含子问题的最优解 分治法解决最大子数组问题 学习通作业 动态规划解决最大子数组问题 学习通作业 贪婪算法 0-1背包问题定义： 输入：n个商品组成的集合O，每个商品有两个属性Vi和Pi，分别表示每个商品的体积和价格 输出：商品子集S 部分背包问题： 问题背景：调制饮料比赛：参赛者拥有容量为800ml，可任选不超过体积上限的饮料进行混合，调制饮品价格为各所使用饮料价格之和，所得饮品价格之和最高者获胜 问题定义： 输入：n个商品组成的集合O，每个商品有两个属性Vi和Pi，分别表示每个商品的体积和价格 输出：商品子集S={Xi|1 max求和(Xi*Pi)----------f(s)=max(x1p1+x2p2+x3p3+...+xnpn) Xi∈(0,1] 约束条件:求和(XiVi)部分背包与0-1背包不同的是商品子集S的表示 0-1背包中的S 部分背包中S={Xi|1 饮料 价格体积 体积 苏打水 60 600 汽水 10 250 橙汁 36 200 苹果汁 16 100 西瓜汁 45 200 部分背包问题与0-1背包问题的区别：0-1背包中必须使用商品的全部体积，而部分背包中可以抽取商品的部分体积。 贪心解：橙汁200体积+苹果汁100体积+西瓜汁200体积+苏打水300体积，除了最后一个商品未选完体积，前面选的所有商品都会选择所有体积 最优解：对于选中的每一个商品，可能都只选择了该商品中的一部分体积，从每个商品中选择一部分体积，凑够800ml，使得价格最高 贪心算法伪代码 i=1; // 初始化商品序号为1 price=0; //初始化价格为0 //表示当杯子还没装满，还有体积 while (C>0 and i "},"14-408/1-操作系统/1-操作系统.html":{"url":"14-408/1-操作系统/1-操作系统.html","title":"1. 操作系统","keywords":"","body":"第一章 计算机系统概述 1.1 操作系统概念 一台电脑的诞生： 厂家组装一台裸机 出售前安装操作系统 用户安装QQ、微信、联盟等应用 使用QQ聊天 操作系统的定义：（Operating System OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。 操作系统是系统资源的管理者，即对上层软件进行管理也对下层硬件进行管理。 操作系统为上层提供易用的服务。 操作系统是软件而不是硬件，它是最接近硬件的一层软件。 直观的例子：打开Windows的任务管理器，如下： 左边百度网盘、PPT、Typora等都是操作系统对软件的管理，右边CPU、内存、磁盘、网络、GPU等都是操作系统对硬件的管理。 1.1.1 作为资源的管理者 执行一个程序前需要先将该程序放到内存中，才能被CPU处理。 作为资源的管理者，主要提供的管理功能有：处理机管理、存储器管理、文件管理、设备管理。 用QQ和朋友聊天的过程表示出操作系统作为资源的管理者的具体呈现： 在各个文件夹中找到QQ安装的位置，如D:/Tencent/QQ/Bin（文件管理功能） 双击打开QQ.exe（存储器管理：把该程序的相关数据放入内存） QQ程序正常运行（处理机管理：对应的进程被处理机即CPU处理） 开始和朋友视频聊天（设备管理：将摄像头设备分配给进程） 1.1.2 为上层提供方便易用的服务 封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便的使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。 操作系统为上层提供的服务： 现代：比如GUI（图形化用户接口），用户可以使用形象的图形化界面进行操作，而不需要记忆复杂的命令、参数。例如：在Win系统中，删除一个文件只需要把文件”拖拽“到回收站即可。 早期：早期操作系统并没有GUI，而是提供给用户命令接口（即命令行形式）的形式与用户交互，命令接口又分为两种形式：一种是联机命令接口，一种是脱机命令接口。 联机命令接口（交互式命令接口）：使用Win+R键，输入cmd可调出终端，如下： 脱机命令接口（批处理命令接口）：使用Win系统的搜索功能，搜索C盘种的*.bat文件，用记事本打开任意一个，里面是一堆命令。 程序接口：可以在程序种进行系统调用来使用程序接口，普通用户不能直接使用程序接口，只能通过程序代码间接使用。 系统调用类似函数调用，是应用程序请求操作系统服务的唯一方式 1.1.3 操作系统的功能和目标 需要实现对硬件机器的扩展，没有任何软件支持的计算机成为裸机。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。通常把覆盖了软件的机器成为扩充机器，又称之为虚拟机 类比汽车：发动机-只会转，轮子-只会滚，如果在原始的硬件机器上，再加一层传动系统，让发动机带着轮子转，使原始的硬件机器得到扩展。 操作系统对硬件机器的拓展：将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能。 1.1.4 总结 1.2 操作系统的特征 操作系统有四个特征，分别是：并发、共享、虚拟、异步，其中并发与共享是最基本的特征，两者互为存在条件。 1.2.1 并发 并发：指两个或多个事件再同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。 并行：两个或多个事件在同一时刻同时发生。 两者区别： 操作系统的并发性是指计算机系统”同时“运行着多个程序，这些程序宏观上看是同时运行的，而微观上看是交替运行的。 操作系统是伴随着”多道程序技术“而出现的。因此操作系统和程序并发是一起诞生的。 1.2.2 共享 共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。 两种资源共享方式： 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问资源。 同时共享方式：系统中的某些资源，允许一个时间段内由多个进程”同时“对他们进行访问。 所谓的”同时“，往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问（即分时共享） 实例： 互斥共享方式：使用QQ和微信视频，同一时间内摄像头只能分配给其中一个进程。 同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替访问硬盘。 1.2.3 并发与共享的关系 并发性指计算机系统中同时存在多个运行着的软件。 共享性指计算机系统中的资源可供内存中多个并发执行的进程共同使用。 共享与并发的关系：以使用QQ发送文件A，微信发送文件B为例。 两个进程正在并发执行 需要共享地访问硬盘资源 如果失去并发性，则系统中只有一个程序在运行，共享性就失去了它的意义；如果失去共享性，QQ和微信不能同时访问硬盘资源，就无法实现同时发送资源，并发性也就失去了意义。因此： 操作系统的共享性和并发性是相互依存的。 1.2.4 虚拟 虚拟是把一个物理上的实体变为若干个逻辑上的对应物。物理上的实体是真实存在的，而逻辑上的对应物是用户感受到的。 例子1： 注意：一个程序需要先放入内存并给他分配CPU才能执行。 情景：GTAS需要4GB的运行内存，QQ需要256MB内存，微信需要256MB内存，网易云需要256GB内存。 我的电脑：4GB运行内存 问题：这些软件同时运行的话需要的内存远大于4GB，为什么还可以同时在电脑上运行？ 原因：计算机采用了虚拟存储技术，实际只有4GB内存，在用户看来远远大于4GB（空分复用） 例子2： 情景：某单核CPU中，用户同时打开了QQ、微信、迅雷、GTAS软件 问题：既然一个程序需要被分配到CPU才能正常执行，那么为什么单核CPU电脑上能同时执行这么多程序？ 原因：计算机采用了虚拟处理器技术，实际只有一个单核CPU，在用户看来有6个CPU同时为自己服务（时分复用，微观上还是一个CPU在交替执行） 虚拟技术： 时分复用（如虚拟处理器技术） 空分复用（虚拟存储器技术） 如果失去了并发性，在同一时间段内只运行一个程序，则虚拟性也就失去了意义。 1.2.5 异步 异步是指在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。 举例：老渣要和两个女孩约会 第一道程序： 一号女孩的指令1：老渣陪我吃饭 一号女孩的指令2：老渣把心给我 第二道程序： 二号女孩的指令1：老渣把心给我 二号女孩的指令2：老渣陪我吃饭 与一、二号的约会=两道并发执行的程序 老渣的心=有限的系统资源 由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底，只有系统拥有并发性，才有可能导致异步性。 总结 1.3 操作系统的发展与分类 1.3.1 手工操作阶段 手工操作流程： 程序员先将自己的程序放在纸袋机上，计算机把纸袋机上的数据读取到计算机中（非常慢），计算机处理程序（非常快），再将程序结果输出到纸袋机上，最后程序员取走程序结果（非常慢）。 时间图示： 主要缺点：用户独占全机，人机速度矛盾导致资源利用率极低。 1.3.2 批处理阶段-单道批处理系统 引入脱机输入/输出技术（用外围机+磁带完成），并由监督程序负责控制作业的输入、输出。 单道批处理流程： 各程序员把自己的程序放入纸袋机上，由外围机负责把各程序存入磁带中，计算机从磁带中读取程序并处理（非常快），将处理结果再写入磁带中（快）。 时间图示： 主要优点：缓解了一定程序的人机速度矛盾，资源利用率有所提升 主要缺点：内存中仅能有一道程序运行，只有该程序运行结束之后才能运行下一道程序。CPU有大量的实践再空闲等待I/O完成。资源利用率依旧很低。 1.3.3 批处理阶段-多道批处理系统 操作系统正式诞生，用于支持多道程序并发运行 图示： 主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅度提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。此处的计算机资源包括：输入设备、CPU、输出设备 主要缺点：用户响应时间长，没有人机交互功能（用户提交自己的作业后只能等待计算机处理完成，中间不能控制自己作业的执行。eg:无法调试程序/无法在程序运行过程中输入一些参数） 1.3.4 分时操作系统 分时操作系统：计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机交互。 主要优点：用户请求可以被及时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作系统相互独立，感受不到别人的存在。（在用户看来仿佛自己独占全机） 主要缺点：不能优先处理一些紧急的任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户作业服务一个时间片，不区分任务的紧急性。 1.3.5 实时操作系统 在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。 主要优点：依旧基于时间片处理任务，但能够优先响应一些紧急任务，某些任务不需要时间片排队。 硬实时系统：必须在绝对严格的时间规定内完成任务（比如导弹控制系统、自动驾驶系统）。 软实时系统：可以接受偶尔违反规定的时间（比如12306订票系统）。 1.3.6 其他操作系统 网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。(如:Windows NT就是一种典型的网络操作系统，网站服务器就可以使用) 分布式操作系统：主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。 个人计算机操作系统:如 Windows XP、MacOS，方便个人使用。 1.4 操作系统的运行机制 1.4.1 程序是如何运行的 一条高级语言的代码翻译过来可能会对应多条机器指令，比如下方的代码： private int a; a++; 其经过编译器翻译之后的产生的二进制代码可能如下： 101010100101101010111 100100010010101101010 000110101010101010101 010101100111101101011 程序运行的过程其实就是CPU执行一条条的机器指令的过程。 指令：是处理器（CPU）能识别、执行的最基本的命令 注意：Linux、Windows、MacOS系统中的“小黑框”中使用的命令与本节中的指令有所区别，前者属于交互式命令接口，而后者属于二进制机器指令。 1.4.2 内核 应用程序：普通程序员写的程序就是应用程序。 内核程序：苹果、微软有一帮人负责实现操作系统，他们写的是内核程序 内核：有很多内核程序组成了操作系统内核，简称内核，内核是操作系统最核心的部分，也是最接近硬件的部分。操作系统的功能之一即：操作系统需要对系统资源进行管理，依靠的即是内核。 甚至可以说一个操作系统只需要有内核就足够了（如Docker仅需要Linux内核） 但并非操作系统的所有功能都在内核中，比如图形化用户界面GUI 操作系统内核作为“管理者”，有时会让CPU执行一些“特权指令”，如内存清零指令。这些指令影响重大，只允许“管理者”--即操作系统内核来使用。 应用程序只能使用非“特权指令”，比如加法指令、减法指令等。 在CPU设计和产生的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断出其类型。 1.4.3 内核态与用户态 CPU能判断出指令类型，但是它如何区分现在正在运行的是内核程序还是应用程序？ CPU有两种状态：内核态和用户态 内核态（核心态/管态）：当CPU处于内核态时，说明此时正在执行的是内核程序，此时可以执行特权指令 用户态：当CPU处于用户态时，说明此时正在执行的是应用程序，此时只能执行非特权指令 扩展：CPU中有一个寄存器叫程序状态寄存器（PSW），其中有个二进制位，1表示内核态，0表示用户态。 故事： 刚开机时，CPU位内核态，操作系统内核程序先上CPU运行 开机完成后，用户可以启动某个应用程序 操作系统内核程序在合适的时候主动让出CPU，让该应用程序上CPU执行（操作系统内核在让出CPU之前,会用一条特权指令把 PSW的标志位设置为“用户态”） 应用程序运行在用户态 此时一位猥琐的黑客在应用程序中植入了一条特权指令，企图破坏系统 CPU发现接下来要执行的这条指令是特权指令，但自己又处于用户态 这个非法事件会引发一个中断信号（CPU检测到中断信号后，会立即变为“核心态”，并停止运行当前的应用程序，转而运行处理中断信号的内核程序） 终端使操作系统再次夺回CPU的控制权 操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序。 内核态-->用户态：执行一条特权指令--修改PSW的标志位位用户态，这个动作意味着操作系统主动让出CPU使用权 用户态-->内核态：由中断引发，硬件自动完成变态过程，出发中断信号意味着操作系统强行夺回CPU使用权。 除了非法使用特权指令之外，还有很多事件会出发中断信号。一个共性是，但凡需要操作系统接入的地方，都会触发中断信号。 1.4.4 总结 1.5 中断和异常 1.5.1 中断的作用 中断会使CPU由内核态切换为用户态，是操作系统重新夺回对CPU的使用权。 中断，是让操作系统内核夺回CPU使用权的唯一途径，如果没有中断机制，那么一旦应用程序上CPU运行，CPU就会一致运行这个应用程序，也就不会存在并发。 内核态-->用户态：执行一条特权指令--修改PSW的标志位位用户态，这个动作意味着操作系统主动让出CPU使用权 用户态-->内核态：由中断引发，硬件自动完成变态过程，出发中断信号意味着操作系统强行夺回CPU使用权。 1.5.2 中断的分类 内中断：与当前执行的指令有关，中断信号来自CPU内部，也称异常（√） 例子1：黑客向正在执行应用程序的CPU中植入了一条有害的特权指令，CPU执行这条指令时，发现这是特权指令，会引发中断。--故障 例子2 ：CPU在用户态执行除法指令时，发现除数为0，表示这条指令是非法的，当CPU执行这条指令时会引发中断。--终止 例子3：有时候应用程序想请求操作系统内核服务，此时会执行一条特殊的非特权指令--陷入指令，该指令会出发一个中断信号。--陷入/trap/陷阱 外中断：与当前执行的指令无光，中断信号来自CPU外部，也称中断（狭义的中断） 例子1：时钟中断--由时钟部件发来的中断信号（并发的原理），时钟部件每隔一个时间片（如50ms）会给CPU发送一个时钟中断信号。--时钟中断 I/O中断--由输入输出设备发来的中断信号，当输入输出任务完成时，向CPU发送中断信号。--I/O中断请求 1.5.3 中断机制的基本原理 不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。 中断处理程序一定是内核程序，一定运行在内核态 1.5.4 总结 1.6 系统调用 系统调用一定会设计到CPU状态的切换 操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。 系统调用：是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数。应用程序可以通过系统调用来请求获得操作系统内核的服务。 1.6.1 系统调用与库函数的区别 不涉及系统调用的库函数：如“取绝对值”的函数 涉及系统调用的函数：如“创建一个新文件夹”的函数 普通程序 可直接进行系统调用，也可使用库函数。有的库函数设计系统调用，有的不涉及 编程语言 向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便 操作系统 向上提供系统调用，使得上层程序能请求内核的服务。 裸机 生活场景: 去学校打印店打印论文，你按下了WPS 的“打印”选项,打印机开始工作。你的论文打印到一半时，另一位同学按下了Word的“打印”按钮，开始打印他自己的论文。 思考: 如果两个进程可以随意地、并发地共享打印机资源，会发生什么情况?两个进程并发运行，打印机设备交替地收 到WPS和 Word两个进程发来的打印请求，结果两篇论文的内容混杂在一起了... 解决方法: 由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用”，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。 1.6.2 用到系统调用的功能 应用程序通过系统调用请求操作系统的服务（系统调用一定涉及中断和CPU状态切换）。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是与共享资源有关的操作（如存储分配、l/O操作、文件管理等)，都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。 1.6.3 系统调用过程 传递系统调用参数->执行陷入指令->执行相应的内请求核程序处理系统调用（核心态）->返回应用程序。 陷入指令实在用户态执行的，执行陷入指令后立即引发一个内中断，使CPU进入核心态 发出系统调用是在核心态,而对系统调用的相应处理在核心态下进行. 流程描述： CPU先处于用户态执行非特权指令，其中这些指令中包含传参指令，这些指令被执行后将参数传入寄存器，随后执行陷入指令，出发CPU中断信号，CPU切换为核心态，CPU切换为核心态后执行相应的中断处理程序，识别寄存器中的参数，判断执行什么样的内核程序，执行完毕之后主动将CPU状态切换为用户态，继续执行应用程序中的非特权指令。 1.6.4 总结 系统调用一定会设计到CPU状态的切换 1.7 操作系统的体系结构 1.7.1 操作系统的内核 时钟管理：是实现外中断和并发的必须的内核程序。 原语:是一种特殊的应用程序,具有原子性。也即是说这段程序的运行必须一气呵成，中间不允许被中断。 UbuntuCentOS的开发团队，其主要工作是实现非内核功能，而内核都是用了Linux内核 时钟管理、中断处理、原语是与硬件关联最紧密的部分 1.7.2 大内核与微内核 大内核：一些操作系统会把对系统资源进行管理的功能：如进程管理、存储器管理、设备管理等功能划分到内核中，这就是大内核。 微内核：一些操作系统不会把对系统资源进行管理的功能划分到内核中，这就是微内核。 操作系统内核功能需要运行在内核态，操作系统非内核功能需要运行在用户态 大内核与微内核性能上的区别： 如果一个应用程序想请求操作系统服务，而这个操作同时设计进程管理、存储器管理、设备管理 大内核情况下执行请求CPU只需切换两次状态，而微内核情况下需要切换六次状态 CPU切换状态是有成本的，需要消耗不少时间，频繁的变态会降低操作系统的性能 1.7.3 总结 典型的大内核/宏内核单/内核操作系统：Linux、UNIX 典型的微内核：WindowsNT 第二章 进程 2.1 进程的概念组成特征 同时挂三个QQ，会对应三个QQ进程。 程序：是静态的，就是存放在磁盘里的可执行文件，就是一些列的指令集合。 进程：（Processs）是动态的，是程序的一次执行过程。同一个程序的多次执行会对应多个进程 思考：操作系统是这些进程的管理者，它要怎么区分各个进程？ 2.1.1 进程控制块PCB PID：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的身份证号--PID（Process ID，进程ID） 进程控制块PCB： 操作系统要记录PID、进程所属用户ID（UID，基本的进程描述信息，可以让操作系统区分各个进程） 还要记录给进程分配了哪些资源（如分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件） 还要记录进程的运行情况（如CPU使用时间、磁盘使用情况、网络流量使用情况等） 这些信息都被保存到一个数据结构PCB中（Process Control Block）中，即进程控制块。 操作系统需要对各个并发运行的进程进行管理，但凡管理时所需的信息，都会被放进PCB中。 2.1.2 进程的组成 一个进程除了包括PCB，还要包括程序段、数据段 PCB：进程的唯一标识，是进程存在的唯一标识，当进程被创建时操作系统为其创建PCB，当进程结束时，会回收其PCB。 程序段：用于存放程序的代码。 数据段：用于存放程序运行过程中产生的数据。 PCB是给操作系统用的，而数据段与程序段是给自己用的。 同时挂3个QQ，会对应3个QQ进程，他们的PCB、数据段各不相同，但他们的代码段是相同的（都是运行着相同的QQ程序） 程序的运行过程： 一个进程实体（进程映像）是由PCB、程序段、数据段组成。 进程是动态的，进程实体是静态的，进程实体更像进程在某一时刻的快照，它反映了进程在某一时刻的状态 一个存放在硬盘中的程序经过双击运行后，会被加载的内存中，开始运行前会从创建对应的进程，即创建对应的PCB，然后在内存中会创建对应的程序段和数据段，程序段中存放着应用程序被编译后生成的指令，数据段中存放着程序运行中生成的数据，比如变量等。 总结： 程序段、数据段、PCB三部分组成了进程实体（进程映像），引入进程实体的概念后，可以把进程定义为：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。（一个进程被调度就是指操作系统让这个进程上CPU运行） 2.1.3 进程的特征 程序是静态的，进程是动态的，相比程序，进程拥有以下特征： 动态性：进程是程序的一次执行过程，是动态地产生、变化、消亡的（最基本的特征） 并发性：内存中有多个进程实体，各进程可并发执行 独立性：进程是能独立运行的、独立获得资源、独立接受调度的基本单位 异步性：各进程按各自独立的、不可知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题（异步性会导致并发程序执行结果的不确定性） 结构性：每个进程都会配置一个PCB，从结构上看，进程是由程序段、数据段、PCB组成。 总结 2.2 进程的状态与转换、进程的组织 2.2.1 进程的状态与转换 进程的PCB中，会有一个变量state来表示进程当前的状态。如1表示创建态，2表示就绪态，3表示运行态..... 进程共有五种状态：创建态、就绪态、运行态、阻塞态、退出态 创建态：进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源、初始化PCB。 就绪态：当进程创建完成后，进入就绪态，处于就绪态的进程已经具备了运行条件，但由于没有空闲的CPU，暂时不能运行。 运行态：如果一个进程此时在CPU上运行，那么这个进程处于“运行态”，此时CPU会执行该进程对应的程序（执行指令序列） 阻塞态：进程执行的过程中，可能会请求等待某个时间的发生，比如某种系统资源的分配，或者等待其他进程的相应。在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让他进入“阻塞态” 终止态：一个进程可以执行exit系统调用，请求操作系统终止该进程，此时该进程会进入“终止态”，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB。 进程各状态转换的流程： 进程在被创建时处于创建态；当系统完成创建进程的一些工作时进程转为就绪态，此时进程已具备执行的资源，但唯独缺少处理器文字；进程被调度后，被拿上CPU运行，此时进程处于运行态；进程用系统调用的方式申请某种系统资源（而该资源恰巧处于非空闲状态），或者请求等待某个事件发生，此时进程进入阻塞态；当进程申请的资源被分配，或等待的事件发生，此时进程又将进入就绪态；进程再次被调度后又会处于运行态；最后当进程运行结束或运行过程中遇到不可修复的错误时，进程会进入终止态。 就绪态可以通过进程调用转为运行态，当时间片用完或者CPU被抢占时进程状态会从运行态转为就绪态 运行态到阻塞态的转换是一种进程自身做出的主动行为 阻塞态到就绪态不是进程自身能控制的，是一种被动行为 不能由阻塞态直接转换称运行态，也不能由就绪态直接转为阻塞态（因为进入阻塞态意味着是进程主动请求的，必然需要进程在运行时才能发出这种请求） 总结： 注意： 进程的整个生命周期中，大部分时间处于运行态、阻塞态、就绪态三种基本状态 单CPU情况下，同一时刻只会有一个进程处于运行态，多核CPU中可能有多个进程处于运行态 2.2.2 进程的组织 为了对同一状态下的各进程进行统一股那里，操作系统会将各个进程的PCB组织起来，进程的组织方式有两种。 大部分操作系统采用的都是链式组织方式。 链接方式： 索引方式 总结： 2.2.3 总结 2.3 进程控制 2.3.1 什么是进程控制 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。 简化理解： 进程控制就是要实现进程状态转化 2.3.2 如何实现进程同步 用原语实现：原语是一种特殊的程序，它的执行具有原子性，也就是说这段程序的运行必须一气呵成，不能被打断 思考：为什么进程控制的过程要一气呵成？ 举例：假设PCB中的state表示当前进程所处状态，1表示就绪态，2表示阻塞态.... 假设此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做这样的两件事 PCB2的state设置为1 将PCB2从阻塞队列放到就绪队列 假设第一步后收到中断信号，那么PCB2的state=1，但是他却被放在阻塞队列中。所以如果此转换操作不能一气呵成的执行，就有可能导致操作系统中的耨写关键数据结构信息不统一，这会影响操作系统进行别的管理工作。因此，可以用原语来执行操作，不会被打断。 2.3.3 如何实现原语的原子性 原语的执行具有原子性，即执行过程只能一气呵成， 期间不允许被中断，可以用关中断指令和开中断指令实现原语的原子性。（两个特权指令） 操作系统每执行一条指令，都会例行检查是否有中断信号，CPU执行关中断指令后，就不再例行检查中断信号，知道执行开中断指令后才会恢复检查。 这样关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了原子性。 这两个特权指令不允许被用户程序执行，因为一旦被用户程序执行，可能就不会被终止。 2.3.4 进程控制相关原语 相关原语： 进程的创建：创建原语 进程的终止：撤销原语 进程的阻塞：阻塞原语 进程的唤醒：唤醒原语 进程的切换：切换原语 无论哪个进程控制原语，要做的无非就三件事 更新PCB信息 将PCB插入合适的队列 分配/回收资源 2.4 进程通信 进程间的通信方式有三种：共享存储、消息传递、管道通信 2.4.1 什么是进程通信 进程间通信（Inter-Process Communication,IPC）指两个进程之间进行数据交换。 举例： 拼多多中的商品可以分享到微信中。 拼多多和微信分别所属两个进程，但如果拼多多中的商品需要分享到微信，则需要进行两个进程间的通信，传递数据。 2.4.2 进程通信需要操作系统支持 进程是分配系统资源的单位（包括内存地址空间），因此进程拥有的内存地址空间相互独立。为了保证安全，一个进程不能直接访问另外一个进程的地址空间。 因此，操作系统为进程提供了三种进程通信方式： 共享存储 消息传递 管道通信 2.4.3 共享存储 共享存储又分为基于内存空间共享和基于数据结构共享 基于内存空间的共享 操作系统在内存中划出一块共享存储区，数据的形式、存储位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信 基于数据结构的共享 比如共享空间里只能放一个长度为10的数组，这种共享方式速度慢、限制多，是一种低级通信 2.4.4 消息传递 进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的发送消息/接收消息两个原语进行数据交换。 格式换的消息： 消息传递可分为：直接通信方式/间接通信方式 直接通信方式：消息发送进程要指明接收进程的PID 进程P如果想向进程Q发送数据，则需要在P的地址空间中封装好需要发送的格式化的数据，在操作系统的内核中存在进程Q的PCB，进程Q的PCB中存在一个进程Q的消息队列，进程P通过下面发送原语将数据发送到位于内核中进程Q的PCB的消息队列中。 //发送原语 seng(Q,msg) 随后进程Q通过下面的接收原语接受进程P发送的数据，将数据从PCB的消息队列中迁移到进程Q的地址空间中。 //接收原语 receive(P,&msg) 直接通信方式即点名道姓的消息传递 间接通信方式：又称信箱通信方式 进程P如果想想进程Q发送数据，需要先在进程P的地址空间中封装好格式化的数据，然后通过下面的发送原语，将数据发送到内核中的一个信箱中。 //发送原语,A表示A信箱 send(A,msg) 进程Q通过接收原语将A信箱中的数据迁移到Q的地址空间中。 //接收原语 receive(A,&msg) 可以多个进程往同一个信箱中send消息，也可以多个进程从同一个信箱中receive消息。 2.4.5 管道通信 管道是一种特殊的共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的内存缓冲区。管道具有先进先出的特性（FIFO），即先进入的数据，先被取出，类比水管 管道只能采用半双工通信，某一段时间内只能实现单向传输。如果要实现双向同时传输，则需要设立两条管道。 各进程要互斥的访问管道（由操作系统实现） 当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程 当管道读空时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程 管道中的数据一旦被读出，就彻底消失，当多个读进程读同一管道时，可能会错乱。对此，通常有两种解决方案。 一个管道允许多个写进程，一个读进程（教材规定） 允许有多个写进程，多个读进程，但操作系统会让各个读进程轮流从管道中读数据（Linux系统方案） 2.4.6 总结 写进程往管道写数据，即使管道没被写满，只要管道没空，读进程就可以直接从管道中读数据 读进程从管道中读数据，即便管道没被读空，只要管道没满，写进程就可以直接往管道中写数据 2.5 线程 2.5.1 为什么要引入线程 还没引入进程之前，系统中各个程序只能串行执行。如果想同时使用QQ开视频、文字聊天、传送文件仅靠一个进程是不能实现的（进程是程序的一次执行，但浙西功能显然不可能是由一个程序顺序处理就能实现的）。因此系统为QQ开辟了一个进程，而QQ为了实现同时开视频、文字聊天、传送文件这三个功能，又在进程中引入了线程。 进程引入的背景需求： 有的进程可能需要同时做很多事情（宏观上同时，微观上交替执行），而传统的进程只能串行地执行一系列程序。为此引入了线程，来增加并发度。 传统的进程是程序执行流的最小单位 引入了线程后，线程成为了程序执行流的最小单位。CPU可以并发地执行一个进程中的多个线程。 可以把线程理解为“轻量级的进程” 线程是一个基本的CPU执行单元，也是程序执行流的最小单位。引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（比如QQ视频、文字聊天、传文件） 引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等），CPU要分配给进程。 2.5.2 线程引入带来的变化 2.5.3 线程的属性 2.6 线程的实现方式 操作系统只能识别到内核级线程，不能识别到用户级线程。 2.6.1 用户级线程 早期的操作系统只支持进程，不支持线程（如Linux）。当时的线程是由线程库实现的。 举例： 如果想要同时使用QQ的视频聊天、文字聊天、文件传输功能，则需要在QQ进程中开启对应的三个“线程”，按照早期的操作系统，每一个线程代表了一段实现该对应功能的代码。 //进程1 public int run(){ while(true){ 处理视频聊天的代码; } } //进程2 public int run(){ while(true){ 处理文字聊天的代码; } } //进程3 public int run(){ while(true){ 处理文件传输的代码; } } 三个“线程的并发可以用如下代码实现”： //QQ进程 public int run(){ int i=0; while(true){ if(i=0){处理视频聊天的代码;} if(i=1){处理文字聊天的代码;} if(i=2){处理文件传输的代码;} i=(i+1)%3 } } 从代码角度看，线程其实就是一段代码逻辑。上述三段代码逻辑上可以看作三个“线程”。while循环就是一个弱智的“线程库”，线程库完成了对线程的管理工作（如调度） 很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能 问题： 线程的管理是由谁来完成？ 用户级线程是通过线程库来完成的，也就是上述代码中的while循环（实际上真正实现起来复杂得多） 线程切换是否需要CPU变态 线程切换由while循环控制实现，不涉及到请求操作系统服务，因此线程的切换不需要CPU变态。 操作系统是否能意识到用户级线程的存在 在用户看来，是有多个线程。但操作系统内核只能看到进程（存在于操作系统中 ）的存在，不能感知到用户级线程（存在于用户程序中）的存在。用户级线程就是从用户视角能看到的线程。 这种线程的实现方式有什么优点和缺点： 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，因为这些线程属于同一线程库，而操作系统只为该线程库分配了一个CPU，因此当该线程库种一个线程被阻塞时，该线程库种的其他进程都会被阻塞，并发度不高。多个线程不可在多核处理机上运行。 2.6.2 内核级别线程 内核级线程：由操作系统支持的线程（一对一多线程模型）。 大多数现代操作系统都实现了内核级线程，如Linux、Windows，在多核处理机情况下，进程是系统分配资源的基本单位，而线程是处理机调度的基本单位，所以内核级线程可以实现多CPU并发执行，提升了并发效率 问题： 线程的管理工作谁来完成？ 内核级线程是在操作系统层面实现的线程，因此线程的管理工作是由操作系统管理的。 线程切换是否需要CPU切换？ 线程的调度、切换等工作都是由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。 操作系统能否意识到内核级线程的存在？ 操作系统会为每个内核级线程建立相应的TCB(Thread Control Block 线程控制块)，通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看到能看到的线程” 这种线程的实现方式有什么优点和缺点？ 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理成本高，开销大。 两种方式都有自己的优点和缺点，因此需要一种方式使上述两种方式的优点和缺点结合起来。 2.6.3 多线程模型 在支持内核级线程的操作系统中，根据用户级线程与内核级线程的映射关系，可以划分为几种多线程模型。 2.6.3.1 一对一模型 一对一模型就是上边介绍的情况。 一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。 优点：当一个线程阻塞时，其他线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统完成，需要切换到核心态，因此线程管理成本高，开销大。 2.6.3.2 多对一模型 多对一模型：多个用户级别线程映射到一个内核级线程。且一个进程只被分配到一个内核级线程。 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，多个线程不可以在多核处理机上并行运行。 2.6.3.3 多对多模型 多对多模型：n个用户级线程映射到m个内核级线程（n>=m）。每个用户进程对应m个内核级线程。 优点：克服了多对一用户并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销过大的缺点。 2.7 总结 关于内核级线程与用户级线程的理解： 用户级线程是“代码逻辑的载体” 内核级线程是“运行机会的载体” 内核级线程才是处理机分配的单位。例如：多核CPU环境下，上边的进程最多能被分配到两个CPU 一段“代码逻辑”只有获得了“运行机会”才能被CPU执行。 内核级线程中可以运行任意一个有映射关系的用户级线程代码。只有两个内核级线程中正在运行的代码逻辑都被阻塞时，这个进程才会被阻塞。 2.7 处理机调度 2.7.1 调度的基本概念 例子1： 银行对普通客户的采取的措施就是先来先服务。对于VIP客户（存了几万个亿）可以优先被服务。 例子2： 排队上厕所时，时间短的人先进，时间长的最后进，如果时间相同，则谁排在前面谁先去。 当有一堆任务需要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是调度研究的问题。 2.7.2 高级调度（作业调度） 作业：一个具体的任务 用户向系统提交了一个作业=用户让操作系统启动一个程序（来处理一个具体的任务） 内存空间有限，无法将用户提交的作业全部放入内存，而是将作业放到处于外存的作业后备队列中 高级调度（作业调度）：调度的对象是作业（程序），按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调度时会建立PCB，调出时才会撤销PCB。 2.7.3 低级调度（进程调度/处理机调度） 低级调度（进程调度/处理机调度）按照某种策略从就绪队列中选取一个进程，将处理机分配给它。：调度对象是进程， 进程调度时操作系统中最基本的一种调度，在一般操作系统中都必须配置进程调度。 进程调度的频率很高，一般几十毫秒一次。 2.7.4 中级调度（内存调度） 内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调度到内存中。 暂时调到外存等待的进程状态为挂起状态文字。被挂起的进程PCB会被组织到挂起队列文字。 中级调度（内存调度）：调度对象是进程，按照某种策略决定将哪个处于挂起状态的进程重新调度到内存。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。 2.7.5 进程的挂起态与七状态模型 暂时调到外存等待的进程状态为挂起状态（挂起态） 挂起态进一步可以分为就绪挂起、阻塞挂起两种状态。 进程的五状态模型： 创建态：进程正在被创建，此阶段操作系统会为创建PCB，为进程分配资源。 就绪态：此阶段进程已经具备了上处理机运行的条件，其他系统资源均已经就绪，除了CPU 运行态：此阶段进程在CPU上运行，此时会执行该进程对应的程序指令 阻塞态：当进程主动请求某一系统资源或等待某一时间发生时，进程会变为阻塞态（主动行为） 终止态：进程执行完毕，执行exit系统调用，请求操作系统终止该进程的服务，此时进程会进入“终止态”，操作系统会回收进程的内存空间地址等资源，撤销进程的PCB。 进程的五状态模型图： 进程的七状态模型： 创建态 就绪态 运行态 阻塞态 阻塞挂起 就绪挂起 终止态 进程七状态模型图： 挂起态与阻塞态的区别： 两种状态都是进程暂时不能得到CPU服务，但是挂起态是将进程的映像调到外存（因为内存不足）中，而阻塞态进程映像还在内存中。 有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进一步细分为多个挂起队列。 2.7.6 三层调度对比 做什么 调度发生在 发生频率 对进程的影响 高级调度（作业调度） 按照某种规则，从后备队列中选择合适的作业将其调度到内存，并为其创建进程 外存->内存（面向作业） 低 无->创建态->就绪态 中级调度（内存调度） 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存 外存->内存（面向进程） 中 挂起态->就绪态（阻塞挂起->阻塞态） 低级调度（进程调度） 按照某种规则，从就绪队列中选择一个进程为其分配处理机 内存>处理机（面向进程） 高 就绪态->运行态 2.7.7 总结 2.8 进程调度的切换时机与过程 2.8.1 进程调度的时机 进程调度（低级调度）：就是按照某种算法从就绪队列中选择一个进程为其分配处理机 需要进行进程调度与切换的情况： 当前运行的进程主动放弃处理机（有的操作系统中，只允许进程主动放弃处理机） 进程正常终止 运行过程中发生异常而终止 进程主动请求阻塞（如等待I/O） 当前运行的进程被动放弃处理机（有的操作系统中允许进程主动放弃处理机，当有紧急事情时也会强行结束进程运行） 分给进程的时间片用完 有更紧急的事情需要处理（如I/O中断） 有更高优先级的进程进入就绪队列 不能进行进程调度与切换的情况 在处理中断的过程中。中断处理过程堵在、与硬件密切相关，很难做到在中断处理的过程中进行进程切换。 进程在操作系统内核程序临界区中。（进程位于普通的临界区中时可以进行调度与切换） 在原子操作系统过程中（原语）。原子具有不可中断性，要一气呵成的执行。 区分： 进程在操作系统内核程序临界区中不能进行调度与切换---------√ 进程处于临界区时不能进程处理机调度--------------× 临界资源：一个时间内只允许一个进程使用的资源，各进程需要互斥访问临界资源 临界区：访问临界资源的那段代码 内核程序临界区一般指用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程 的PCB组成） 两个案例： 进程访问就绪队列 进程在访问就绪队列时，就绪队列会上锁（临界资源），避免其他进程访问就绪队列。内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区间期间不能进行调度与切换。 进程访问打印机 此处打印机也属于临界资源，在打印机完成打印任务之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲。 普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。 2.8.2 进程调度方式 非剥夺调度方式：又称非抢占式。即只允许进程主动放弃处理机。在运行过程中即便有更加急迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动请求进入阻塞态。 特点：实现简单，系统开销小但是无法及时处理紧急任务，适用于载器的批处理系统。 剥夺调度方式：又称抢占式。当一个进程正在处理机上执行时，如果有一个更为重要或急迫的进程需要处理机，则立即暂停正在执行的进程，将处理机分配给该进程。 特点：可以优先处理更紧急的进程，也可以让各进程按时间片轮流执行的功能。适用于分时操作系统、实时操作系统。 2.8.3 进程的切换与过程 狭义的进程调度与进程切换的区别： 狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换） 进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。 广义的进程调度包含选择一个进程和进程切换两个步骤 进程切换的过程主要完成了： 对原来运行进程各种数据的保存 对新进程各种数据的恢复（如程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在PCB中） 进程切换是有代价的，因此过于频繁的进程调度、切换必然会使整个系统的效率降低，使系统大部分时间都花在进程切换，而真正用于执行进程的时间减少。 2.8.4 总结 2.9 调度算法的评价指标 调度算法的评价指标：CPU利用率、系统吞吐量、周转时间、等待时间、响应时间。 2.9.1 CPU利用率 CPU利用率：指CPU\"忙碌\"的时间占总时间的比例 利用率=忙碌的时间/总时间 举例：某计算机只支持单道程序，某个作业刚开始需要在CPU上运行5秒，再用打印机打印输出5秒，之后在执行5秒，才能结束。在此过程中，CPU利用率，打印机利用率分别是多少？ CPU利用率：（5+5）/（5+5+5）=66.66% 打印机利用率：5/15=33.33% 通常会考虑多道程序并发执行的情况，可以用”甘特图“来辅助计算。 2.9.2 系统吞吐量 对于计算机来说，希望能尽可能少的时间处理完尽可能多的作业。 系统吞吐量：单位时间内完成作业的数量 系统吞吐量=总共完成了多少道作业/总共花了多少时间 举例：某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为？ 10/100=0.1道/秒 2.9.3 周转时间 对于计算机的用户来说，他很关心自己的作业从提交道完成花了多少时间。 周转时间：指从作业被提交给系统开始，到作业完成为止的这段时间。 周转时间包括： 作业在外村后备队列上等待作业调度（高级调度）的时间 进程在就绪队列上等待进程调度（低级调度）的时间（可能发生多次） 进程在CPU上执行的时间（可能发生多次） 进程等待I/O操作完成的时间。（可能发生多次） 周转时间（作业）=作业完成的时间-作业提交时间（用户关心的） 平均周转时间=各作业周转时间之和/作业数（操作系统关心的） 有的作业运行时间短，有的作业运行时间长，因此在周转时间相同的情况下，运行时间不同的作业，给用户的感觉肯定是不一样的(因为周转时间相同，运行时间短的作业等待的时间肯定长)，因此引出了下面的带权周转时间。 带权周转时间=作业周转时间/作业实际运行的时间=（作业完成时间-作业提交时间）/作业实际运行时间（作业提交者关注的） 平均带权周转时间=各作业带权周转时间之后/作业数（操作系统关注的） 2.9.4 等待时间 计算机的用户希望自己的作业尽可能少的等待处理机 等待时间：指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低 对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在I/O完成的期间其实进程也在被服务，所以不计入等待时间。 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。 一个作业共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法只会影响作业/进程的等待时间。 2.9.5 响应时间 对于计算机用户来说，会希望自己提交的请求（比如通过键盘输入了一个调试命令）尽早的开始被系统服务、回应。 响应时间：指从用户提交请求到首次产生响应所用的时间。 2.9.6 总结 2.10 几种作业/进程调度算法 本节介绍三种常见的调度算法： FCFS：先来先服务 SJF：短作业优先 HRRN：高响应比优先 学习几种调度算法时，需要考虑各个算法的算法思想、算法规则、属于作业调度还是进程调度、抢占式还是非抢占式、优点和缺点、是否会饥饿 2.10.1 先来先服务 算法思想：主要从公平的角度考虑（类似我们生活中排队买东西的例子） 算法规则：按照进程/作业到达的先后顺序进行排序 调度对象：用于作业调度时，考虑的是哪个作业先到达后备队列，用于进程调度时，考虑的是哪个进程先到达就绪队列 是否可抢占：非抢占式算法 优缺点：优点：公平、算法时间简单；缺点：排在长作业（进程）后面的短作业需要等待很长时间，带去按周转时间很大，对短作业用户体验不好。即FCFS算法对长作业有利，对短作业不利 饥饿现象：不会 例子说明： 进程 到达时间 运行时间 P1 0 7 P2 2 4 P3 4 1 P4 5 4 先来先服务调度算法：按照到达的先后顺序调度，事实上就是等待时间越久的越优先的得到服务，调度顺序为：P1->P2->P3->P4 周转时间：完成时间-到达时间 P1=7-0=0，P2=11-2=9，P3=12-4=8，P4=16-5=11 带权周转时间：周转时间/运行时间 P1=7/7=1，P2=9/4=2.25，P3=8/1=8，P4=11/4=2.75 等待时间：周转时间-运行时间 P1=7-7=0，P2=9-4=5，P3=8-1=7，P4=11-4=7 本例中的进程都是纯计算型进程，一个进程到达后要么在等待，要么在运行。如果是又有计算、又有I/O操作的进程，其等待时间就是周转时间-运行时间-I/O操作时间。 平均周转时间： （7+9+8+11）/4=8.75 平均带权周转时间: (1+2.25+8+2.75)/4=3.5 平均带权周转时间： （0+5+7+7）/4=4.75 2.10.2 短作业优先 短作业优先按照是否为进程/作业是否是抢占式可分为：短进程优先（SPF）/短作业优先（SJF）、最短剩余时间优先（SNRT） 算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间 算法规则：最短的作业/进程优先得到服务（最短，指要求被服务的时间最短） 调度对象：既可用于作业调度也可用于进程调度。用于进程调度时成为“短作业进程优先算法SPF（Short Process First） 是否可抢占：SJF和SPF都是非抢占算法，但也有抢占式的版本——最短剩余时间优先算法SRTN（Short Remainding Time Next） 优缺点：优点：“最短的”平均等待时间、平均周转时间；缺点：不公平。文字。可能产生饥饿现象。进程/作业的运行时间由用户提供，不一定真实，不一定能做到真正的短作业优先。 是否会导致饥饿：会，如果源源不断的有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生饥饿现象。如果一直得不到服务，则称饿死 例子说明： 进程 到达时间 运行时间 P1 0 7 P2 2 4 P3 4 1 P4 5 4 非抢占式算法（SJF/SPF）: 短作业优先SJF/段进程优先SPF算法：每次调度时选择当前已到达且运行时间最短的作业/进程。调度顺寻为： P1->P3->P2->P4 0时刻只有P1到达，所以P1被服务，P1被服务完毕需要7秒，7秒后P2、P3、P4全部到达，此时根据谁的完成时间最小先服务谁，所以P3先被服务，P2、P4运行时间相同，所以两个任选其一被服务即可。 周转时间：完成时间-到达时间 P1=7-0=7，P2=12-2=10，P3=8-4=4，P4=16-5=11 带权周转时间=周转时间/运行时间 P1=7/7=1，P2=10/4=2.5，P3=4/1=4，P4=11/4=2.75 等待时间=周转时间-运行时间 P1=7-7=0，P2=10-4=6，P3=4-1=3，P4=11-4=7 平均周转时间： （7+10+4+11）/4=8 平均带权周转时间: (1+2.5+4+2.75)/4=2.56 平均带权周转时间： （0+3+6+7）/4=4 与FCFS算法相比，SPF/SJF算法的平均等待/周转/带权周转时间都要更低。 抢占式算法（SRNT）: 最短剩余时间优先算法：每当有进程加入就绪队列改变时就绪要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行的进程重新回到就绪队列。另外，当一个进程完成时也需要调度。 0时刻（P1到达）：P1（7） 2时刻（P2到达）：P1（5） P2（4） 4时刻（P3到达）：P1（5） P2（2） P3（1） 5时刻（P3完成且P4到达）：P1（5） P2（2） P4（4） 7时刻（P2运行完成）：P1（5） P4（4） 11时刻（P4运行完成）：P1（5） 16时刻（P5完成） 周转时间：完成时间-到达时间 P1=16-0=16，P2=7-2=5，P3=5-4=1，P4=11-5=6 带权周转时间：周转时间/运行时间 P1=16/7=2.28，P2=5/4=1.25，P3=1/1=1，P4=6/4=1.5 等待时间：周转时间-运行时间 P1=16-7=9，P2=5-4=1，P3=1-1=0，P4=6-4=2 平均周转时间=（16+5+1+6）/4=7 平均带权周转时间=（2.28+1.25+1+1.5）/4=1.5 平均等待时间=（9+1+0+2）/4=3 与非抢占算法SJF/SPF相比，平均周转时间、平均带权周转时间、平均等待时间均变小 注意： 如果题目中未特别说明，所提到的短作业/短进程优先算法默认都是非抢占式 很多书上说“SJF调度算法的平均等待时间、平均周转时间最少”，但严格来说最短剩余时间优先算法（SRNT）得到的时间更少。应该加上在所有进程同时可运行时，采用SJF调度算法的平均等待、平均周转时间最少。 虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（入FCFS），SJF依然可以获得较少的等待时间、平均周转时间 2.10.3 两种算法对比 FCFS算法是在每次调度时选择一个等待时间最长的作业/进程为其服务，但是没有考虑作业的运行时间，因此导致了对短作业不友好的问题。 SJF算法是选择一个执行时间最短的作业为其服务，但是又完全不考虑各个作业的平均等待时间，因此造成了对长作业不友好的问题，甚至还会造成饥饿问题。 因此，需要找到一种能顾及上述两种问题的算法 2.10.4 高响应比优先 响应比=（等待时间+要求服务的时间）/要求服务的时间 算法思想：综合考虑作业/进程的等待时间和要求服务的时间 算法规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。 调度对象：进程调度、作业调度 是否可抢占：非抢占式算法，因为只有当前运行的进程或作业主动放弃处理机时，才需要调度，才需要计算响应比 优缺点：综合考虑了等待时间和运行时间，等待时间相同时，要求服务时间段的优先（SJF优点）；要求服务时间相同时，等待时间长的优先（FCFS优点）；对于长作业来说，随着等待时间越久，其响应比越大，从而避免了长作业饥饿问题 是否会饥饿：不会 举例说明： 进程 到达时间 运行时间 P1 0 7 P2 2 4 P3 4 1 P4 5 4 高响应比优先算法：非抢占式调度算法，只有当前运行的进程主动放弃CPU时（正常/异常完成、或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机运行。 0时刻：只有P1到达，P1被服务 7时刻：P1完成服务，主动放弃处理机，各响应比：P2（响应比=（5+4）/4=2.25）、P3（（3+1）/1=4）、P4（（2+4）/4=1.5） 8时刻：P3完成，主动放弃，P2（2.5）、P4（1.75） 12时刻：P2完成，就绪队列中只剩P4 2.10.5 小结与回顾 算法 思想 可抢占 优点 缺点 考虑等待时间&运行时间 导致饥饿 FCFS 从公平角度考虑 非抢占 公平、实现简单 对短作业不利 等待时间√运行时间× 不会 SJF/SPF 追求最少的平均等待时间、平均周转时间、平均带权周转时间 SJF非抢占式；SRTN抢占式 最短的平均等待时间 对长作业不利，可能会导致饥饿，难以做到真正的短作业优先 等待时间×；运行时间√ 会 HRRN 综合考虑作业/进程的等待时间/要求非服务的时间 非抢占式 上述两种算法的这种，综合考虑等待时间、运行时间 等待时间√运行时间√ 不会 注：这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心响应时间，也不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适用于早期的批处理系统。 以下的算法才是现代计算机使用的交互算法。 2.10.6 时间片轮转 算法思想：公平的、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应。 算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。 调度对象：进程调度，只有作业放入内存建立了相应的进程后，才会被分配处理机时间片。 是否可抢占：若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到。 优缺点： 是否会饥饿： 举例： 进程 到达时间 运行时间 P1 0 7 P2 2 4 P3 4 1 P4 5 4 2.10.7 优先级调度 第三章 内存管理 3.1 内存的基础知识 3.1.1 什么是内存及其作用 内存可存放数据。程序执行前需要先放入内存中才能被CPU统一处理 作用：缓和CPU与硬盘之间的速度矛盾。 思考：在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中，那么，如何区分各个程序的数据存放在什么地方。 方案:给内存的存储单元编地址 以酒店房间为例: 内存中也有一个一个的小房间,每个小房间就是一个一个的存储单元 3.1.2 指令的工作原理 代码在执行前需要编译成计算机可以识别的0/1机器语言 以CPU执行上边经过编译之后的机器指令为例,红色二进制码表示操作码,代表着要做什么操做 指令1:数据传送指令，将01001111寄存器中的数据传送到00000011寄存器中。 指令2：加法指令，将00000011中的数据进行加1操做。 指令3：数据传送指令，将00000011中的数据加1后传送到位于内存中01001111的数据段中。 CPU怎么找到这些数据的？ 指令的工作方式（CPU执行指令的方式）是基于“地址”进行的，每一个地址对应着一个数据的存储单元。 3.1.3 写程序到运行程序 编译：由编译程序将用户源代码编译成若干个目标模块（编译就是将高级语言翻译为机器语言） 链接：由链接程序将编译后形成的一组目标模块，以及所需的库函数链接在一起，形成一个完整的装入模块。 装入（装载）：由装入程序将装入模块装入到内存 3.1.4 三种装入方式 装入其实就是解决逻辑地址向物理地址的改变 程序的执行流程： 程序的执行需要先使用编译器将高级语言编译成操做系统能识别的二进制机器指令，通过链接处理形成作业放到外存中的后备作业队列中，然后通过高级调度（作业调度）将作业加载到内存，操作系统为创建进程以及分配系统资源，通过处理机调度（低级调度）将作业（进程）拿上处理机运行。 3.1.3.1 绝对装入 绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照转入模块中的地址，将程序和数据装入内存。 举例：如果知道装入模块要从地址为100的地方开始存放 如果在编译时就知道程序装入模块要从哪个地方开始存放，则直接在编译时就修改模块中与内存地址有关的参数。 绝对装入只适用于单道环境的装入 3.1.3.2 可重定位装入 静态重定位：又称可重定位装入。编译、链接后的装入模块地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对对于起始地址而言的逻辑地址。可根据当前内存的使用情况，将装入模块装入到内存的适当位置，装入时对地址进行重定位，将逻辑地址换位物理地址（地址变换是在装入时一次完成的） 静态重定位的特点：在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间 3.1.3.3 动态重定位 动态重定位：又称动态运行时装入文字。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行的时候。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。 动态重定位的特点：允许程序在内存中发生移动。并且可将程序分配到不连续的存储区中；在程序运行前只需要装入它的部分代码即可投入运行，然后在程序运行期间根据需要动态申请分配内存，便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。 3.1.5 链接的三种方式 3.1.5.1 静态链接 在程序运行前，先将各目标模块及他们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。 3.1.5.2 装入时动态链接 将各个目标模块装入内存时，边装入边链接的链接方式。 3.1.5.3 运行时动态链接 在程序执行中需要该目标模块时，才对他进行链接。其优点是便于修改各更新，便于实现对目标模块的共享。 3.1.6 总结 3.2 内存管理的概念 操作系统作为系统资源的管理者，当然需要对内存进行管理，要管理些什么？ 内存的分配与回收 对内存空间进行扩充 逻辑地址与物理地址的转换 内存保护，保证各进程在各自的存储空间内运行，互不干扰 3.2.1 内存分配与回收 当有新进程需要进入内存时，操作系统要记录哪些内存区域已经被分配出去了，哪些内存处于空闲态。当有进程运行结束之后，还要考虑如何将内存空间进行回收。 3.2.2 对内存空间进行扩充 虚拟技术： 虚拟存储器技术 虚拟处理机技术 3.2.3 地址转换 为了使编程方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换（被称为地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。 逻辑地址到物理地址的转换，即程序的装入： 静态装入：编译时产生物理地址（早期单道批处理系统中） 可重定位装入：在装入时将逻辑地址转换为物理地址（早期的多道批处理系统中） 动态运行时转入：运行时将逻辑地址转换为物理地址，需要依靠重定位寄存器（现代操作系统中） 3.2.4 内存保护 内存保护即指各个进程仅在自己的内存区域中运行，与其他进程互不干扰 内存保护的两种方法： 在CPU中设置一对上、下限寄存器，存放进程的上下限地址。进程的指令要访问某个地址时，CPU检查是否发生越界。 当进程的指令要访问内存时，会先经过CPU中的地址寄存器的检查，检查要访问的地址是否超出了范围 采用重定位寄存器（又称基地址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。 3.2 总结 3.3 覆盖与交换 内存扩充的技术： 覆盖技术 交换技术 虚拟存储技术 3.3.1 覆盖技术 背景：早期的计算机内存很小，比如IBM退出的第一台PC机最大只支持1MB大小的内存，进场会出现内存空间不够的情况。 后来引入了覆盖技术，用来解决程序大小超过物理内存总和的问题 覆盖技术的思想：（多段程序公用一个内存块） 将程序分为）多个段（多个模块，常用的段常驻内存，不常用的段在需要时调度内存。 内存中分为一个固定区和若干个覆盖区 需要常驻内存的模块放在固定区，调入后就不再调出，除非运行结束。 不常用的段放在覆盖区，需要用到时调入内存，用不到时调出内存。 上图中A段程序需要经常被调用，因此需要把他放到内存中的固定区中，直到整个进程运行结束才能将其调出。 对于B、C程序，经常需要在两者之间调入调出的切换，因此可以把B、C两个程序段公用一个内存块（覆盖区），在这个内存块中可以根据处理机需求任意调入调出程序。 对于D、E、F三段程序，也经常需要在三者之间调入调出，因此把D、E、F三者公用一个内存块（覆盖区），在这个内存块中可以根据处理机需要任意调入调出三段程序。 如果将ABCDEF六段程序分别给予一块内存，则共需要52K内存，但如果使用了覆盖技术仅需要30K内存空间即可。因此使用覆盖技术可以大大增加内存的空间。 缺点： 必须有程序员声明覆盖结构，操作系统自动实现覆盖，因此对用户不透明，增加了用户编程负担。 3.3.2 对换技术 对换技术思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已经具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）-中级调度 中级调度（内存调度）：就是决定要将哪个挂起状态的进程重新调入内存。 扩展： 暂时换出外存等待的进程处于挂起状态（挂起态） 挂起态又可以分为就绪挂起、阻塞挂起两种状态 七状态模型： 应该在外存什么位置保存被换出的进程？ 具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。 文件区主要用于存放文件，主要追求存储空间的利用率，因此对换区空间的管理采用离散分配方式； 对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间管理主要追求换入换出的速度，因此对换区采用连续分配方式。 对换区的I/O速度比文件区要快。 什么时候完成交换？ 交换通常在许多进程运行且内存吃紧的时候进行，而系统负载降低就暂停 应该换出哪些进程？ 可优先换出阻塞进程，可换出优先级低的进程，为防止优先级低的进程在被调入内存后很快又被调出，有的系统还会考虑进程在内存的驻留时间。 3.3.3 总结 3.4 连续分配管理方式 连续分配：指为用户进程分配的内存必须是一个连续的内存空间 3.4.1 单一连续分配 单一连续分配中内存被分为系统区和用户区，操作系统将用户区内存划分成一个整体，只能供一个程序的进程使用，用户程序独占一个用户空间。因此单一连续分配存在于单道批处理阶段。 优点：实现简单，无外部碎片，可以采用覆盖技术扩充内存，不一定需要采取内存保护。 缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储利用率极低 3.4.2 固定分区分配 20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。 固定分区分配又可分为： 分区大小相等 分区大小相等，缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合。 分区大小不相等 分区大小不相等，增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小进行划分。 操作系统需要建立一张数据结构--分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态。 当某用户程序想装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为已分配。 优点：实现简单，无外部碎片 缺点：当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；会产生内部碎片，内存利用率低。 3.4.3 动态分区分配 动态分区分配又称为可变分区分配，这种分配方式不会预先划分内存分区，而是再进程装入内存时根据进程大小动态的建立分区，并使分区的大小正好适合进程需要，因此系统分区的大小和数目是可变的。 考点 第一章 重要考点： 单核CPU同一时刻只能执行一个程序，各个程序只能并发执行。 多核CPU同一时刻可以同时执行多个程序，多个程序可以并行执行 举例：Intel的第八代i3处理器就是4核CPU，意味着可以并行执行4各程序。如同时执行QQ、微信、谷歌浏览器、PPT，此时如果有第五个程序想要执行，则必须替换掉四个程序中的一个(即并发执行)。 即使对于4核CPU来说，只要有4各以上的程序需要“同时（宏观上）”运行，那么并发性依然是必不可少的，因此并发性是操作系统一个最基本的特性。 理解并发与并行的区别；并发与共享互为存在条件；没有并发和共享就谈不上虚拟和异步，因此并发和共享是操作系统的两个最基本的特征。 重点关注和理解各类操作系统主要用于解决什么问题，各自的优缺点 第二章 操作系统只能看见内核级线程，因此只有内核级线程才是处理机分配的单位 "},"14-408/2-数据结构/1-数据结构.html":{"url":"14-408/2-数据结构/1-数据结构.html","title":"2. 数据结构","keywords":"","body":"第一章 1.1 数据结构在学什么 如何用程序代码把现实世界的问题信息化 如何用计算机高效的处理这些信息从而创造价值 1.2 数据结构的基本概念 什么是数据？ 画家用画笔描述世界，音乐家用音符描述世界，而计算机专业人员用数据描述世界。 数据：数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理（二进制0和1）的符号的集合。数据是计算机程序加工的原料。 早期计算机处理的数据 世界上第一台通用计算机ENIAC，用于计算弹道轨迹等战争使用，只用于计算处理纯数值型问题。 现代计算机处理的数据 经常用于处理非数值型问题。 对于非数值型问题：我们关心每个个体的具体信息；关心个体之间的关系。 1.2.1 数据元素与数据项 数据元素：是数据的基本单位，通常作为一个整体进行考虑和处理 数据项：一个数据元素可以由若干个数据项组成，数据项是构成数据元素不可分割的最小单位。 数据对象：具有相同性质的数据元素的集合，是数据的一个子集。 数据元素：相互之间存在一种或多种特定关系的数据元素的集合。 区别与联系：数据元素强调数据元素之间必须要有一定的关系，而数据对象强调数据元素之间只要有相同的性质就可以从属一个数据对象。同一个数据对象种的数据元素可以组成不同的数据结构，如线性结构、网状结构等。不同的数据元素也可以组成相同的数据结构。 由于各数据元素可以组成不同的数据结构，因此数据结构这门课着重关注的是数据元素之间的关系，和对这些数据元素的操作。而不关心具体数据项的内容。 1.3 数据结构的三要素 1.3.1 逻辑结构 数据元素之间有四种基本关系，分别为集合、线性、树形、图状。 408考试大纲中，集合的考纲已经删除，因此不需要过多学习。 1.3.2 数据的运算 针对某种逻辑结构，结合实际需求，定义基本运算。 比如，线性结构基本运算可以包含以下几个方面： 查找第i个数据元素 在第i个位置插入新的数据元素 删除第i个位置的数据元素 1.3.3 物理结构 如何用计算机表示数据元素的逻辑关系，即如何在计算机中实现逻辑结构中定义的几种数据结构。 数据的存储结构： 顺序存储 链式存储 索引存储 散列存储 下面以线性结构为例，分别表示四种存储结构的实现。 1.3.3.1 顺序存储 逻辑上相邻的数据元素（因为是线性结构），存储在物理位置上也相邻的存储单元中。元素之间的关系由存储单元的邻接关系来体现。 1.3.3.2 链式存储 逻辑上相邻的数据元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。 1.3.3.3 索引存储 在物理内存中存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项一般形式是（关键字，地址） 1.3.3.4 散列存储 根据元素的关键字直接计算出该元素在物理内存中的存储地址，又称哈希（Hash）存储。 1.3.4 存储结构特点 若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用非顺序存储，则各个数据元素在物理上是可以离散的。如果在物理内存上找不到一块连续的地址空间，则就没法完成顺序存储。而非顺序存储则无需考虑此类问题。 数据的存储结构会影响存储空间分配的方便程度。 数据的存储结构会影响对数据运算的速度。如：对于数据元素a、c、d、e，以顺序存储形式存于内存中，若要在ac之间插入数据f，则必须先把de向后移动。 运算的定义是针对逻辑结构的，指出运算的功能；运算的实现（即代码实现）是针对存储结构的，指出运算的具体操作步骤。 1.3.5 数据类型和抽象数据类型 数据类型是一个值的集合和定义在此集合上的一组操作的总称。包括原子类型和结构类型： 原子类型：其值不可再分的数据类型。比如bool（布尔类型）、int类型 结构类型：其值可以再分解为若干成分（分量）的数据类型。比如下面的结构： struct Coordinate{ int x; int y; }; 抽象数据类型（ADT）：是抽象数据组织及与之相关的操作。 总结 1.4 算法的概念 1.4.1 什么是算法 程序=数据结构+算法 数据结构：如何用数据正确的描述现实世界的问题，并存入计算机。 算法：如何高效的处理这些数据，以解决实际问题。是求解问题的步骤。 算法：是对特定问题求解步骤的一中描述，它是指令的有限序列，其中每条指令表示一个或多个操作。 以制作西红柿炒鸡蛋为例： 其中数据结构对应的就是食材，算法对应的就是制作西红柿炒鸡蛋的步骤。 现在有以下需求：实现对下列任务按年龄从小到大排序的算法，下面五个元素呈线性关系。 算法：将该线性表按照年龄递增排序 Step1：扫描5个元素，找到年龄最小的一个元素，插入到第1个位置 Step2：扫描剩下的4个元素，找到年龄最小的一个元素，插入到第2个位置 Step3：扫描剩下的3个元素，找到年龄最小的一个元素，插入到第3个位置 Step4：扫描剩下的2个元素，找到年龄最小的一个元素，插入到第4个位置 1.4.2 算法的特性 算法有五个特性：有穷性、确定性、可行性、输入、输出 只要其中一个不满足，就不能称之为算法。 有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。注：算法必须是有穷的，而程序可以是无穷的。比如微信，不关闭就不会结束，因此可以说它是一个程序而不是算法，又比如for循环也不是算法。 确定性：算法中每条指令必须有明确的含义，对于相同的输入只能得到相同的输出。一个算法的结果输出必须确定。 可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。（说白了就是给出的算法能够用计算机代码来实现） 输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。 输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。 1.4.3 好算法的特质 一个好的算法要具备：正确性、可读性、健壮性、高效率和低存储量需求 正确性：算法能够正确的解决问题 可读性：算法应具有良好的可读性，以帮助人们理解 健壮性：输入非法数据时（比如年龄为负），算法能够适当的做出反应或进行处理，而不会产生莫名奇妙的输出结果。 高效率和低存储量需求：高效率指执行算法时电脑花的时间少（对应于时间复杂度），低存储量指执行算法时不费电脑内存（对应于空间复杂度低） 总结 1.5 算法的时间复杂度 1.5.1 事后估计运行时间的缺点 如果让算法先运行，事后统计运行时间的话会存在什么问题？ 与机器性能有关，如：超级计算机vs单片机 和编程语言有关，越高级的语言执行效率越低（如java>C） 和编译程序产生的机器指令质量有关 有些算法不能事后再统计的，如导弹控制算法 1.5.2 采用时间复杂度事先估计 通过分析算法的时间复杂度，来评估算法的时间开销。 事前预估算法时间开销T(n)与问题规模n的关系（T表示time） 举个时间复杂度计算的例子： 如何计算代码的时间复杂度？ 代码段中问题规模n=3000，所以：T(3000)=1+3001+2*3000+1 时间开销与问题规模n的关系表达式可以表示为：T(n)=3n+3 基于上述引出如下两个问题： 问题1：是否可以忽略表达式的某一部分？ 问题2：如果有好几千行代码，按这种方法需要一行一行读？ 1.5.3 时间复杂度计算方式 1.5.3.1 如何简化表达式 时间开销与问题规模n的关系 对于上述各时间复杂度，可以忽略掉表达式的某些部分，即转换成： T1（n）=3n T2(n)=n*n T3(n)=n n n 结论：可以只考虑阶数高的部分 加法规则： 多项相加，只保留最高阶的项，且系数变为1 乘法规则： 多项相乘，都保留 各阶数大小排序（重点记忆）： 记忆口诀：常对幂指阶 1.5.3.2 代码量过多该如何计算 通过对上述如何简化时间复杂度表达式的研究，发现只需要保留最高阶的项以及使最高阶的项系数等于1即可，因此可以根据此对代码量多的算法，计算其时间复杂度。 结论1：顺序执行的代码只会影响常数项，可以忽略 结论2：只需要挑循环中的一个基本操作分析它的执行次数与n的关系即可。 结论3：如果有多层嵌套循环，只需要关注最深处循环循环了几次。 例子1（嵌套循环）： 例子2： 例子3： 由于n的位置不确定，因此算法的时间复杂度也不确定，需要分情况讨论： 最好情况：元素n在数组的第一个位置上--最好时间复杂度为T(n)=O(1) 最坏情况：元素n在数组的最后一个位置上--最坏时间复杂度为T(n)=O(n) 平均情况：假设n在任意一个位置上的概率相同为1/n--平均时间复杂度为T(n)=O(n) 平均时间复杂度计算公式： 最坏时间复杂度：最坏情况下算法的时间复杂度（√） 平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间（√） 最好时间复杂度：最好请款下算法的时间复杂度（× 一般不考虑） 1.5.4 总结 "},"15-Project/1-小程序开发流程.html":{"url":"15-Project/1-小程序开发流程.html","title":"1. 小程序开发流程","keywords":"","body":"Flask项目开发流程 项目技术框架： Flask+MySQL+Redis+WTF+Werkzeug.security Flask：基本框架 MySQL：数据存储 Redis：缓存、短信/图片验证码、session WTF：防POST攻击 1.新建项目启动类：manage.py manage主要负责：启动文件,只需要负责启动整个项目即可，只是项目启动的入口文件。 其他的项目配置、路由函数、数据库、redis的初始化都不能出现在这，以版本号构建蓝图，将路由函数写进蓝图中 from nanyu import create_app, db # 导入创建flask应用对象的函数、数据库 # 通过命令行的形式来操作Flask # 下面数据库迁移时需要用到 from flask_script import Manager # 数据库迁移数据，flas——migrate版本不能较高：2.7.0 # Migrate为迁移的执行者；MigrateCommand为迁移的命令解析者 from flask_migrate import Migrate, MigrateCommand ''' manage主要负责:启动文件,只需要负责启动整个项目即可. 其他的项目配置、路由函数、数据库、redis的初始化都不能出现在这 以版本号构建蓝图，将路由函数写进蓝图中 ''' app = create_app(\"develop\") # 数据库迁移脚本 manager = Manager(app) # 设置命令行对象,通过命令行的形式来操作Flask Migrate(app, db) manager.add_command(\"db\", MigrateCommand) # 增加一条命令，db:为该命令的名称，MigrateCommand：指令的执行者 if __name__ == '__main__': manager.run() 2.创建配置文件config.py 该文件的作用：定义配置文件，配置MySQL数据库、Redis数据库。 SESSION_TYPE ：session的存储位置可以有多种，比如存储在内存、存储在MySQL数据库、存储在Redis等，flask中session默认保存位置为客户端的cookies里，使用flask-session可以修改session的保存位置。 secret_key：存在的意义是防止用户篡改session的（和jwt的秘钥类似） SESSION_USE_SIGNER = True：将cookie中的session隐藏 PERMANENT_SESSION_LIFETIME = 86400：设置session的有效时间 因为项目分为开发环境和生产环境两种情况，开发环境下需要用到DEBUG模式，而生产环境下不需要，没必要写两个类，因此将公共的配置写到Config类中，再写两个类继承Config类，这两个类分别表示开发环境和生产环境，在子类里配置不同环境下独有的配置。 不同环境下调用不同的类即可。 # 配置文件 # redis 用于存储缓存和session import redis ''' 1. 这个文件主要是存放项目的配置文件 2. 不使用键值对的原因：考虑到我们的项目会在开发模式和生产模式下运行， 因此使用定义配置类的方法更合适，可以使用类的继承来解决不同模式下的开发 ''' class Config(object): SECRET_KEY = \"XVNIEASANI0249*OHSD\" # 定义数据库 SQLALCHEMY_DATABASE_URI = \"mysql+pymysql://root:123456@127.0.0.1:3306/test\" SQLALCHEMY_TRACK_MODIFICATIONS = True # redis配置 REDIS_HOST = \"192.168.154.104\" REDIS_PORT = 6379 # flask-session配置 SESSION_TYPE = \"redis\" # 指明session的保存位置 ''' 指明redis的存储位置，实际生产中存储session的redis与存储缓存的redis不是一个服务器, 所以实际生产中可能需单独指定存储session的redis服务器 ''' SESSION_REDIS = redis.StrictRedis(host=REDIS_HOST, port=REDIS_PORT, encoding=\"utf-8\") SESSION_USE_SIGNER = True # 对cookie中的session进行隐藏 PERMANENT_SESSION_LIFETIME = 86400 # 设置session的数据有效期，单位s # 采用继承的方式解决不同生产环境下的配置 class DevelopmentConfig(Config): \"\"\"开发环境下的配置信息\"\"\" DEBUG = True # 只有开发环境下才需要DEBUG class ProductionConfig(Config): \"\"\"生产环境下的配置信息\"\"\" pass # 构建map键值对 config_map = { \"develop\": \"DevelopmentConfig\", \"product\": \"ProductionConfig\" } 3.创建日志文件夹log，用于存储网站日志 4.创建项目包nanyu，便于管理蓝图 4.1 项目基础配置 _init _ import redis import logging # Python提供的一个标准log模块，提供了一些记录日志的工具 from flask import Flask from flask_sqlalchemy import SQLAlchemy # 导入数据库 from flask_session import Session # 导入flask工具库 from flask_wtf import CSRFProtect # 引入csrf防护机制，开启csrf防护 from config import DevelopmentConfig, ProductionConfig # from logging.handlers import TimedRotatingFileHandler # 日志处理工具，帮助对日志进行切分，限制大小,无法解决多线程问题 from concurrent_log_handler import ConcurrentRotatingFileHandler # 引入该模块的原因：解决logging模块多线程问题 # from concurrent_log import ConcurrentTimedRotatingFileHandler # 引入该模块的原因：解决logging模块多线程问题 from nanyu.utils.commons import ReConverter # 数据库 db = SQLAlchemy() # 创建redis连接对象,需指明redis连接的主机地址及端口号 redis_store = None # 日志处理配置 # 设置日志的等级记录，四种日志级别：ERROR>WARN>INFO>DEBUG logging.basicConfig(level=logging.DEBUG) # 调试debug级 # 创建日志记录器，指明日志的存储路径，每个日志文件的大小，保存的日志文件个数上限:日志文件log;每个日志文件大小:100M;日志文件保存数:10 file_log_handler = ConcurrentRotatingFileHandler(\"logs/log\", maxBytes=1024 * 1024 * 100, backupCount=10, encoding='utf-8') # 生成日志的格式 formatter = logging.Formatter('%(levelname)s %(filename)s:%(lineno)d %(message)s') # 为全局的日志工具对象（flask app使用的）添加日志记录器 logging.getLogger().addHandler(file_log_handler) ''' flask工厂模式 在工厂模式中主要做了: 1. 根据实际情况选择生产或开发模式，创建不同模式下的app对象 2. 当flask应用对象app创建时，初始化数据库、redis 3. 当flask应用对象创建时，更改Session缓存机制、增加防护POST攻击请求机制 ''' def create_app(config_name): \"\"\" 创建flask的应用对象（app） :param config_name: str 配置模式名称：develop，product :return:flask对象app \"\"\" app = Flask(__name__) config_class = None if config_name == \"develop\": # config_class = config_map.get(config_name) config_class = DevelopmentConfig elif config_name == \"product\": config_class = ProductionConfig app.config.from_object(config_class) # 当create_app函数被执行时，自动把数据库对象与app绑定在一起 db.init_app(app) # 初始化redis，设置在初始化app时才初始化redis global redis_store redis_store = redis.StrictRedis(host=config_class.REDIS_HOST, port=config_class.REDIS_PORT, encoding=\"utf-8\", decode_responses=True) # 利用flask-session，将session数据保存到redis中 # flask-session工具可以改变session的存放位置,比如：redis、mongodb，memcached Session(app) # 为flask开启防护机制，防止POST请求攻击 # CSRFProtect(app) # 为flask添加自定义正则转换器，因为注册的蓝图最终还是要通过app统一管理，具有扫描和操作各蓝图中路由函数的权限，所以转换器虽然定义在app上，仍然可以在蓝图中使用。 app.url_map.converters[\"re\"] = ReConverter # 解决循环导包问题，什么时候用什么时候导包 from nanyu import api_1_0 # 注册蓝图，所有蓝图最终由app统一管理，app可以扫描和操作所有蓝图中定义的路由函数 app.register_blueprint(api_1_0.api, url_prefix=\"/api/v1.0\") # 注册提供静态文件的蓝图 from . import web_html app.register_blueprint(web_html.html) return app 4.1以版本号为依据划分蓝图，创建api1.0 4.2 创建数据模块models from . import db from datetime import datetime from werkzeug.security import generate_password_hash, check_password_hash # 基表 class BaseModel(object): \"\"\"模型为基类，为每个模型补充创建时间与更新时间\"\"\" create_time = db.Column(db.DateTime, default=datetime.now) update_time = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now) # 资源表 class Source(BaseModel, db.Model): __tablename__ = \"source\" id = db.Column(db.Integer, primary_key=True) # 主键 name = db.Column(db.String(24), nullable=False) # 资源名称 url = db.Column(db.String(256), nullable=False) # 资源链接 img_url = db.Column(db.String(256), nullable=True) # 资源链接 describe = db.Column(db.String(256), nullable=True) # 资源描述 admin_id = db.Column(db.Integer, db.ForeignKey(\"admin.id\")) # 所属管理员 category = db.relationship(\"Category\", secondary=\"source_category\", backref=\"sourcescategory\") # 资源分类 # 分类表 class Category(BaseModel, db.Model): __tablename__ = \"category\" # 分类对应资源：多对多，一个分类对应多个资源，一个资源对应多个分类 id = db.Column(db.Integer, primary_key=True) # 主键 Category_name = db.Column(db.String(12), nullable=False) # 分类名 # 资源-分类中间表 class SourceToCategory(BaseModel, db.Model): __tablename__ = \"source_category\" id = db.Column(db.Integer, primary_key=True) # 主键 Category_id = db.Column(db.Integer, db.ForeignKey(\"category.id\", ondelete='CASCADE')) source_id = db.Column(db.Integer, db.ForeignKey(\"source.id\", ondelete='CASCADE')) # 管理员表 class Admin(BaseModel, db.Model): __tablename__ = \"admin\" id = db.Column(db.Integer, primary_key=True) admin_name = db.Column(db.String(12), nullable=False, unique=True) admin_password = db.Column(db.CHAR(20), nullable=False) source = db.relationship(\"Source\", backref=\"admin\") # 用户表(测试使用，实际项目中不用此表) class User(BaseModel, db.Model): __tablename__ = \"user\" id = db.Column(db.Integer, primary_key=True) # 用户id name = db.Column(db.String(12), nullable=False) # 用户名 hash_passwd = db.Column(db.String(256), nullable=False) # 加密的密码 mobile = db.Column(db.String(11), nullable=False, unique=True) # 手机号 avatar_url = db.Column(db.String(128)) \"\"\" def generate_password_hash(self, orgin_password): # 对密码进行sha256加密,出入原始密码，对其进行加密后直接将结果赋值于hash_password self.hash_password = generate_password_hash(orgin_password) \"\"\" # 加上property装饰器后，会把函数转换为属性，属性名即函数名,这个属性和数据库没有任何关系，仅仅是为了给User这个类增加一个单纯的属性，与db没有关系 @property def password(self): \"\"\"读取属性的函数行为\"\"\" # 函数的返回值作为属性值 # return \"\" raise AttributeError(\"这个属性只能设置不能读写\") @password.setter def password(self, orgin_password): ''' 设置属性：user.password=\"xxxxxx\" :param orgin_password:原始密码 :return: ''' self.hash_passwd = generate_password_hash(orgin_password) def check_password(self, orgin_password): \"\"\" 检验密码的正确性 :param password:用户登录时填写的原始密码 :return:如果正确返回True，否则返回False \"\"\" return check_password_hash(self.hash_passwd, orgin_password) def to_dict(self): \"\"\"将对象转为字典\"\"\" d = { \"uid\": self.id, \"uname\": self.name, \"umobile\":self.mobile } return d class Area(BaseModel, db.Model): __tablename__ = \"area\" id = db.Column(db.Integer, primary_key=True) # 用户id name = db.Column(db.String(32), nullable=False) # 用户名 def to_dict(self): \"\"\"将对象转为字典\"\"\" d = { \"aid\": self.id, \"aname\": self.name } return d class Houses(BaseModel, db.Model): __tablename__ = \"houses\" id = db.Column(db.Integer, primary_key=True) # 用户id name = db.Column(db.String(32), nullable=False) # 用户名 houses_price = db.Column(db.String(32), nullable=False) # 加密的密码 4.3 创建工具类utils 4.4 创建静态文件夹static 4.5 创建constants常量 # 保存常量数据 # 图片验证码的redis有效期，单位为s IMAGE_CODE_REDIS_EXPIRE = 180 # 登录错误的尝试次数 LOGIN_ERROR_MAX_TIMES = 5 # 登录错误后，重试时间，单位为s LOGIN_ERROR_TIMES_LIMIT = 600 # 七牛图片域名 QINIIU_IMAGE_DOMAIN = \"https://dingzijun.com/\" # 城区信息的缓存时间,单位为s AREA_INFO_CACHE_EXPIRES = 7200 4.6 创建页面跳转web_html from flask import Blueprint, current_app, make_response from flask_wtf import csrf # 引入csrf防护 # 提供静态文件的蓝图 html = Blueprint(\"web_html\", __name__) # 127.0.0.0:5000/() # 127.0.0.0:5000/index.html # 127.0.0.0:5000/login.html # 127.0.0.0:5000/favicon.ico @html.route(\"/\") def get_html(html_file_name): \"\"\"提供html文件\"\"\" # 如果html_file_name为空，表示访问路径为/，请求的为主页 if not html_file_name: html_file_name = \"index.html\" if html_file_name != \"favicon.ico\": html_file_name = \"html/\" + html_file_name # 创建一个csrf_token的值,在用户第一次访问网站时就放入到cookies中 csrf_token = csrf.generate_csrf() # falsk提供的返回静态文件的方法,封装成一个response对象 resp = make_response(current_app.send_static_file(html_file_name)) # 设置cookies值,键值对形式;不设置cookie的有效期，默认是浏览器关闭cookie自动生效，下次打开网站重新生成cookie，如果设置长期有效，有风险，可能会失窃 resp.set_cookie(\"csrf_token\", csrf_token) return resp ​ "},"15-Project/2-项目管理系统.html":{"url":"15-Project/2-项目管理系统.html","title":"2. 项目管理系统","keywords":"","body":"1. 项目介绍 项目名称：项目管理系统，是一个用于管理项目的项目，本项目的前后端均由我一人完成。用到的技术都是最底层技术，目的也是为了巩固基础知识，先把底层的原理学会，学透彻，将来学习框架才会更容易。 后续会学习Spring、Mybatis、SpringMVC、SpringBoot、Thymeleaf、微服务、Vue等，后期会使用新的技术对项目进行升级与完善。 1.1 项目说明 项目中用到的技术栈：JDBC+Servlet+JSP+MySQL+Maven 开发环境： Win10+JDK 1.8 数据库：MySQL 5.6 后端环境：JSP+Servlet+JDBC 前端环境：HTML+CSS+JS+JQuery 运行环境：Tomcat 开发工具：VScode+IDEA 1.2 时间安排 第一周：使用原生的Html、CSS、JS完成所有前端页面 第二周：使用Java+Servlet+Maven+JSP+JDBC完成所有后端业务 2. 系统分析 所谓项目管理系统，就是管理项目的系统，由于本人有归纳的爱好，所有的东西都想要整理归纳好，所以突发奇想做出这个项目，同时也是自己的练手项目，巩固之前学习的所有知识，将学的所有知识整合到一起。 2.1 需求分析 从需求分析上看，整个项目很简单，分为用户信息管理、项目信息管理、项目Bug管理三个需求，这些功能都是在用户注册登录的基础上才能实现的，但是目前该项目不打算开放注册，仅供自己使用。在这三个功能的基础上还会再新增一些其他功能用于丰富整个项目。 2.2 角色分析 这是一个简单的项目，简单到项目中的角色只有一种，所有用户都是自己项目的管理员，用户登录之后即可修改个人信息、添加项目、删除项目、搜索项目、修改项目信息、新增Bug、修改Bug、删除Bug。另外，还会提供给用户登出功能。 后期如果学到新的技术、或者产生新的想法会再加入一些功能，完善整个项目，目前由于是练手项目，所以暂时只实现了这几个功能。 3. 系统设计 3.1 系统概述 项目共分为三大模块，各模块概述如下： 用户管理：用户登录系统之后，可以对自己的个人信息进行修改，具体的修改内容有：用户名、密码、头像（不确定有没有），还可以执行系统登出。 项目管理：用户登录系统之后，可以添加项目、删除项目、修改项目、查找项目，修改项目时可修改的项目信息有：项目名称、项目技术栈、项目上线地址（选填）、项目简介，开源与否（选填）、开源地址（选填） Bug管理：每个项目都避免不了存在Bug，在每个项目下面又提供了添加Bug、删除Bug、修改Bug的操作，修改Bug时可以修改的信息有：Bug简介、是否解决、解决方法 3.2 数据库设计 数据库project中有三张表： 用户表（User）：id、用户名、密码、头像URL、创建时间、更新时间、标识字段（标识是否注销） 项目表（project）：id、项目名称、项目介绍、用户id、项目线上地址、技术栈、开源与否、开源地址、创建时间、更新时间 Bug表（bug）：id、Bug简介、是否解决、解决方法、创建时间、更新时间，项目id、用户id 表的创建如下： 用户表： delete_flag字段标识注销标识字段，判断用户是否注销，注销为1，没注销为0. -- 创建数据库 create database project; drop table users; -- 创建表 create table users( id int primary key auto_increment comment '用户id', username varchar(20) unique not null comment '用户名', passwd varchar(25) not null comment '用户密码', avatar_url varchar(255) default 'https://picsum.photos/id/289/500/500' comment '头像地址', create_time timestamp default current_timestamp comment '创建时间', update_time timestamp default current_timestamp on update current_timestamp comment '更新时间', delete_flag int(2) default 0 comment '注销标识字段' )charset utf8 engine innodb; -- 添加两条数据 insert into users (username,passwd) values(\"南雨\",\"123456\"); insert into users (username,passwd) values(\"张三\",\"123456\"); 项目表： -- 创建项目表 drop table projects; create table projects( id int primary key auto_increment comment '项目id', project_name varchar(255) unique not null comment '项目名称', content longtext comment '项目简介', online_url varchar(255) not null comment '项目地址', skill_stack varchar(255) not null comment '技术栈', open_source int(2) not null default 0 comment '是否开源', source_url varchar(255) comment '开源地址', user_id int not null comment '所属用户id', create_time timestamp default current_timestamp comment '创建时间', update_time timestamp default current_timestamp on update current_timestamp comment '更新时间', foreign key(user_id) references users(id) on update cascade on delete cascade )charset utf8 engine innodb; Bug表 drop table bugs; -- Bug表 create table bugs( id int primary key auto_increment comment 'Bug id', content longtext not null comment 'Bug简介', solver_flag int(2) not null default 0 comment '是否解决', solver_content longtext comment '解决方法', user_id int not null comment '所属用户id', project_id int not null comment '所属项目id', create_time timestamp default current_timestamp comment '创建时间', update_time timestamp default current_timestamp on update current_timestamp comment '更新时间', foreign key(user_id) references users(id) on update cascade on delete cascade, foreign key(project_id) references projects(id) on update cascade on delete cascade )charset utf8 engine innodb; 3.3 界面设计 4. 系统实现 4.1 环境搭建 4.2 用户信息管理 4.3 项目管理 4.4 Bug管理 "},"15-Project/3-接口文档.html":{"url":"15-Project/3-接口文档.html","title":"3. 接口文档","keywords":"","body":"1. 接口名字 获取图片验证码 2. 接口描述 前端访问，可以获取到验证码图片 3. url /api/v1.0/image_codes/ 4. 请求方式 GET 5. 传入参数: 格式:路径参数（参数是查询字符串、请求的表单、json、xml） 名字 类型 是否必传 说明 image_code_id 字符串 是 验证码图片的编号 6. 返回值: 格式: 正常:图片 异常:json 名字 类型 是否必传 说明 errno 字符串 否 错误代码 errmsg 字符串 否 错误信息 实例: '{\"errno\":\"4001\",\"errmsg\":\"save image code id failed\"}' "}}