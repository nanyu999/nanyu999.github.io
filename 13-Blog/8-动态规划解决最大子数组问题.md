动态规划解决最大子数组问题

最大子数组问题：

- 输入：数组，一组数据

- 输出：Smax=max{s(l,r)}（l<=r）

```java
// 1. 问题结构分析

P[i,c]=max{P[i-1,c-v(i)]+p(i),P[i-1,c]} //左边选取该商品后的价格，右边为不选该商品后的价格
// Smax是输入的一组数据中最大的子数组的和，l表示开始元素的下标，r表示结束元素的下标
Smax=maxS{l,r}
// 优化后的枚举，S[l,r]：下标为l到下标为r的数组的和。
S[l,r]=S[l+1,r]+X[l]
// S[l,r]=S[l+1,r]+X[l]：表示下一个子数组的和，等于上一个子数组的和加x[r]
S[l+1,r]=S[l+2,r]+X[l+1]
......
S[r-1,r]=S[r,r]+X[r-1]
// 遍历到最后变成了从下标r到下标r，其结果就是X[r]
S[r,r]=X[r]
   
// 上面的代码有两个参数，下面是变成一个参数。
// D[i]:从下标为i开始的最大的子数组和
// D[1]:表示从1开始到下标为2、3、4、5、n的最大子数组的和，是个列表[D(1,2),D(1,3),D(1,n)]
// 从D[i]的得到的子数组和中选择一个最大的：max{D[i]} i∈{1,n}
D[i]=X[i]+X[i+1]+X[i+2]+......+X[n]
D[i+1]=   X[i+1]+X[i+2]+......+X[n]
D[i+2]=          X[i+2]+......+X[n]
......
D[n]=X[n]
i开头
D[i]=D[i+1]+X[i]
    
D[i]=  X[1]+X[2]+X[3]+......++X[i-1]+X[i]
D[i+1]=X[1]+X[2]+......+X[i-2]+X[i-1]
......
D[n]=X[n]
i结尾
D[i]=D[i-1]+X[i]


// 2. 递推关系建立
// 上述规律总结 
D[i]=X[i]+D[i+1]
// 求最大子数组和
D[i]=X[i]+D[i+1]	if D[i+1]>0,	max{D[i]}=X[i]+D[i+1]
D[i]=X[i]+D[i+1]	if D[i+1]<0,	max{D[i]}=X[i]

// 3.自底向上计算
1 2 3 4 5 6 7 8 9 10
2 -3 4 6 0 12 3 4 1
计算顺序，按照下标从后往前算
    3
// 4. 最优方案选取
// 备忘录Rec[i]取值为0、1，表示选取或不选取
Rec[i]=Rec[i+1]		if D[i+1]>0 //大于0的时候保留D[i+1]，表示选取了D[i+1]
Rec[i]=Rec[i]		if D[i+1]<0 // 小于0表示不选D[i+1]，D[i]就是最大的
```





动态规划四部曲

- 问题结构分析

- 递推关系建立

- 自底向上计算

- 最优方案追踪





## 子序列

将给定序列中零个或多个元素去掉后的结果

- 最大子数组和

- 最长公共子序列

最长公共子序列的要求：给定两个序列X和Y，要求两个子序列中存在的最长的公共子序列

如：

序列X：A B C B D A B

序列Y：B D C A B A

求两个数列中存在的最长公共子序列

```bash
输入：
序列X{x1,x2,x3....xm},序列Y{y1,y2....yn}

输出：
求解一个公共子序列Z={z1,z2,z3....zl}，令max{Z}

约束条件
# l是公共子序列的长度，m是序列X的长度，n是Y序列的长度
0<=l<min{m,n}
```

动态规划中的最优子结构性质：原问题的最优解肯定包含子问题的最优解

## 分治法解决最大子数组问题

学习通作业





## 动态规划解决最大子数组问题

学习通作业



## 贪婪算法

- 0-1背包问题定义：

输入：n个商品组成的集合O，每个商品有两个属性Vi和Pi，分别表示每个商品的体积和价格

输出：商品子集S<=O，令max(p1+p2+p3+...+pn)，(v1+v2+v3+..+vn)<=cs

- 部分背包问题：

问题背景：调制饮料比赛：参赛者拥有容量为800ml，可任选不超过体积上限的饮料进行混合，调制饮品价格为各所使用饮料价格之和，所得饮品价格之和最高者获胜

问题定义：

输入：n个商品组成的集合O，每个商品有两个属性Vi和Pi，分别表示每个商品的体积和价格

输出：商品子集S={Xi|1<=i<=n,0<=Xi<=1}，i∈S，

```
max求和(Xi*Pi)----------f(s)=max(x1p1+x2p2+x3p3+...+xnpn)   Xi∈(0,1]
约束条件:求和(XiVi)<=C------------(x1v1+x2v2+...xnvn)<=C
```

部分背包与0-1背包不同的是商品子集S的表示

1. 0-1背包中的S<=O,它表示从O中选择了哪些商品（O是所有商品的集合）
2. 部分背包中S={Xi|1<=i<=n,0<=Xi<=1}，它可以表示从商品集合中选择了哪些商品，同时也能表示每个商品的体积取了多少

| 饮料   | 价格体积 | 体积 |
| ------ | -------- | ---- |
| 苏打水 | 60       | 600  |
| 汽水   | 10       | 250  |
| 橙汁   | 36       | 200  |
| 苹果汁 | 16       | 100  |
| 西瓜汁 | 45       | 200  |

部分背包问题与0-1背包问题的区别：0-1背包中必须使用商品的全部体积，而部分背包中可以抽取商品的部分体积。

贪心解：橙汁200体积+苹果汁100体积+西瓜汁200体积+苏打水300体积，除了最后一个商品未选完体积，前面选的所有商品都会选择所有体积

最优解：对于选中的每一个商品，可能都只选择了该商品中的一部分体积，从每个商品中选择一部分体积，凑够800ml，使得价格最高

贪心算法伪代码

```java
i=1; // 初始化商品序号为1
price=0; //初始化价格为0
//表示当杯子还没装满，还有体积
while (C>0 and i<n){
    // 如果该商品的体积小于被子剩余体积，则全部倒入
    if (v[i]<=C){
    选择商品;
    price=price+p[i];
     // 体积减去 
    C=C-v[i];
    }else{
        
    }
    
    
}	
// 时间复杂度O(nlogn)
```



